{"./":{"url":"./","title":"前言","keywords":"","body":"前言前言 c++ 知识点 Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-10-30 22:01:13 "},"docs/multithreading.html":{"url":"docs/multithreading.html","title":"多线程","keywords":"","body":"多线程编程pthread_kill多线程编程 pthread_kill 如果是异常产生的信号(比如程序错误, 像SIGPIPE, SIGEGV这些), 则只有产生异常的线程收到并处理.如果是用pthread_kill产生的内部信号, 则只有pthread_kill参数中指定的目标线程收到并处理.如果是外部使用kill命令产生的信号, 通常是SIGINT, SIGHUP等job control信号, 则会遍历所有线程, 直到找到一个不阻塞该信号的线程, 然后调用它来处理. (一般从主线程找起, 注意只有一个线程能收到) 其次, 每个线程都有自己独立的signal mask, 但所有线程共享进程的signal action. 这意味着, 你可以在线程中调用pthread_sigmask(不是sigmask)来决定本线程阻塞哪些信号.但你不能调用sigaction来指定单个线程的信号处理方式.如果在某个线程中调用了sigaction处理某个信号, 那么这个进程中的未阻塞这个信号的线程在收到这个信号都会按同一种方式处理这个信号.另外, 注意子线程的mask是会从主线程继承而来的 Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-10-30 22:09:15 "},"docs/iterator.html":{"url":"docs/iterator.html","title":"迭代器失效","keywords":"","body":"迭代器迭代器失效迭代器 迭代器失效 vector 有序容器. 使用erase时不能使用 iter++ 来防止迭代器失效. 应当使用erase的返回值, erase的返回值为下一个迭代器位置. 如果为最后一个, 则返回end() 对于map 等关联的容器, 则需要使用iter++来防止迭代器失效。c++11前erase的返回值为void, 不过在c++11之后，关联容器的erase返回值也是返回下一个迭代器位置。 Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-10-30 22:10:16 "},"docs/rvalue_reference.html":{"url":"docs/rvalue_reference.html","title":"右值引用","keywords":"","body":"右值引用基本概念左值和右值左值引用和右值引用左值引用和右值引用的汇编代码const左值引用左值引用和右值引用的相互赋值右值引用和移动语义标准库move函数模板实参推断和引用引用折叠和右值引用参数理解右值引用折叠和右值引用类型推断当右值引用作为函数模板参数时move函数实现转发定义能保持类型信息的函数参数使用forward保持类型信息右值引用 基本概念 左值和右值 左值 赋值符号左边的值。左值是表达式（不一定是赋值表达式）后依然存在的持久对象。 右值 右边的值，是指表达式结束后就不再存在的临时对象。 c++11中将右值进一步划分为：纯右值、将亡值 纯右值 纯粹的右值 纯粹的字面量：如10、true 求值结果相当于字面量或匿名临时对象：如1+2 非引用返回的临时变量、运算表达式产生的临时变量、原始字面量、lambda表达式字符串字面量只有在类中才是右值，在普通函数中是左值 将亡值 即将被销毁、却能够被移动的值。如函数返回值的 左值引用和右值引用 传统的c++引用被称为左值引用用法如下: int i = 10; int & ii = i; c++11中增加了右值引用, 右值引用关联到右值时, 右值被存储到特定位置, 右值引用指向该特定位置, 也就是说, 右值虽然无法获取地址, 但是右值引用是可以获取地址的, 该地址表示临时对象的存储位置.语法如下:int && iii = 10; 左值引用和右值引用的汇编代码 以下汇编都是x86汇编 int i = 1; int & ii = i; 0x080483f3 movl $0x1,-0x10(%ebp) 0x080483fa lea -0x10(%ebp),%eax 0x080483fd mov %eax,-0x8(%ebp) 第一句是将1赋值给i, 第二句将i的地址放入eax中, 第三句将eax中的值传给ii. 可见引用就是从一个变量处取得变量的地址, 然后赋值给引用变量. 再看一句右值引用的汇编 int && iii = 10; 0x08048400 mov $0xa,%eax 0x08048405 mov %eax,-0xc(%ebp) 0x08048408 lea -0xc(%ebp),%eax 0x0804840b mov %eax,-0x4(%ebp) 第一句将10赋值给eax, 第二句将eax放入-0xc(%ebp)处, 前面说到\"临时变量会引用关联到右值时, 右值被存储到特定位置\", 在这段程序中, -0xc(%ebp)便是该临时变量的地址, 后两句通过eax将该地址存到iii处. 通过上述代码, 我们还可以发现, 在上述的程序中-0x4(%ebp)存放着右值引用iii, -0x8(%ebp)存放着左值引用, -0xc(%ebp)存放着10, 而-0x10(%ebp)存放着1, 左值引用和右值引用同int一样是四个字节(因为都是地址) 同时, 我们可以深入理解下临时变量, 在本程序中, 有名字的1(名字为i)和没有名字的10(临时变量)的值实际是按同一方式处理的, 也就是说, 临时变量根本上来说就是一个没有名字的变量而已.它的生命周期和函数栈帧是一致的. 也可以说临时变量和它的引用具有相同的生命周期 const左值引用 如果写如下代码, 定义一个左值引用, 将其值置为一个常量值 则会报错: int & i = 10; 原因很明显, 左边是一个左值引用, 而右边是一个右值, 无法将左值引用绑定到一个右值上.但是如果是一个const的左值引用, 是可以绑定到右值上的.即如下写法是符合语法规范的: const int & i = 10; 这段程序的汇编代码如下: 0x08048583 mov $0xa,%eax 0x08048588 mov %eax,-0x8(%ebp) 0x0804858b lea -0x8(%ebp),%eax 0x0804858e mov %eax,-0x4(%ebp) 易知-0x4(%ebp)处存放着i, -0x8(%ebp)处则存放着临时对象10, 程序将10的地址存放到了i处. 看到这里会发现const引用在绑定右值时和右值引用并没有什么区别 左值引用和右值引用的相互赋值 能将右值引用赋值给左值引用, 该左值引用绑定到右值引用指向的对象, 在早期的c++中, 引用没有左右之分, 引入了右值引用之后才被称为左值引用, 所以说左值引用其实可以绑定任何对象. 这样也就能理解为什么const左值引用能赋予常量值 int&& iii = 10; int& ii = iii; //ii等于10，对ii的改变同样会作用到iii 右值引用和移动语义 在旧的c++中, 出现了很多的不必须要的拷贝, 因为在某些情况下, 对象拷贝完之后就销毁了. 新标准引入了移动操作, 减少了很多的复制操作, 而右值引用正式为了支持移动操作而引入的新的引用类型 标准库move函数 根据右值引用的语法规则可知, 不能将右值引用绑定到一个左值上, c++11引入右值引用, 并且提供了move函数, 用来获得绑定到左值上的右值引用, 此函数定义在头文件utility中 int &&iii = move(ii) 调用move之后, 必须保证除了对ii赋值或销毁它外, 我们将不再使用它, 在调用move之后, 我们不能对移动源后对象做任何假设 模板实参推断和引用 为了理解move函数的实现, 首先需要理解模板实参推断和引用. 当左值引用作为参数时, 看几个例子: template void f1(T&) {} f1(i) //i是一个int，模板参数类型T是int f1(ci) //ci是一个const int，模板参数T是const int fl(5) //错误：传递给一个&参数的实参必须是一个左值 // 如果函数的参数是const的引用时： template void f2(const T&) {} f2(i) //i是一个int，模板参数类型T是int，因为非const可以转化为const f2(ci) //ci是一个const int，模板参数T是int f2(5) //看前面，const的引用可以绑定右值，T是int // 当参数是右值引用时， template void f3(T&&) {} f3(5) // T是int 引用折叠和右值引用参数 按照道理来说, f3(i)是应该不正确的, 因为无法将右值引用绑定到一个左值上, 但是, c++中有两个正常绑定规则的例外, 允许这种绑定. 这两个例外规则是move正确工作的基础 例外1: 右值引用的类型推断. 当我们将一个左值传递给函数的右值引用作为参数时(函数参数为T&&), 编译器推断模板类型参数为实参的左值引用类型, 因此, 调用f3(i)时, T被推断为int&, 而不是int. 并且, 模板函数中对参数的改变会反映到调用时传入的实参. 通常, 我们不能直接定义一个引用的引用, 但是同过类型别名(使用typedef)和模板间接定义是可以的. 例外2: 引用折叠. 当定义了引用的引用时, 则这些引用形成了\"折叠\", 所有的情况下(除了一个例外), 引用会折叠成一个普通的左值引用类型. 这个例外就是右值引用的右值引用: X& &、X& &&、X&& &都折叠成X& X&& &&折叠成X&& 理解右值引用折叠和右值引用类型推断 对于函数f3而言, 根据右值引用类型推断规则可以知道如下结果: f3（i） //实参是左值，模板参数T是int& f3（ci） //实参是左值，模板参数T是一个const int& 但是当T被推断为int&时，函数f3会实例化成如下的样子： void f3（int& &&） 然后根据右值引用折叠规则可以知道，上述实例化方式应该被折叠成如下样子： void f3(int&) 这两个规则导致了两个重要的结果： 如果一个函数参数是一个指向模板类型参数的右值引用, 如T&&, 则它能被绑定到一个左值, 且可以传递给他任意类型的实参. 如果实参是一个左值, 则推断出的模板实参类型将是一个左值引用, 且函数参数被实例化为一个普通左值引用参数(T&) 值得注意, 参数为T&&类型的函数可以接受所有类型的参数, 左值右值均可. 在前面, 同样介绍过, const的左值引用做参数的函数同样也可以接受所有类型的参数 当右值引用作为函数模板参数时 通过前面, 我们了解到当右值引用作为函数模板参数时, 类型T会被推断为一个引用类型. 这一特性会影响模板函数内部的代码, 看下面一段代码: template void f3(T &&val) { T t = val; t = fcn(t); if(val == t){…} } 假如以左值i来调用该函数, 那么T被推断为int&, 将t绑定到val之上, 对t的更改就被应用到val, 则if判断条件永远为true. 右值引用通常用于两种情况, 模板转发其实参, 模板被重载. 前面说到, const左值引用做参数和右值引用做参数一样, 是可以匹配所有的参数类型, 但当重载函数同时出现时, 右值引用做参数的函数绑定非const右值, const左值引用做参数的函数绑定左值和const右值(非const右值就是通过右值引用来引用的右值, 虽然无法获取右值的地址, 但是可以通过定义右值引用来更改右值): Template void f(T&&) //绑定到非const右值 Template void f(const T&) //左值和const右值 move函数实现 vs2017中move函数的定义如下 using remove_reference_t = typename remove_reference::type; template constexpr remove_reference_t&& move(_Ty&& _Arg) _NOEXCEPT { return (static_cast&&>(_Arg)); } template struct remove_reference { // remove reference using type = _Ty; }; template struct remove_reference { // remove reference using type = _Ty; }; template struct remove_reference { // remove rvalue reference using type = _Ty; }; 使用右值引用作为参数, 前面说过, 可以匹配所有类型. 以下两种方式都是正确的: string s1(\"s1\"),s2 s2 = move(string(\"bye!\")) //_Ty推断为string s2 = move(s1) //_Ty推断为string& 至于remove_reference就好理解了 综上, 可以发现move函数不管传入什么类型参数, 不管是左值还是右值, 都会返回其右值引用类型 转发 某些函数需要将其中一个或多个实参连同类型不变地转发给其他函数, 在这种情况下, 我们需要保持被转发实参的所有性质, 包括实参是否是const的, 以及是左值还是右值.有如下的两个函数, 在flip中调用f: void f(int v1, int &v2) { cout void flip(F f, T1 t1, T2 t2) { f(t2, t1); } 我们会发现f会改变第二个参数的值, 但是通过flip调用f之后就不会改变 f(42, i) flip(f, j, 42) 模板被实例化成如下： void flip (void(*fcn)(int, int&), int t1, int t2); j的值被拷贝到t1中, 所以flip中的f只会改变t1, 而不会改变j 定义能保持类型信息的函数参数 如果将flip的参数定义成右值引用, 根据上面描述过的规则, 当给flip传入引用时, T1被推断为int&, t1则被折叠成int&, 完美保持了实参的类型 template void flip(F g, T1&& t1, T2&& t2) { g(t2, t1); } // 但是当函数f接受右值引用作为参数的时候，flip就不能正常工作了 void g(int &&I, int j) { cout 注意: 这里的f和g都不是模板函数, 所以说前面提到的右值引用作为参数时的两个例外不能成立. 所以这里是错误的 使用forward保持类型信息 Forward需要显示提供实参类型, 返回该实参类型的右值引用(在前面可以看到, 右值引用是可以赋值给左值引用的) void flip(F f, T1&& t1, T2&& t2) { f(forward(t2), forward(t1)); } 当显式实参T是int&&时, forward返回int&& &&, 折叠成int&&. 当当显式实参T是int&时, forward返回int& &&, 折叠成int&. 所以说forward完美保持了参数的类型 Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-10-30 22:13:10 "},"docs/memory.html":{"url":"docs/memory.html","title":"内存分配","keywords":"","body":"内存分配new内存分配简介plain newnothrow newplacement new内存分配 new内存分配简介 new有三种使用方式: plain new, nothrow new和placement new plain new 顾名思义就是普通的new, 就是我们惯常使用的new. 在C++中是这样定义的: void* operator new(std::size_t) throw(std::bad_alloc); void operator delete(void *) throw(); 提示: plain new在分配失败的情况下, 抛出异常std::bad_alloc而不是返回NULL, 因此通过判断返回值是否为NULL是徒劳的 nothrow new 是不抛出异常的运算符new的形式. nothrow new在失败时, 返回NULL. 定义如下: void * operator new(std::size_t,const std::nothrow_t&) throw(); void operator delete(void*) throw(); placement new 意即\"放置\", 这种new允许在一块已经分配成功的内存上重新构造对象或对象数组. placement new不用担心内存分配失败, 因为它根本不分配内存, 它做的唯一一件事情就是调用对象的构造函数. 定义如下: void* operator new(size_t,void*); void operator delete(void*,void*); 提示1: palcement new的主要用途就是反复使用一块较大的动态分配的内存来构造不同类型的对象或者他们的数组。 提示2: placement new构造起来的对象或其数组, 要显示的调用他们的析构函数来销毁, 千万不要使用delete 第三种内存申请, 适用于反复使用一块较大的动态分配成功的内存来构造不同类型的对象或者他的数组 #include #include using namespace std; class ADT { public: ADT() = default; ~ADT() = default; private: int i; int j; }; int main() { char *p = new(nothrow) char[sizeof(ADT) + 2]; if(p == NULL) { coutADT::~ADT();//显示调用析构函数 delete [] p; return 0; } Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-10-30 22:14:38 "},"docs/brackets.html":{"url":"docs/brackets.html","title":"括号对创建对象的影响","keywords":"","body":"括号对创建对象的影响栈上创建对象堆上创建对象括号对创建对象的影响 class Test { public: 　　Test() {} 　　Test(int a) {} } 栈上创建对象 无括号 Test a; // 调用默认构造函数，栈上分配内存创建对象 有括号 ```　　　　 Test a(); // 无任何意义，声明一个返回值为Test对象的无参函数 3. 有括号+参数 ```　　 Test a(2); // 调用构造函数Test(int a)，栈上分配内存创建对象 堆上创建对象 无括号 ```　 Test *a = new Test; // 调用默认构造函数(若由编译器生成则成员不初始化), 堆上分配内存创建对象 2. 有括号 ```　　　　 Test *a = new Test(); // 调用默认构造函数（若由编译器生成则成员初始化），堆上分配内存创建对象 有括号+参数 ```　 Test *a = new Test(2); // 调用构造函数Test(int a)，堆上分配内存创建对象 4. 系统内置类型 ```　　　 new int; // 分配内存，未初始化 new int(); // 分配内存，初始化为0 new int(2); // 分配内存，初始化为2 Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-10-30 22:15:33 "},"docs/string.html":{"url":"docs/string.html","title":"字符串和字符串流的清空","keywords":"","body":"字符串和字符串流流的清空字符串和字符串流流的清空 字符串流清空 stringstream ss ss.str(\"\"); // 先赋值空字符串 ss.clear(); // 在执行clear. 字符串 清空string用 string str; str.clear(); // 这样只能清空数据, 不能改变容量, str.swap(); // 和空字符串进行交换, 就可有改变容量的大小了, 和空的交换 ,就是把大小变为0 Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-10-30 22:16:19 "},"docs/const.html":{"url":"docs/const.html","title":"容易记混的const关系","keywords":"","body":"记不住的const关系记不住的const关系 通过const对象调用函数只能调用const函数或者是static函数 通过const函数只能调用const函数或者static函数 Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-10-30 22:16:58 "},"docs/inherit.html":{"url":"docs/inherit.html","title":"虚继承","keywords":"","body":"虚继承单个虚继承, 不带虚函数单个虚继承, 带虚函数多重继承(带虚函数)钻石型虚继承虚拟继承如何表现虚继承 单个虚继承, 不带虚函数 虚继承与继承的区别 多了一个虚基指针 虚基类位于派生类存储空间的最末尾 单个虚继承, 带虚函数 如果派生类没有自己的虚函数，此时派生类对象不会产生虚函数指针 如果派生类拥有自己的虚函数, 此时派生类对象就会产生自己本身的虚函数指针, 并且该虚函数指针位于派生类对象存储空间的开始位置 多重继承(带虚函数) 每个基类都有自己的虚函数表 派生类如果有自己的虚函数, 会被加入到第一个虚函数表之中 内存布局中, 其基类的布局按照基类被声明时的顺序进行排列 派生类会覆盖基类的虚函数, 只有第一个虚函数表中存放的是真实的被覆盖的函数的地址; 其它的虚函数表中存放的并不是真实的对应的虚函数的地址, 而只是一条跳转指令 钻石型虚继承 虚基指针所指向的虚基表的内容: 虚基指针的第一条内容表示的是该虚基指针距离所在的子对象的首地址的偏移 虚基指针的第二条内容表示的是该虚基指针距离虚基类子对象的首地址的偏移 虚拟继承如何表现 存在即表示虚继承体系和虚基类确实存在间接性表现在当访问虚基类的成员时同样也必须通过某种间接机制来完成(通过虚基表来完成)共享性表现在虚基类会在虚继承体系中被共享, 而不会出现多份拷贝 Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-10-30 22:17:46 "},"docs/delete_derived.html":{"url":"docs/delete_derived.html","title":"delete基类指针释放子类和内存泄漏","keywords":"","body":"用基类指针delete子类会不会造成内存泄漏用基类指针delete子类会不会造成内存泄漏 当基类的析构函数是虚析构函数时, 用基类的指针delete时, 会调用子类的析构函数.如果基类不是虚析构函数, 则不会调用子类的析构函数, 可能会造成内存泄漏. Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-10-30 22:21:08 "},"docs/volatile.html":{"url":"docs/volatile.html","title":"volatile","keywords":"","body":"volatile参考volatile 易变性 在汇编层面可观察 下一条语句不会直接使用volatile变量的寄存器内容, 而是从内存重新读取. 不可优化 在汇编层面可观察 编译器不对volatile变量优化, 保证程序员写在代码中的指令一定被执行. 顺序性 volatile变量与非volatile变量的操作顺序, 有可能会被编译器交换, 导致出现多线程运行bug 期望: something = 0; volatile flag = true; void thread1() { something = 1; flag = true; } void thread2() { if (flag == true) { if (something == 1) { // 期望做这里的事情 // do something; } // do other something; } } 编译器优化后可能的情况. 实际上可能是这样: something = 0; volatile flag = true; void thread1() { flag = true; something = 1; } void thread2() { if (flag == true) { if (something == 1) { // do something; } // 实际上可能做这些事情 // do other something; } } 但是volatile变量之间的操作顺序不会被改变.cpu自己的优化, 也可能会导致操作顺序不一致, 不同的cpu架构, 可能会执行指令顺序不一样 参考 博客参考 Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-10-30 22:21:10 "},"docs/explicit.html":{"url":"docs/explicit.html","title":"explicit","keywords":"","body":"explicitexplicit 阻止参数类型到类对象类型的隐式转换。 跟它相对应的另一个关键字是implicit, 意思是隐藏的,类构造函数默认情况下即声明为implicit(隐式) 示例 #include using namespace std; class A { public: /* 加了explicit 之后，就不能发生其它类型到该对象类型的隐式类型转换了 */ /* explicit A(int num): num_(num) { }; */ A(int num): num_(num) { } /* 两个参数同样起作用 */ /* explicit A(int num1, int num2): num_(num1) { } */ A(int num1, int num2): num_(num1) { } int num() { return num_; } private: int num_; }; void foo(A a) { cout int这样的外部类型转换 */ float f = 15.333; A a(f); foo(a); return 0; } Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-10-30 22:21:46 "},"docs/compilation.html":{"url":"docs/compilation.html","title":"汇编与源码对照","keywords":"","body":"汇编与源码对照汇编与源码对照 汇编与源码对照 // 编译层汇编 g++ -S -fverbose-asm -g test.cpp -o test.s // 查看 as -alhnd test.s 查看方法定义信息 源码 #include int add(int, int); int main(void) { printf(\"result: %d\\n\", add(3, 4)); return 0; } int add(int a, int b) { return a + b; } 执行结果 $g++ -c test.cpp $nm -C test.o 0000000000000000 T main U printf 000000000000002b T add(int, int) 前面带有数字的表示该函数的定义在该文件中 Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-10-30 22:22:32 "},"docs/before_main.html":{"url":"docs/before_main.html","title":"在main函数之前执行函数","keywords":"","body":"在main函数之前执行函数在main函数之前执行函数 全局变量在main函数之前分配和初始化，结合cpp11的lambda表达式或普通函数调用，可以做到。 #include #include // 1 int foo() { std::cout Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-10-30 22:24:08 "},"docs/sizeof.html":{"url":"docs/sizeof.html","title":"c++与c的sizeof","keywords":"","body":"sizeofsizeof sizeof在c++和c里面略有不同 #include int main(void) { /* * 'a' 在c语言里面侧重于数字，在c++里面侧重于字符， * 侧重于数值（int类型）的输出当然是4个字节，而字符是1个字节。 * */ printf(\"char: %ld\\n\", sizeof('a')); /* * \"12345\" 默认为字符数组类型(arr[])， * 所以计算长度为 6(包含末尾的 `'\\0'` ) * 而 \"12345l\" + 1 发生了偏移，被转换为了指针， * 所以这里输出为 8(指针的大小) */ printf(\"array: %ld\\n\", sizeof(\"12345\")); printf(\"point: %ld\\n\", sizeof(\"12345\" + 1)); /* * 表达式可以从声明和解析上就能够知道数据类型，所以sizeof只需要知道类型就可以了， * 不需要对表达式进行计算。 * 所以 sizeof(++n) 中的 ++n不会进行计算的。 * */ int n = 10; printf(\"n = %d\\n\", n); sizeof(++n); printf(\"n = %d\\n\", n); return 0; } Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-10-30 22:24:22 "},"docs/map.html":{"url":"docs/map.html","title":"map","keywords":"","body":"mapmap 在一次代码中发现map出现的崩溃问题。 这样的代码可以通过编译，但运行时会崩溃。 #include #include using namespace std; int main(void) { std::map m; /* * 对于存放string的map * find方法会使用compare比较函数，如果map为空， * 那么即使传入一个map.end()也没问题， * 但是如果map不为空，传入map.end()就会出现无法比较 * */ // m[\"\"] = 1; /* 添加这样的赋值不会崩溃 */ m[\"hello\"] = 1; m.find(m.end()->first); /* 添加上m的赋值，该行就会崩溃 */ return 0; } Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-10-30 22:24:31 "},"docs/pod.html":{"url":"docs/pod.html","title":"pod类型","keywords":"","body":"pod类型pod类型 Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-10-30 22:25:03 "}}