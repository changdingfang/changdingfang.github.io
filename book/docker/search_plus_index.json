{"./":{"url":"./","title":"前言","keywords":"","body":"前言参考前言 Docker 是开放源代码的软件，是一个开放平台，用于开发应用、交付应用、运行应用。 Docker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的linux机器上，也可以实现虚拟化。 容器完全使用沙箱机制，相互之间不会有任何接口，更重要的是容器性能开销极低。 参考 docker菜鸟教程 docker Dockerfile命令详解 Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-25 18:31:45 "},"docs/install/docker-install.html":{"url":"docs/install/docker-install.html","title":"安装docker","keywords":"","body":"安装步骤ubuntuubuntu18.04ubuntu16.04CentOSalios安装步骤 ubuntu ubuntu18.04 更换国内软件源 推荐中国科技大学的源，稳定速度快（可选） sudo cp /etc/apt/sources.list /etc/apt/sources.list.bak sudo sed -i 's/archive.ubuntu.com/mirrors.ustc.edu.cn/g' /etc/apt/sources.list sudo apt update 安装需要的包 sudo apt install apt-transport-https ca-certificates software-properties-common curl 添加 GPG 密钥，并添加 Docker-ce 软件源这里以中国科技大学的 Docker-ce 源为例curl -fsSL https://mirrors.ustc.edu.cn/docker-ce/linux/ubuntu/gpg | sudo apt-key add - sudo add-apt-repository \"deb [arch=amd64] https://mirrors.ustc.edu.cn/docker-ce/linux/ubuntu $(lsb_release -cs) stable\" 添加成功后更新软件包缓存 sudo apt update 安装 Docker-ce sudo apt install docker-ce 设置开机自启动并启动 Docker-ce安装成功后默认已设置并启动，可忽略 sudo systemctl enable docker sudo systemctl start docker 测试运行 sudo docker run hello-world 添加当前用户到 docker 用户组可以不用 sudo 运行 docker（可选）sudo groupadd docker sudo usermod -aG docker $USER 测试添加用户组（可选） docker run hello-world ubuntu16.04 选择国内的云服务商，这里选择阿里云为例 curl -sSL http://acs-public-mirror.oss-cn-hangzhou.aliyuncs.com/docker-engine/internet | sh - 安装所需要的包 sudo apt-get install linux-image-extra-$(uname -r) linux-image-extra-virtual 添加使用 HTTPS 传输的软件包以及 CA 证书 sudo apt-get update sudo apt-get install apt-transport-https ca-certificates 添加GPG密钥 sudo apt-key adv --keyserver hkp://p80.pool.sks-keyservers.net:80 --recv-keys 58118E89F3A912897C070ADBF76221572C52609D 添加软件源 echo \"deb https://apt.dockerproject.org/repo ubuntu-xenial main\" | sudo tee /etc/apt/sources.list.d/docker.list 添加成功后更新软件包缓存 sudo apt-get update 安装docker sudo apt-get install docker-engine 启动 docker sudo systemctl enable docker sudo systemctl start docker CentOS alios 安装container-selinux 安装docker时，需要container-selinux yum install https://buildlogs.centos.org/c7-extras.x86_64/container-selinux/20180307170220/2.42-1.gitad8f0f7.el7.x86_64/container-selinux-2.42-1.gitad8f0f7.el7.noarch.rpm 添加docker-ce源 官方源可能会很慢，或者添加失败，可以尝试使用阿里源 官方源 yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo 阿里源 yum-config-manager --add-repo https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo 安装 yum install docker-ce 也可以安装指定版本(第一条命令查看版本列表) yum list docker-ce --showduplicates | sort -r yum install docker-ce- 启动 docker sudo systemctl enable docker sudo systemctl start docker Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-25 18:31:45 "},"docs/config/docker-config.html":{"url":"docs/config/docker-config.html","title":"配置docker","keywords":"","body":"配置开启rest api刷新配置生效默认docker.service文件默认的本地连接配置文件配置 开启rest api 在ExecStart选项中加入: -H tcp://0.0.0.0:2375 刷新配置生效 重新加载配置 $ systemctl daemon-reload 重启服务 $ systemctl restart docker.service 或 $ service docker restart 默认docker.service文件 路径: /lib/systemd/system/docker.service [Unit] Description=Docker Application Container Engine Documentation=https://docs.docker.com BindsTo=containerd.service After=network-online.target firewalld.service containerd.service Wants=network-online.target Requires=docker.socket [Service] Type=notify # the default is not to use systemd for cgroups because the delegate issues still # exists and systemd currently does not support the cgroup feature set required # for containers run by docker # ExecStart=/usr/bin/dockerd -H fd:// --containerd=/run/containerd/containerd.sock ExecStart=/usr/bin/dockerd -H fd:// -H tcp://0.0.0.0:2375 ExecReload=/bin/kill -s HUP $MAINPID TimeoutSec=0 RestartSec=2 Restart=always # Note that StartLimit* options were moved from \"Service\" to \"Unit\" in systemd 229. # Both the old, and new location are accepted by systemd 229 and up, so using the old location # to make them work for either version of systemd. StartLimitBurst=3 # Note that StartLimitInterval was renamed to StartLimitIntervalSec in systemd 230. # Both the old, and new name are accepted by systemd 230 and up, so using the old name to make # this option work for either version of systemd. StartLimitInterval=60s # Having non-zero Limit*s causes performance problems due to accounting overhead # in the kernel. We recommend using cgroups to do container-local accounting. LimitNOFILE=infinity LimitNPROC=infinity LimitCORE=infinity # Comment TasksMax if your systemd version does not support it. # Only systemd 226 and above support this option. TasksMax=infinity # set delegate yes so that systemd does not reset the cgroups of docker containers Delegate=yes # kill only the docker process, not all processes in the cgroup KillMode=process [Install] WantedBy=multi-user.target 默认的本地连接配置文件 路径: /lib/systemd/system/docker.socket [Unit] Description=Docker Socket for the API PartOf=docker.service [Socket] ListenStream=/var/run/docker.sock SocketMode=0660 SocketUser=root SocketGroup=docker [Install] WantedBy=sockets.target Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-25 18:31:45 "},"docs/cmd/live.html":{"url":"docs/cmd/live.html","title":"容器生命周期管理","keywords":"","body":"run语法选项注意事项使用示例start/stop/restart语法使用示例kill语法选项使用示例rm语法选项使用示例pause/unpause语法create语法使用示例exec语法选项使用示例run 创建一个新的容器并运行一个命令 语法 docker run [选项] 镜像 [命令] [参数...] 选项 -a stdin 指定标准输入输出内容类型，可选 STDIN/STDOUT/STDERR 三项 -d 后台运行容器，并返回容器ID -i 以交互模式运行容器，通常与 -t 同时使用 -P 随机端口映射，容器内部端口随机映射到主机的高端口 -p 指定端口映射，格式为：主机(宿主)端口:容器端口 -t 为容器重新分配一个伪输入终端，通常与 -i 同时使用 --name=\"nginx-lb\" 为容器指定一个名称 --dns 8.8.8.8 指定容器使用的DNS服务器，默认和宿主一致 --dns-search example.com 指定容器DNS搜索域名，默认和宿主一致 -h \"mars\" 指定容器的hostname -e username=\"ritchie\" 设置环境变量 --env-file=[] 从指定文件读入环境变量 --cpuset=\"0-2\" or --cpuset=\"0,1,2\" 绑定容器到指定CPU运行 -m 设置容器使用内存最大值 --net=\"bridge\" 指定容器的网络连接类型，支持 bridge/host/none/container: 四种类型 --link=[] 添加链接到另一个容器 --expose=[] 开放一个端口或一组端口 --volume , -v 绑定一个卷 需要使用绝对路径 注意事项 当docker将宿主机上的一个文件直接挂载到容器内时， 在宿主机上修改文件的内容后，在容器中看到该文件内容不变，或者容器中的该文件不见了 因为挂载绑定是基于文件系统的inode的，因为使用一般编辑器的行为会改变inode，所以宿主机上内容 的改变不会同步到容器内。 使用示例 使用docker镜像 nginx:latest 以后台模式启动一个容器,并将容器命名为 mynginx。 $ docker run --name mynginx -d nginx:latest 使用镜像 nginx:latest 以后台模式启动一个容器,并将容器的80端口映射到主机随机端口。 $ docker run -P -d nginx:latest 使用镜像 nginx:latest ，以后台模式启动一个容器,将容器的 80 端口映射到主机的 80 端口,主机的目录 /data 映射到容器的 /data $ docker run -p 80:80 -v /data:/data -d nginx:latest 绑定容器的 8080 端口，并将其映射到本地主机 127.0.0.1 的 80 端口上。 $ docker run -p 127.0.0.1:80:8080/tcp ubuntu bash docker容器的隔离是基于linux的capability机制实现的，linux的capability机制允许用户将超级用户相关的高级权限划分为不同的小单元，而时间修改就是一个小单元。而容器默认启动时没有该小单元的权限的，所以想要有该权限功能，就需要添加相应的小单元权限。添加 SYS_TIME 参数启动的容器，可以在容器内修改系统时间。 $ docker run --cap-add SYS_TIME --name hello ubuntu:18.04 bash start/stop/restart docker start 启动一个或多个已经被停止的容器 docker stop 停止一个运行中的容器 docker restart 重启容器 语法 docker start [选项] 容器 [容器...] docker stop [选项] 容器 [容器...] docker restart [选项] 容器 [容器...] 使用示例 假设有一个容器id为 dc1234567 的容器未启动，现在把它启动起来 $ docker start dc1234567 kill 杀掉一个运行中的容器 语法 docker kill [选项] 容器 [容器...] 选项 -s 向容器发送一个信号 使用示例 杀掉运行中的容器 mynginx $ docker kill -s KILL mynginx rm 删除一个或多个容器 语法 docker rm [选项] 容器 [容器...] 选项 -f 通过SIGKILL信号强制删除一个运行中的容器 -l 移除容器间的网络连接，而非容器本身。 -v 删除与容器关联的卷。 使用示例 移除容器 nginx01 对容器 db01 的连接，连接名 db： $ docker rm -l db 删除容器 nginx01, 并删除容器挂载的数据卷 $ docker rm -v nginx01 删除所有已经停止的容器 $ docker rm $(docker ps -a -q) pause/unpause docker pause 暂停容器中所有的进程。 docker unpause 恢复容器中所有的进程。 语法 docker pause [选项] 容器 [容器...] docker unpause [选项] 容器 [容器...] create 创建一个新的容器但不启动它 语法 docker create [选项] 镜像 [命令] [参数...] 使用示例 使用docker镜像 nginx:latest 创建一个容器,并将容器命名为 myrunoob $ docker create --name myrunoob nginx:latest exec 在运行的容器中执行命令 语法 docker exec [选项] 容器 命令 [参数...] 选项 -d 分离模式: 在后台运行 -i 即使没有附加也保持STDIN 打开 -t 分配一个伪终端 使用示例 更多可以参考run 以root用户身份进入test容器 docker exec -it --user root test bash Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-25 18:31:45 "},"docs/cmd/operation.html":{"url":"docs/cmd/operation.html","title":"容器操作","keywords":"","body":"ps语法选项使用示例inspect语法选项使用示例top语法使用示例attach说明语法使用示例events语法选项使用示例logs语法选项使用示例wait语法使用示例export语法选项使用示例port语法使用示例ps 列出容器 语法 docker ps [选项] 选项 -a 显示所有的容器，包括未运行的。 -f 根据条件过滤显示的内容。 --format 指定返回值的模板文件。 -l 显示最近创建的容器。 -n 列出最近创建的n个容器。 --no-trunc 不截断输出。 -q 静默模式，只显示容器编号。 -s 显示总的文件大小。 使用示例 $ docker ps 显示类似如下图 字段说明 字段 说明 CONTAINER ID 容器 ID IMAGE 使用的镜像 COMMAND 启动容器时运行的命令 CREATED 容器的创建时间 STATUS 容器状态 PORTS 容器的端口信息和使用的连接类型（tcp\\udp） NAMES 自动分配的容器名称 状态有七种(上图为什么显示的不是状态我还不太清楚) created（已创建） restarting（重启中） running（运行中） removing（迁移中） paused（暂停） exited（停止） dead（死亡） inspect 获取容器/镜像的元数据。 语法 docker inspect [选项] NAME|ID [NAME|ID...] 选项 -f 指定返回值的模板文件。 -s 显示总的文件大小。 --type 为指定类型返回JSON。 使用示例 获取正在运行的容器 mymysql 的IP $ docker inspect --format='{{range .NetworkSettings.Networks}}{{.IPAddress}}{{end}}' mymysql top 查看容器中运行的进程信息，支持 ps 命令参数。 语法 docker top [选项] CONTAINER [ps 选项] 使用示例 查看所有运行容器的进程信息 $ for i in `docker ps |grep Up|awk '{print $1}'`;do echo \\ &&docker top $i; done attach 连接到正在运行中的容器。 说明 要attach上去的容器必须正在运行，可以同时连接上同一个container来共享屏幕（与screen命令的attach类似）。 如果container当前在运行bash，CTRL-C自然是当前行的输入，没有退出；如果container当前正在前台运行进程，如输出nginx的access.log日志，CTRL-C不仅会导致退出容器，而且还stop了。这不是我们想要的，detach的意思按理应该是脱离容器终端，但容器依然运行。好在attach是可以带上--sig-proxy=false来确保CTRL-D或CTRL-C不会关闭容器。 语法 docker attach [选项] CONTAINER 使用示例 容器mynginx将访问日志指到标准输出，连接到容器查看访问信息。 $ docker attach --sig-proxy=false mynginx events 从服务器获取实时事件 语法 docker events [选项] 选项 -f 根据条件过滤事件； --since 从指定的时间戳后显示所有事件; --until 流水时间显示到指定的时间为止； 使用示例 显示docker 镜像为mysql:5.6 2016年7月1日后的相关事件。 $ docker events -f \"image\"=\"mysql:5.6\" --since=\"1467302400\" logs 获取容器的日志 语法 docker logs [选项] CONTAINER 选项 -f 跟踪日志输出 --since 显示某个开始时间的所有日志 -t 显示时间戳 --tail 仅列出最新N条容器日志 使用示例 查看容器 mynginx 从2020年7月1日后的最新10条日志。 $ docker logs --since=\"2020-07-01\" --tail=10 mynginx wait 阻塞运行直到容器停止，然后打印出它的退出代码。 语法 docker wait [选项] 容器 [容器...] 使用示例 $ docker wait CONTAINER_ID export 将文件系统作为一个tar归档文件导出到STDOUT。 语法 docker export [选项] 容器 选项 -o 将输入内容写到文件。 使用示例 将id为 a404c6c174a2 的容器按日期保存为tar文件。 $ docker export -o mysql-`date +%Y%m%d`.tar a404c6c174a2 port 列出指定的容器的端口映射，或者查找将PRIVATE_PORT NAT到面向公众的端口。 语法 docker port [选项] 容器 [PRIVATE_PORT[/PROTO]] 使用示例 查看 mymysql 容器的端口映射情况 $ docker port mymysql Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-25 18:31:45 "},"docs/cmd/rootfs.html":{"url":"docs/cmd/rootfs.html","title":"容器rootfs命令","keywords":"","body":"commit语法选项使用示例cp语法选项使用示例diff语法使用示例commit 从容器创建一个新的镜像。 语法 docker commit [选项] 容器 [仓库[:标签]] 选项 -a 提交的镜像作者； -c 使用Dockerfile指令来创建镜像； -m 提交时的说明文字； -p 在commit时，将容器暂停。 使用示例 将容器 a404c6c174a2 保存为新的镜像,并添加提交人信息和说明信息。 $ docker commit -a \"runoob.com\" -m \"my apache\" a404c6c174a2 mymysql:v1 cp 用于容器与主机之间的数据拷贝。 语法 docker cp [选项] [容器:源路径] [目标路径] docker cp [选项] [源路径] [容器:目标路径] 选项 -L 保持源目标中的链接 使用示例 将主机 /www/runoob 目录拷贝到容器 96f7f14e99ab 的 /www 目录下。 $ docker cp /www/runoob 96f7f14e99ab:/www/ diff 检查容器里文件结构的更改。 语法 docker diff [选项] CONTAINER 使用示例 查看容器 mymysql 的文件结构更改。 $ docker diff mymysql Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-25 18:31:45 "},"docs/cmd/images.html":{"url":"docs/cmd/images.html","title":"镜像仓库","keywords":"","body":"login/logout语法选项pull语法选项使用示例push语法选项使用示例search语法选项使用示例查看远端所有tag查看远端镜像所有taglogin/logout login 登陆到一个Docker镜像仓库，如果未指定镜像仓库地址，默认为官方仓库 Docker Hub logout 登出一个Docker镜像仓库，如果未指定镜像仓库地址，默认为官方仓库 Docker Hub 语法 docker login [选项] [SERVER] docker logout [选项] [SERVER] 选项 -u 登陆的用户名 -p 登陆的密码 pull 从镜像仓库中拉取或者更新指定镜像 语法 docker pull [选项] NAME[:TAG|@DIGEST] 选项 -a 拉取所有 tagged 镜像 --disable-content-trust 忽略镜像的校验,默认开启 使用示例 从Docker Hub下载java最新版镜像。 $ docker pull java 从Docker Hub下载REPOSITORY为java的所有镜像。 $ docker pull -a java push 将本地的镜像上传到镜像仓库,要先登陆到镜像仓库 语法 docker push [选项] NAME[:TAG] 选项 --disable-content-trust 忽略镜像的校验,默认开启 使用示例 上传本地镜像myapache:v1到镜像仓库中。 $ docker push myapache:v1 search 从Docker Hub查找镜像 语法 docker search [选项] TERM 选项 --automated 只列出 automated build类型的镜像； --no-trunc 显示完整的镜像描述； -s 列出收藏数不小于指定值的镜像。 使用示例 从docker hub查找所有镜像包含ubuntu, 并且star数大于20的镜像, 结果如下图 $ docker search -s 20 ubuntu 字段说明 字段 说明 NAME 镜像仓库源的名称 DESCRIPTION 镜像的描述 OFFICIAL 是否 docker 官方发布 stars 类似 Github 里面的 star，表示点赞、喜欢的意思 AUTOMATED 自动构建 查看远端所有tag function usage() { cat 查看远端镜像所有tag function usage() { echo \" 用法: bash ./dockertags [镜像名] 示例: bash ./dockertags ubuntu\" } if [ $# -lt 1 ]; then usage exit 0 fi image=\"$1\" tags=`wget -q https://registry.hub.docker.com/v1/repositories/${image}/tags -O - | \\ sed -e 's/[][]//g' -e 's/\"//g' -e 's/ //g' | tr '}' '\\n' | \\ awk -F: '{print $3}'` if [ -n \"$2\" ]; then tags=` echo \"${tags}\" | grep \"$2\"` fi echo \"${tags}\" Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-25 18:31:45 "},"docs/cmd/localimage.html":{"url":"docs/cmd/localimage.html","title":"本地镜像管理","keywords":"","body":"images语法选项使用示例rmi语法选项使用示例tag语法使用示例build语法选项使用示例history语法选项save语法选项使用示例load语法选项使用示例import语法选项使用示例images 列出本地镜像。 语法 docker images [选项] [REPOSITORY[:TAG]] 选项 -a 列出本地所有的镜像（含中间映像层，默认情况下，过滤掉中间映像层）； --digests 显示镜像的摘要信息； -f 显示满足条件的镜像； --format 指定返回值的模板文件； --no-trunc 显示完整的镜像信息； -q 只显示镜像ID。 使用示例 列出本地镜像中REPOSITORY为ubuntu的镜像列表。 $ root@runoob:~# docker images ubuntu rmi 删除本地一个或多少镜像。 语法 docker rmi [选项] IMAGE [IMAGE...] 选项 -f 强制删除； --no-prune 不移除该镜像的过程镜像，默认移除； 使用示例 强制删除本地镜像 runoob/ubuntu:v4 $ docker rmi -f runoob/ubuntu:v4 tag 标记本地镜像，将其归入某一仓库。 语法 docker tag [选项] IMAGE[:TAG] [REGISTRYHOST/][USERNAME/]NAME[:TAG] 使用示例 ubuntu:15.10 标记为 runoob/ubuntu:v3 镜像。 $ docker tag ubuntu:15.10 runoob/ubuntu:v3 build 命令用于使用 Dockerfile 创建镜像。 语法 docker build [选项] PATH | URL | - 选项 --build-arg=[] 设置镜像创建时的变量； --cpu-shares 设置 cpu 使用权重； --cpu-period 限制 CPU CFS周期； --cpu-quota 限制 CPU CFS配额； --cpuset-cpus 指定使用的CPU id； --cpuset-mems 指定使用的内存 id； --disable-content-trust 忽略校验，默认开启； -f 指定要使用的Dockerfile路径； --force-rm 设置镜像过程中删除中间容器； --isolation 使用容器隔离技术； --label=[] 设置镜像使用的元数据； -m 设置内存最大值； --memory-swap 设置Swap的最大值为内存+swap，\"-1\"表示不限swap； --no-cache 创建镜像的过程不使用缓存； --pull 尝试去更新镜像的新版本； --quiet, -q 安静模式，成功后只输出镜像 ID； --rm 设置镜像成功后删除中间容器； --shm-size 设置/dev/shm的大小，默认值是64M； --ulimit Ulimit配置。 --tag, -t 镜像的名字及标签，通常 name:tag 或者 name 格式；可以在一次构建中为一个镜像设置多个标签。 --network 默认 default。在构建期间设置RUN指令的网络模式 使用示例 使用当前目录的 Dockerfile 创建镜像，标签为 runoob/ubuntu:v1 $ docker build -t runoob/ubuntu:v1 . 使用URL github.com/creack/docker-firefox 的 Dockerfile 创建镜像 $ docker build github.com/creack/docker-firefox 也可以通过 -f Dockerfile 文件的位置 $ docker build -f /path/to/a/Dockerfile . history 查看指定镜像的创建历史。 语法 docker history [选项] IMAGE 选项 -H 以可读的格式打印镜像大小和日期，默认为true； --no-trunc 显示完整的提交记录； -q 仅列出提交记录ID。 save 将指定镜像保存成 tar 归档文件。 语法 docker save [选项] 镜像 [镜像...] 选项 -o 输出到的文件。 使用示例 打包时，使用镜像名和tag，因为在load时无法指定名字和tag，是按照打包的名字和tag进行复原的。 将镜像 runoob/ubuntu:v3 生成 my_ubuntu_v3.tar 文档 $ docker save -o my_ubuntu_v3.tar runoob/ubuntu:v3 load 导入使用 docker save 命令导出的镜像。 语法 docker load [选项] 选项 --input , -i 指定导入的文件，代替 STDIN。 --quiet , -q 精简输出信息。 使用示例 导入示例1 $ docker load 导入示例2 $ docker load --input fedora.tar import 从归档文件中创建镜像。 语法 docker import [选项] file|URL|- [REPOSITORY[:TAG]] 选项 -c 应用docker 指令创建镜像； -m 提交时的说明文字； 使用示例 从镜像归档文件 my_ubuntu_v3.tar 创建镜像，命名为 runoob/ubuntu:v4 $ docker import my_ubuntu_v3.tar runoob/ubuntu:v4 Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-25 18:31:45 "},"docs/cmd/info.html":{"url":"docs/cmd/info.html","title":"info/version","keywords":"","body":"info语法version语法选项info 显示 Docker 系统信息，包括镜像和容器数 语法 docker info [选项] version 显示 Docker 版本信息。 语法 docker version [选项] 选项 -f 指定返回值的模板文件。 Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-25 18:31:45 "},"docs/cmd/resource.html":{"url":"docs/cmd/resource.html","title":"资源","keywords":"","body":"Docker 资源Docker 国内镜像Docker 资源 Docker 官方主页 Docker 官方博客 Docker 官方文档 Docker Store Docker Cloud Docker Hub Docker 的源代码仓库 Docker 发布版本历史 Docker 常见问题 Docker 远端应用 API Docker 国内镜像 阿里云的加速 网易加速 官方中国加速 ustc 的镜 daoclou（注册后使用） Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-25 18:31:45 "},"docs/dockefile/dockefile.html":{"url":"docs/dockefile/dockefile.html","title":"Dockefile","keywords":"","body":"指令FROM语法使用示例RUN语法使用示例COPY语法使用示例ADD语法ENV语法使用示例EXPOSE语法VOLUME语法WORKDIR语法使用示例USER语法使用示例CMD语法ENTRYPOINT语法LABEL语法ARG语法使用示例ONBUILD语法使用示例STOPSIGAL语法SHELL语法使用示例Dockerfile文件示例指令 FROM 用于指定其后构建新镜像所使用的基础镜像FROM 启动构建流程后，Docker将会基于该镜像构建新镜像，后面的指令也会基于这个基础镜像 语法 FROM : FROM 必须是Dockerfile中的第一条非注释指令 在一个Dockerfile文件中创建多个镜像时，FROM可以多次出现，只需在每个新命令FROM之前，记录提交上次的镜像ID tag是可选的，如果不使用，则会使用latest版本的基础镜像 使用示例 FROM ubuntu:18.04 RUN 在镜像的构建过程中执行特定的命令，并生成一个中间镜像 语法 RUN 或 RUN [\"可执行文件\", \"param\", ... ] RUN 指令将当前的image中执行的任意合法命令提交执行结果。命令提交后，就会自动执行Dockerfile中的下一个指令 层级RUN指令和生成提交是符合Docker核心理念的做法。它允许像版本控制那样，在任意一个点，对image镜像进定制化构建 RUN指令创建的中间镜像会被缓存，并会在下次构建中使用。如果不想使用这些缓存，可以在构建时指定 --no-cache 参数，如: docker build --nocache 使用示例 RUN echo \"hello world\" COPY 语法 COPY ... 或 COPY [\"源路径\", ... \"目标路径\"] 源路径 可以是多个，也可以使用通配符，通配符需要满足 Go 的filepath.Match规则 目标路径 可以是容器内的绝对路径，也可以是相对于工作目录的相对路径 使用示例 COPY ./package /root COPY ./home/* /root ADD ADD指令和COPY的格式和性质基本一致。 ADD的源路径可以是一个URL 语法 ADD ... 或 ADD [\"源路径\", ... \"目标路径\"] 注意 如果docker发现文件内容被改变，则接下来的指令都不会再使用缓存。 ENV 设置环境变量 语法 ENV 或 ENV = = 使用示例 ENV VERSION=1.0 NODE_PATH=/home/.node \\ NAME=\"hello wrold\" EXPOSE 为构建的镜像设置监听端口，使容器运行时监听 语法 EXPOSE [...] EXPOSE指令并不会让容器监听主机的端口，这需要在运行时通过 -P 参数来发布容器端口到主机端口 VOLUME VOLUME用于创建挂在点，既向基于所构建镜像创始的容器添加卷 语法 VOLUME [\"/data\"] 卷可以在容器间共享和重用 修改卷后悔立即生效 对卷的修改不会对镜像产生影响 WORKDIR 指定容器内设置的一个工作目录 语法 WORKDIR 使用示例 WORKDIR /root USER 指定运行镜像所使用的用户 语法 UEER 使用示例 USER dingfang CMD 用于指定在容器启动时所要执行的命令 语法 CMD [\"可执行文件\", \"param\", ...] 或 CMD 命令 param... 注意 RUN是在构建时执行，CMD是在运行容器时执行 ENTRYPOINT 用于给容器配置一个可执行程序 也就是说，每次使用镜像创建容器时，通过 ENTRYPOINT 指定的程序都会被设置为默认程序 语法 ENTRYPOINT [\"可执行文件\", \"param\", ...] 或 ENTRYPOINT 命令 param... ENTRYPOINT 与 CMD 非常类似，不同的是通过docker run执行的命令不会覆盖 ENTRYPOINT，而docker run命令中指定的任何参数，都会被当做参数再次传递给 ENTRYPOINT。Dockerfile 中只允许有一个 ENTRYPOINT 命令，多指定时会覆盖前面的设置，而只执行最后的 ENTRYPOINT 指令。 docker run 运行容器时指定的参数都会被传递给 ENTRYPOINT ，且会覆盖 CMD 命令指定的参数。如，执行 docker run -d 时，-d 参数将被传递给入口点 LABEL LABEL用于为镜像添加元数据，元数以键值对的形式指定 语法 LABEL = = = ... 制定后可以通过 docker inspect 来查看元数据 ARG ARG用于指定传递给构建运行时的变量 语法 ARG [=] 在使用 docker build 构建镜像时，可以通过 --build-arg = 参数来指定或重设置这些变量的值。 使用示例 ARG test1 ARG test2=helloworld 上面指定了 test1 和 test2 两个变量, 其中 test2 设置了默认值 ONBUILD ONBUILD用于设置镜像触发器 当所构建的镜像被用做其它镜像的基础镜像，该镜像中的触发器将会被钥触发。 语法 ONBUILD [INSTRUCTION] 使用示例 ONBUILD ADD . /package ONBUILD RUN echo \"hello world\" STOPSIGAL STOPSIGNAL用于设置停止容器所要发送的系统调用信号 所使用的信号必须是内核系统调用表中的合法的值 语法 STOPSIGAL signal SHELL SHELL用于设置执行命令(shell式)所使用的的默认 shell 类型 一般用于无shell脚本命令, 如在windows系统 语法 SHELL [\"executable\", \"parameters\"] 使用示例 SHELL [\"cmd\", \"/S\", \"/C\"] Dockerfile文件示例 FROM ubuntu:18.04 MAINTAINER changdingfang ENV NODE_PATH=/root/.node/lib/node_modules \\ PATH=${PATH}:/root/.node/bin RUN apt-get update && apt-get install vim git nginx openssh-server -y WORKDIR /root COPY ./package/ /root/ COPY ./nginx/ /etc/nginx/ Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-25 18:31:45 "},"docs/other/docker.html":{"url":"docs/other/docker.html","title":"docker知识","keywords":"","body":"Dokcer是容器管理工具Docker不是虚拟化引擎Dokcer是容器管理工具 Docker是一个轻量级、便携式、与外界隔离的容器，它直接使用宿主机的内核和硬件，直接在宿主机上运行容器内应用。 也正因为如此，Docker容器内运行的应用和宿主机上运行的应用性能差距几乎可以忽略不计 但Docker本身不是一个容器系统，而是一个基于原有的容器化工具LXC用来创建虚拟环境的工具。 Docker不是虚拟化引擎 虚拟机是虚拟出一套硬件，虚拟机的系统进行的磁盘操作，其实都是在对虚拟出来的磁盘进行操作。当运行cpu密集型的任务时，是虚拟机把虚拟系统里的cpu指令“翻译”成宿主机的cpu指令并进行执行。 两个磁盘层，两个处理器调度器，两个操作系统消耗内存，所有虚拟出来的这些都会带来相当多的性能损失。 Docker运行应用采取的是“容器”的解决方案：使用namespace和CGroup进行资源限制，和宿主机共享内核，不虚拟磁盘，所有的容器磁盘操作其实都是对 /var/lib/docker/ 的操作。简言之，其实只是在宿主机中运行了一个受到限制的应用程序。 所以，宿主机是linux，只能通过虚拟机运行windows，docker便无法做到。 Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-25 18:31:45 "},"docs/other/network.html":{"url":"docs/other/network.html","title":"网络","keywords":"","body":"Docker网络模式查看docker的所有模式针对网络模式查看包含的容器通过容器信息查看网络模式Docker网络模式 查看docker的所有模式 docker network ls 输出示例 NETWORK ID NAME DRIVER SCOPE fc86dbb052ee bridge bridge local 24d213e42eb4 host host local 4abb34d88618 none null local 针对网络模式查看包含的容器 docker network inspect [DRIVER] 示例 docker network inspect bridge 执行后可以看到包含以下内容的输出，Containers 里面包含了使用了bridge模式的容器 \"Containers\": { \"25a79e42d86b2b26ee2514354acc3cf0c330f683a9da423b3580c4ceedb419d0\": { \"Name\": \"psfg\", \"EndpointID\": \"7b35657ddef0c89d6c99c4e6cdbb45cc81ef57131855a3ed34c5b85f95828a07\", \"MacAddress\": \"02:42:ac:11:00:02\", \"IPv4Address\": \"172.17.0.2/16\", \"IPv6Address\": \"\" } } 从上面示例知道 psfd 使用了 bridge网络模式 通过容器信息查看网络模式 docker inspect [容器] | grep -i \"network\" Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-25 18:31:45 "},"docs/other/q_a.html":{"url":"docs/other/q_a.html","title":"问题","keywords":"","body":"问题save 和 export的区别问题 save 和 export的区别 docker save 和 docker export 都能够导出镜像包，但为什么会出现两个命令呢？ save save是用来将一个或多个image打包保存的命令 使用 docker load 命令可以载入镜像包 export export是用来将container的文件系统进行打包的命令 将打包的容器载入进来需要使用 docker import 命令，载入后成为一个image，而不是恢复成为一个容器 场景 export主要用来制作基础镜像，而save用于保存运行过后的容器，保存快照； Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-25 18:31:45 "}}