{"./":{"url":"./","title":"前言","keywords":"","body":"前言参考前言 c++11/14/17特性归纳 在c++11及其之后标准中, 语言本身和标准库都增加了很多新内容. 里面的某些特性, 会让你在代码编写时更优雅. 参考 自由真实个性 白杨 jiange_zh DoubleLi c++ primer第五版 季末的天堂 c++参考手册 现代c++ Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-25 18:31:45 "},"docs/cpp11/language/nullptr.html":{"url":"docs/cpp11/language/nullptr.html","title":"nullptr","keywords":"","body":"nullptrnullptr NULL可以直接赋值给bool, int, float等类型(有些会编译警告), 而nullptr赋值给这些类型会编译报错. 比起NULL宏来说, nullptr常量更利于函数的重载. #include void f(int i) { std::cout 对于上面的代码, 使用NULL会编译报错(看到有些文章说会调用void f(int); 编译器不同, 还是有些差别的. 我是编译都不能通过). 使用nullptr会调用void f(int*s); Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-25 18:31:45 "},"docs/cpp11/language/strong_enum.html":{"url":"docs/cpp11/language/strong_enum.html","title":"强枚举类型","keywords":"","body":"强类型枚举强类型枚举 在传统的c++枚举类型中, 程序员必须为同一作用域每一个枚举项设定一个唯一的名字. 否则就会出现重命名. 而且它们会被隐式转换为int类型, 无法拥有特定的用户定义类型. 如下代码就是传统c++枚举出现重命名的问题(代码编译报错). #include enum E0 { Val1, Val2 }; enum E1 { Val, Val1 }; int main(void) { return 0; } c++11中引入强类型枚举的新类型, 不会将枚举常量暴露到外层作用域, 也不会隐式转换为int类型, 并且拥有用户指定的特定类型. 在c++11中, 传统的枚举类型也可以由用户指定特定类型. 如下代码可以正常编译. 枚举类型转换其它类型只能显式转换. #include enum class E2 : bool { Val1, Val2, }; enum class E3 { Val, Val1 }; int main(void) { //bool k = E2::Val1; /* error */ bool b = static_cast(E2::Val2); return 0; } Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-25 18:31:45 "},"docs/cpp11/language/auto_type.html":{"url":"docs/cpp11/language/auto_type.html","title":"类型推断","keywords":"","body":"类型推断auto关键字正确的用法类型推断 在c++11之前, auto关键字就已经存在, 之前的auto用于声明变量为自动变量, 自动变量意味着拥有自动的生命期. 就算不使用auto声明, 变量依旧默认是有自动的生命期. int a = 10; /* 拥有自动生命期 */ auto int b = 10 /* 拥有自动生命期 */ static int c = 01 /* 延长生命期 */ 在c++11之前, 对auto的使用是极少的, 在c++11已经删除了这个用法, 取而代之的是全新的auto: 变量的自动类型推断. #include #include int main(void) { auto a = 20; auto b = 20LL; auto c = \"hello world\"; if (typeid(a) == typeid(int)) { std::cout 上面代码输出: a is int b is long long c is const char * 从输出可以看出, auto 推断出a为int类型, b 为long long类型, c为const char * 类型; 在编程时不建议这样使用auto, 直接写出变量的类型更加的清晰易懂. auto的自动类型推断发生在编译期, 所以使用auto并不会造成程序运行时效率的降低.而是否会造成编译期的时间消耗, 我认为是不会的, 在未使用auto时, 编译器也需要得知右操作数的类型, 再与左操作数的类型进行比较, 检查是否可以发生相应的转化, 是否需要进行隐式类型转换. auto关键字正确的用法 用于代替冗长复杂, 变量使用范围专一的变量声明 #include #include int main(void) { /* 传统写法 */ std::vector vs1; for (std::vector::iterator i = vs1.begin(); i != vs1.end(); i++) { /* ... */ } /* 使用auto */ std::vector vs2; for (auto i = vs2.begin(); i != vs2.end(); i++) { /* ... */ } /* 配合范围的遍历操作更加简洁 */ std::vector vs3; for (auto &i : vs3) { /* ... */ } return 0; } 从上面可以看出, 使用auto, 会使代码变得非常简洁. 在定义模板函数时, 用于声明依赖模板参数的变量类型 #include template void Multiply(_Tx x, _Ty y) { auto v = x * y; std::cout 在模板函数中, 我们很难确定x * y的真正类型, 这样使用auto就很容易定义函数了. 模板函数依赖于模板参数的返回值.decltype 是检查实体的声明类型, 或表达式的类型和值类别的一个关键字. 返回值后置式声明语法也是c++11的特性. #include template auto multiply(_Tx x, _Ty y)->decltype(x * y) { return x * y; } int main(void) { return 0; } 当模板函数的返回值依赖于模板的参数时, 我们无法在编译代码前确定模板参数的类型, 也无法知道返回值类型, 这时候可以使用auto.auto在这里只是返回值占位, 它只是为函数返回值占了一个位置, 真正的返回值是后面的decltype(_Tx * _Ty). 为什么要用返回值后置式声明语法呢?如果没有后置, 那么声明就是decltype(x * y) multiply(_Tx x, _Ty y), 而此时x, y还没有声明, 编译时无法通过的.使用返回值后置式函数声明语法, 返回值类型的位置必须记做 \"auto\" 注意事项: auto变量必须在定义时初始化.函数或模板参数不能被声明为auto定义在一个auto序列的变量, 必须始终推到成同一类型 例如: auto a1 = 1, a2 = 12, a3 = 30; /\\* 正确 \\*/ auto a4 = 1, a5 = 1.1, a6 = 'k'; /\\* 错误, 没有推到成为同一类型 \\*/ auto仅仅是一个占位符, 它并不是一个真正的类型, 不能使用一些以类型为操作数的操作符, 如sizeof, typeid等. Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-25 18:31:45 "},"docs/cpp11/language/foreach.html":{"url":"docs/cpp11/language/foreach.html","title":"基于范围的遍历操作","keywords":"","body":"基于范围的遍历操作基于范围的遍历操作 遍历容器时支持\"foreach\" 用法. 可以遍历c类型的数组, 初始化列表以及任何冲在了begin()和end()函数的类型. 写法非常简洁: #include int main(void) { int arr[] = {1, 20, 9, 4, 111, 53, 23, 7}; //for (const auto &val : arr) for (const int &val : arr) { std::cout Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-25 18:31:45 "},"docs/cpp11/language/default_member.html":{"url":"docs/cpp11/language/default_member.html","title":"委托和成员默认初始值","keywords":"","body":"委托和成员默认初始值委托和成员默认初始值 一个构造函数可以调用该类中的其它构造函数来完成部分初始化任务(委托).声明成员时可以直接指定默认初始值. #include class A { public: A(int new_number) : m_nNumber(new_number) { std::cout Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-25 18:31:45 "},"docs/cpp11/language/alias_template.html":{"url":"docs/cpp11/language/alias_template.html","title":"类型别名模板","keywords":"","body":"类型别名模板类型别名模板 #include #include #include template class MagicType { public: T d; U m; }; typedef int (*pf)(void *); using pf2 = int(*)(void *); template using cType = MagicType, std::string>; // 无法使用typedef定义类模板别名 // template // typedef MagicType, std::string> cType2; int main(void) { return 0; } Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-25 18:31:45 "},"docs/cpp11/language/default_template.html":{"url":"docs/cpp11/language/default_template.html","title":"默认模板来参数","keywords":"","body":"默认模板参数默认模板参数 提供了默认模板参数类型 template T foo(T x) { return x; } int main(void) { return 0; } Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-25 18:31:45 "},"docs/cpp11/language/template_param.html":{"url":"docs/cpp11/language/template_param.html","title":"模板可变参数","keywords":"","body":"模板的可变参数模板的可变参数 为模板方法提供了类似普通函数的可变参数(...)支持. #include void f() { std::cout void f(T t, Args... args) { /* 打印可变参数的长度(参数的个数) */ std::cout Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-25 18:31:45 "},"docs/cpp11/language/constexpr.html":{"url":"docs/cpp11/language/constexpr.html","title":"constexpr","keywords":"","body":"constexprconstexpr constexpr 变量: 一定是一个常量. 而且必须用常量表达式初始化. constexpr 函数: 指能用于常量表达式的函数. 函数的返回类型以及所有形参类型都得是字面值类型, 而且函数体中必须有且只有一条return语句. constexpr 构造函数: 用于生成constexpr对象以及constexpr函数的参数或返回类型. constexpr构造函数可以声明成=default或=delete的形式. constexpr构造函数必须即符合构造函数的要求, 又符合constexpr函数的要求. 所以constexpr构造函数一般是空的.constexpr构造函数必须初始化所有数据成员, 初始值或者使用constexpr构造函数, 或者是一条常量表达式. 允许constexpr函数的返回值并非一个常量. 当函数的实参是常量表达式时, 它的返回值也是常量表达式; 反之则不然. constexpr int func1() { return 100; } constexpr int func2(int val) { /* 如果val是常量表达式, 则func2(val)也是常量表达式 */ return val * func1(); } int main(void) { constexpr int a = 20; /* 20 是常量表达式 */ constexpr int b = a + 2; /* a + 2 是常量表达式 */ constexpr int c = func2(100); //int i = 100; //constexpr int d = func2(i); /* i 不是常量表达式, 所以func2(i)不是常量表达式, 该语句error */ return 0; } Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-25 18:31:45 "},"docs/cpp11/language/default_delete.html":{"url":"docs/cpp11/language/default_delete.html","title":"显示默认和禁用方法","keywords":"","body":"显式默认和禁用方法显式默认和禁用方法 用户可以通过 =default 后缀修饰符, 为每个类显式指定默认构造函数. 也可以通过 =delete 后缀修饰构造函数和赋值等操作(通常用来实现禁止复制的语义) 显式限定这些特殊方法增强了代码的可读性和可维护性. class A { public: A() = default; A(const A &a) = delete; }; int main(void) { A a; //A b(a); /* 拷贝构造函数已经声明为delete, 无法调用. */ return 0; } Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-25 18:31:45 "},"docs/cpp11/language/override_final.html":{"url":"docs/cpp11/language/override_final.html","title":"override和final修饰符","keywords":"","body":"override 和 final 修饰符override 和 final 修饰符 override 修饰符用于标识指定的虚函数重载了基类中的同名虚方法(而不是定义一个新的同名虚方法). 该修饰符在编译时严格检查, 避免因为函数签名不同而导致重载失败. final 修饰符可用于修饰类或方法. 在修饰类时, 它表示指定类是一个concrete类(不能再作为基类而被其它类继承).用于函数时, 表示此虚方法已经是最终实现, 任何派生类中重载这个方法的企图都将引发一个编译错误. #include class A { public: A() = default; virtual ~A() { std::cout func1(); delete a; a = nullptr; return 0; } 通过上面的例子我发现final和override还可以被定义成变量.使用override和final 有利于增强可读性, 定义和派生抽象类的利器. 它们在除了特定上下文中有特别的含义外, 仍然可以作为合法的标识符使用. Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-25 18:31:45 "},"docs/cpp11/language/new_str.html":{"url":"docs/cpp11/language/new_str.html","title":"新的字符类型和字符串字面值","keywords":"","body":"新的字符类型和字符串字面值定义新的字符类型和字符串字面值定义 新增char16_t 和 char32_t 两种类型. 新增 utf-8(u8), utf-16(u), utf-32(U)字符串字面值定义方法. 同时新增了对 引号(\")和反斜杠()等特殊字符无需转换的裸字符串字面值定义方法(R), 该方法还可以与utf字面值前缀接合使用(u8R, uR, UR) #include int main(void) { char16_t ch1; char32_t ch2; std::cout Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-25 18:31:45 "},"docs/cpp11/language/gt.html":{"url":"docs/cpp11/language/gt.html","title":"改进大于号解析","keywords":"","body":"改进大于号解析改进大于号解析 不必担心模板定义中的 \">>\" 被解析成右移操作. #include int main(void) { std::vector> vec1; /* c++11支持 */ std::vector > vec2; return 0; } Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-25 18:31:45 "},"docs/cpp11/language/lambda.html":{"url":"docs/cpp11/language/lambda.html","title":"lambda表达式","keywords":"","body":"lambda 表达式语法capture list(parameter list)mutable 或 exception 声明->return type{function body}使用示例lambda 表达式 语法 [capture list] (parameter list) mutable或exception声明 ->return type {function body}; capture list 按值传递的参数默认是const的, 不可修改. 空 [] 没有任何capture = 函数体内可以使用lambda所在范围内所有可见的局部变量(包括lambda所在类的this), 并且是值传递方式. & 函数体内可以使用lambda所在范围内所有可见的局部变量(包括lambda所在类的this), 并且是引用传递方式. this 函数体内可以使用lambda所在类中的成员变量 x 将x按值进行传递(默认是const, 不可修改) &x 将x按引用进行传递. x, &y 将x按值传递, b按引用传递. =, &x, &y 除x和y按引用传递外, 其它参数都按值进行传递. &, x, y 除x和y按值进行传递外, 其它参数都按引用进行传递. (parameter list) 如同普通函数的参数列表. mutable 或 exception 声明 这部分可以省略. 按值传递capture list时, 加上mutable修饰符后, 可以修改传递进来的拷贝(只是修改拷贝的副本, 而不是修改本身). exception声明用于指定函数抛出的异常, 如抛出整数类型的异常, 可以使用throw(int). ->return type 标识函数返回值的类型, 当返回值为void, 或者函数体中只有一处return的地方(此时编译器可以自动推断出返回值类型)时, 这部分可以省略. {function body} 函数的实现, 函数体可以为空. 使用示例 #include int main(void) { int n = 5; int m = 5; auto f1 = [m]() mutable { return ++m; }; std::cout int { m = x; return m; }; std::cout 一个没有指定任何捕获的lambda函数, 可以显式的转换成一个具有相同声明形式的函数指针. int main(void) { auto f4 = [](int x) { return ; }; void (*func_ptr)(int) = f4; return 0; } 注意: 使用引用捕获时, 若引用的是函数体内的局部变量, 那么lambda的生命周期不要超过所在函数体的生命周期. Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-25 18:31:45 "},"docs/cpp11/language/right_ref.html":{"url":"docs/cpp11/language/right_ref.html","title":"右值引用和移动构造语义","keywords":"","body":"右值引用和移动构造语义使用示例右值引用和移动构造语义 右值引用解决了左值引用无法传递临时对象和常引用传递的对象只读的问题. 右值引用允许传递一个可变的临时对象引用.移动构造使用移动而非赋值语义完成构造过程, 主要用于解决函数返回值时的大量深拷贝开销.不能将一个右值引用直接绑定到一个变量上, 即使这个变量是右值引用类型也不行. 右值左值详解 或 现代c++ 的右值引用章节 使用示例 #include int main(void) { int a = 30; int &b = a; //int &&c = a; /* error 右值引用不能绑定到左值 */ //int &d = a * 2; /* erro a * 2 是一个右值 */ const int &d = a * 2; /* 常量左值引用能够延长临时变量的生命周期 */ int && f = a * 2; /* 右值引用可以绑定到右值 */ //int && g = f; /* error 不能将一个右值引用绑定到一个变量上, 即使这个变量是右值引用类型也不行 */ int && h = std::move(f); /* ok */ return 0; } int r1 = 20; int &&r2 = std::move(r1); 调用move就意味着承诺: 除了对r1赋值或销毁它以外, 将不能再使用它. Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-25 18:31:45 "},"docs/cpp11/language/noexcept.html":{"url":"docs/cpp11/language/noexcept.html","title":"noexcept异常说明和noexcept运算符","keywords":"","body":"noexcept异常说明 和 noexcept运算符noexcept说明符noexcept运算符noexcept异常说明 和 noexcept运算符 noexcept说明符 知道函数不会抛出异常有助于简化调用该函数的代码.如果编译器确认该函数不会抛出异常, 它就能执行某些特殊的优化操作, 而这些优化操作并不适合可能出错的代码. noexcept说明符出现的位置 函数的尾置返回类型之前. 函数指针的声明和定义中指定noexcept 在成员函数中, noexcept说明符需要跟在const及引用限定符之后, 而在final, override或虚函数的=0 之前. noexcept运算符 返回值是一个bool类型的右值常量表达式, 用于表示给定的表达式是否会抛出异常. 和sizeof类似, noexcept也不会求其运算对象的值. #include class Base { public: void func1() const noexcept { return; } virtual void func2() { return; } virtual void func3() noexcept = 0; virtual void func4() noexcept final { return; } }; class Derive : public Base { public: virtual void func2() noexcept override { return; } virtual void func3() noexcept override { return; } }; void f1() noexcept { return; } void f2() { return; } int main(void) { std::cout Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-25 18:31:45 "},"docs/cpp11/language/constructor.html":{"url":"docs/cpp11/language/constructor.html","title":"继承的构造函数","keywords":"","body":"继承的构造函数继承的构造函数 传统c++构造函数如果需要继承是需要将参数一一传递的，这会有效率问题。关键字using引入了继承构造函数的概念。 派生类能够重用其直接基类定义的构造函数. 一个类只初始化它的直接基类, 出于同样的原因, 一个类也只能继承其直接基类的构造函数. 类不能继承默认, 拷贝和移动构造函数.如果派生类没有定义这些构造函数, 则编译器将为派生类合成它们.和普通的using声明不一样, 一个构造函数的using声明不会改变该构造函数的访问级别(不管using声明出现在哪里, 基类的私有构造函数在派生类中还是私有构造函数; 受保护和公有的构造函数也是同样的规则)一个using声明语句不能指定explicit或constexpr.如果基类的构造函数是explicit或constexpr, 则继承的构造函数也拥有相同的属性.当一个基类构造函数含有默认实参时, 这些实参并不会被继承. 相反, 派生类将获得多个继承的构造函数, 其中每个构造函数分别省略掉一个含有默认实参的形参.例如: 如果基类有一个接受两个形参的构造函数, 其中第二个形参含有默认实参, 则派生类将获得两个构造函数: 一个构造函数接受两个形参(没有默认实参), 另一个构造函数只接收一个形参, 它对应于基类中最左侧的没有默认值的那个形参.如果基类含有多个构造函数, 则除了两个例外情况, 大多数时候派生类会继承所有这些构造函数.第一个例外是派生类可以继承一部分构造函数, 而为其它构造函数定义自己的版本. 如果派生类定义的构造函数与基类的构造函数具有相同的参数列表, 则该构造函数将不会被继承. 定义在派生类中的构造函数将替换继承而来的构造函数.第二个例外是默认, 拷贝和移动构造函数不会被继承. 这些构造函数按照正常规则被合成. 继承的的构造函数不会被作为用户定义的构造函数来使用, 因此, 如果一个类只含有继承的构造函数, 则它也将拥有一个合成的默认构造函数. #include using namespace std; class Base { public: Base() { v1 = 200; cout 如果从多个基类中继承了相同的构造函数(形参列表完全相同), 这程序会产生错误, 这个类必须为该构造函数定义它自己的版本. #include class Base1 { public: Base1() = default; Base1(const std::string&) {}; }; class Base2 { public: Base2() = default; Base2(const std::string&) {}; }; class Derive : public Base1 , public Base2 { public: using Base1::Base1; /* 从Base1继承构造函数 */ using Base2::Base2; /* 从Base2继承构造函数 */ Derive() = default; /* * 因为从多个基类继承了相同的构造函数, * 如果不定义一个可以接受string的构造函数, 则会报错 * */ Derive(const std::string&s): Base1(s), Base2(s) {} }; int main(void) { return 0; } Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-25 18:31:45 "},"docs/cpp11/language/string_value.html":{"url":"docs/cpp11/language/string_value.html","title":"string和数值之间的转换","keywords":"","body":"string 和数值之间的转换string 和数值之间的转换 string和数值转换 转换类型 to_string(val) 把val转换成string stoi(s, p, b) 返回s的起始子串(表示整数内容)的数值, 返回值类型分别是int, long, unsigned long, long long, unsigned long long. b 表示转换所用的基数, 默认值是10(十进制). p是size_t指针, 用来保存s中第一个非数值字符的下标, p默认为0(不保存下标) stol(s, p, b) stoul(s, p, b) stoll(s, p, b) stoull(s, p, b) stof(s, p) 返回s的起始子串(表示浮点数内容)的数值, 返回值类型分别是float, double, long double. 参数p的作用和整数转换函数一样. stod(s, p) stold(s, p) 下面是简单使用例子: #include #include int main(void) { int a1 = 100; std::string s1 = std::to_string(a1); a1 = std::stoi(\"200\", nullptr, 10); int a2 = std::stoi(\"30\"); /* 使用默认的p和b, 可以省略不写 */ std::cout Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-25 18:31:45 "},"docs/cpp11/lib/init_list.html":{"url":"docs/cpp11/lib/init_list.html","title":"初始化列表和统一初始化方式","keywords":"","body":"初始化列表和统一初始化方式初始化列表和统一初始化方式 允许非POD容器类型通过初始化列表完成构造. 无论是POD还是非POD类型都可以使用 obj = { ... }的方式来进行初始化. 对非POD类型{ ... }将自动匹配和调用构造函数. 因此对于 A(x)的构造函数可以这样写: A{x}, A a{x}. 在需要返回一个A类型对象时, 可以写: return{x}; (建议不要滥用该用法, 否则降低代码的可读性和可维护性) #include #include #include #include class A { public: A(std::initializer_list items) : m_nNumber(*items.begin()) {}; private: int m_nNumber; }; int main(void) { std::vector vec1{1, 6, 22, 100, 8, 15, 10, 9}; std::vector vec2 = {1, 6, 22, 100, 8, 15, 10, 9}; std::map map1 = { {1, 2}, {3, 4}, {5, 6}, {7, 8} }; A a1{1, 2}; A a2{1, 2, 5, 1000}; return 0; } Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-25 18:31:45 "},"docs/cpp11/lib/static_assert.html":{"url":"docs/cpp11/lib/static_assert.html","title":"静态断言","keywords":"","body":"static_assert使用示例static_assert 静态断言, 编译时的断言检查. 如果为假, 编译器会打印错误信息. 使用示例 #include class A { public: A() {} virtual ~A() {} private: }; class B : public A { public: B() {} }; int main(void) { /* 若B空类类型(无异于0大小位域的非静态数据成员, 无虚函数, 无虚基类, 且无非空基类和非联合类类型), 则为true */ static_assert(std::is_empty::value, \"error...\"); /* 是否是空类 */ /* 若B派生自A 或 为同一非联合类, 则为true */ static_assert(std::is_base_of::value, \".......error........\"); /* POD 类型为true */ static_assert(std::is_pod::value, \".......error........\"); /* * 是否是整数类型 bool 、 char 、 char8_t 、 char16_t 、 char32_t 、 * wchar_t 、 short 、 int 、 long 、 long long 类型，或任何实现定义 * 的扩展整数类型，包含任何有符号、无符号及 cv 限定的变体。则提供等 * 于 true * */ static_assert(std::is_integral::value, \".......error........\"); /* ... ... */ return 0; } 自定义字面值后缀 后缀名尽量以下划线开头(否则会报警告, 可能有些编译器会报错)后缀的参数只能是 unsigned long long, long double, const char * 或者 const char * + size_t #include unsigned long long operator\"\" _god(unsigned long long n) { return n * 100; } int main(void) { auto n = 3_god; std::cout 注意: 使用不当会降低代码的可读性和可维护性 Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-25 18:31:45 "},"docs/cpp11/lib/func.html":{"url":"docs/cpp11/lib/func.html","title":"函数对象包装器","keywords":"","body":"函数对象包装器std::functionstd::bind 和 std::placeholder函数对象包装器 std::function std::function 是一种通用、多态的函数封装，它的实例可以对任何可以调用的目标实体进行存储、复制和调用操作，它也是对c++中现有的可调用的实体的一种类型安全的包裹，它是函数的容器。 #include #include int foo(int v) { return v; } int main(void) { std::function f = foo; int i = 6; std::function f2 = [&](int value) -> int { return value + i; }; std::cout std::bind 和 std::placeholder std::bind用来绑定函数调用的参数，有时候不一定能够一次性获得调用某个函数的全部参数，通过这个函数，可以将部分调用参数提前绑定到函数身上成为一个新的对象，然后在参数齐全后，完成调用。 #include #include void foo(int a, int b, int c) { std::cout Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-25 18:31:45 "},"docs/cpp11/lib/begin_end.html":{"url":"docs/cpp11/lib/begin_end.html","title":"标准库函数begin、end和容器内的cbegin、cend","keywords":"","body":"标准库函数begin, end 和 容器内的cbegin, cend标准库函数begin, end 和 容器内的cbegin, cend 标准库的begin, end和容器中的成员begin, end功能相似, 正确使用begin和end是将数组作为它们的参数. 可以方便的获取数组的尾指针和头指针. #include #include #include #include int main(void) { char s1[] = \"hello world\"; const char *psbeg = std::begin(s1); char *psend = std::end(s1); printf(\"psbeg:\\t%p\\ns1:\\t%p\\n\", psbeg, s1); /* end返回的是数组结尾的下一个地址 */ printf(\"psend - 1:\\t%p\\ns1[strlen(s1)]:\\t%p\\n\", psend - 1, &s1[strlen(s1)]); return 0; } 容器中新增了cbegin和cend, 类似容器中的begin, end返回指示容器第一个元素或最后一个元素下一个的迭代器. 不同的是不论容器对象本身是否是常量, cbegin, cend返回的是const_iterator. 1 #include 2 3 int main(void) 4 { 5 std::vector vec; 6 std::vector::const_iterator it = vec.cbegin(); 7 8 return 0; 9 } Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-25 18:31:45 "},"docs/cpp11/lib/array_forward.html":{"url":"docs/cpp11/lib/array_forward.html","title":"array和forward_list","keywords":"","body":"array 和 forward_list使用示例array 和 forward_list array是固定大小的序列容器, 它包含以严格线性序列排序的特定数量的元素. 不通过分配器管理其元素的分配. 成员方法和vector容器有诸多类似之处. 就不再一一阐述了. forward_list 是一个单向链表. 无法使用反向迭代器. 只能从它得到const或non-const前项迭代器, 这些迭代器都不能解引用, 只能自增; 没有可以返回最后一个引用的成员函数back(); 因为只能通过自增前面元素的迭代器来到达序列的终点, 所以push_back(), pop_back(), emplace_back()也无法使用. forward_list的操作要比list容器更快, 而且占用更少的内存. 使用示例 #include #include int main(void) { std::array arr1 = {1, 2}; std::cout Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-25 18:31:45 "},"docs/cpp11/lib/tuple.html":{"url":"docs/cpp11/lib/tuple.html","title":"结构化绑定tuple","keywords":"","body":"结构化绑定 tuple结构化绑定 tuple tuple容器用于构造一个元组，可以让函数返回多个值，然后用tie对元组进行拆包。 #include #include #include std::tuple foo() { return std::make_tuple(\"hello world\", 50, 1.23); } int main(void) { int n; std::string s; double d; std::tuple f = foo(); std::cout (f) (f) (f) (f); /* 无法使用动态索引 */ /* 元组合并 */ std::tuple t1 = std::make_tuple(5, \"hello world1\"); std::tuple t2 = std::make_tuple(10, \"hello world2\"); auto t3 = std::tuple_cat(t1, t2); std::cout (t3) (t3) (t3) (t3) Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-25 18:31:45 "},"docs/cpp11/lib/unordered_con.html":{"url":"docs/cpp11/lib/unordered_con.html","title":"无序关联容器","keywords":"","body":"无序关联容器无序关联容器 unordered_set, unordered_map, unordered_multiset, unordered_multimap 它们分别对应有序关联容器 set, map, multiset, multimap.这四个无序关联容器是使用哈希函数和关键字类型的==运算符来组织元素的.除了哈希管理操作之外, 无序关联容器提供了与有序容器相同的操作(find, insert等), 意味着可以像操作set, map一样操作 unordered_set, unordered_map通常情况下, 无序关联容器可以获得更好的性能, 但也会占用更多的内存. Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-25 18:31:45 "},"docs/cpp11/lib/regex.html":{"url":"docs/cpp11/lib/regex.html","title":"正则表达式regex","keywords":"","body":"正则表达式 regex使用示例正则表达式 regex 正则表达式库非常的强大, 用于字符串匹配非常的方便. 这里只简单介绍c++中的使用. 正则表达式库组件 regex 表示有一个正则表达式类 regex_match 将一个字符序列与一个正则表达式匹配 regex_search 寻找第一个与正则表达式匹配的子序列 regex_replace 使用给定格式替换一个正则表达式 sregex_iterator 迭代适配器, 调用regex_search来遍历一个string中所有匹配的子串 smatch 容器类, 保存在string中搜索的结果 ssub_match string 中匹配的子表达式的结果 使用示例 #include #include #include int main(void) { std::string str1[] = {\"foo.txt\", \"b.txt\", \"abcd.txt\", \"txt\", \"a0.txt\", \"AAA.txt\", \"wt.txt\"}; std::regex txtRegex(\"[a-z]+\\\\.txt\"); std::regex baseRegex(\"([a-z]+)\\\\.txt\"); std::smatch baseMatch; for (const auto &s : str1) { if (std::regex_match(s, baseMatch, baseRegex)) { std::cout Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-25 18:31:45 "},"docs/cpp11/lib/smart_ptr.html":{"url":"docs/cpp11/lib/smart_ptr.html","title":"智能指针","keywords":"","body":"智能指针shared_ptr和unique_tr都支持的操作shared_ptr的操作unique_ptr的操作weak_ptr的操作shared_ptr使用注意事项使用示例智能指针 shared_ptr 基于引用计数的智能指针, 会统计当前有多少个对象同时拥有该内部指针; 当引用计数降为0时, 自动释放. weak_ptr 一种弱引用, 指向shared_ptr所管理的对象; weak_ptr只引用, 不计数. unique_ptr 独占语义的智能指针, 资源只能唯一的被一个unique_ptr所占有, 当其离开作用域时自动析构. shared_ptr和unique_tr都支持的操作 shared_ptr sp unique_prt up 空智能指针, 可以指向类型为T的对象. p 将p用作一个条件判断, 若p指向一个对象, 则为true *p 解引用p, 获得它指向的对象 p->mem 等价于(*p).mem p.get() 返回p中保存的指针. swap(p, q) p.swap(q) 交换p和q中的指针 p.reset() shared_ptr将引用计数递减, unique_ptr将释放p指向的对象 p.reset(q) p.reset(nullptr) shared_ptr将引用计数递减, unique_ptr将释放p所指的对象, 如果提供了内置指针q, 则将p指向这个对象. shared_ptr的操作 make_shared(args) 返回一个shared_ptr, 指向一个动态内存分配的类型为T的对象. 使用args初始化此对象 shared_ptrp(q) p是shared_ptr q的拷贝; 此操作会递增q中的计数器. q中的指针必须能转换为T\\* p = q p和q都是shared_ptr, 所保存的指针必须能相互转换. 此操作会递减p的引用计数, 递增q的引用计数; p.unique() 若p.use_count()为1, 返回true; 否则返回false p.use_count() 返回与p共享对象的智能指针数量(引用计数值) unique_ptr的操作 unique_ptr u(d) 空unique_ptr, 指向类型为T的对象, 用类型为D的对象d代替delete u = nullptr 释放u指向的对象, 将u置为空 u.release() u放弃对指针的控制权, 返回指针, 并将u置为空 weak_ptr的操作 weak_ptr wp 空的weak_ptr 可以指向类型为T的对象 weak_ptr wp(sp) 与shared_ptr sp指向相同对象的weak_ptr. T必需能转换成sp指向的类型 wp = p p可以指向一个shared_ptr或weak_ptr. 赋值后wp 与 p共享对象 wp.reset() 将wp置为空 wp.use_count() 与wp共享对象的shared_ptr的数量 wp.expired() 若wp.use_count()为0, 返回true, 否则返回false wp.lock() 如果expired为true, 返回一个空的shared_ptr; 否则返回一个指向wp的对象的shared_ptr shared_ptr使用注意事项 不使用相同的内置指针初始化(或reset)多个智能指针. 不delete get() 返回的指针 不使用get()初始化或reset另一个智能指针 如果使用了get()返回的指针, 记住当最后一个对应的智能指针销毁后, 这个指针就变为了无效指针了. 如果使用智能指针管理的资源不是new分配的内存, 记住传递给它一个删除器. 使用示例 #include class Dealloc { public: Dealloc() = default; //括号()操作符的重载 void operator() (int* p ) { if (p != nullptr) { delete p; p = nullptr; } } }; void shared_ptr_func(void) { //1. 创建 std::shared_ptr sp0; /* 空智能指针 */ std::shared_ptr sp1 = std::shared_ptr(new int(100)); std::shared_ptr sp2 = std::make_shared(int(10)); //2. 自定义资源释放函数 { auto sp4 = std::shared_ptr(new int[5], [](int *p){ delete[ ] p; }); } { // 括号()操作符的重载 auto sp5 = std::shared_ptr(new int(1000), Dealloc() ); } //3. 复制 auto sp6(sp1); auto sp7 = sp1; //4. 获取保存的指针 int* pRaw = sp2.get(); //5. 返回共享对象的智能指针数量. long nCount1 = sp1.use_count(); long nCount2 = sp2.use_count(); //6. 是否是独享 bool b1 = sp1.unique(); bool b2 = sp2.unique(); //7. swap sp1.swap(sp2); //8. reset 重置指向另一个对象, 原指针引用计数减一 sp1.reset(new int(20)); } void del(int *p) { delete p; } void unique_ptr_func(void) { std::unique_ptr up0; std::unique_ptr up1(new int(20)); //std::unique_ptr up2(up1); /* 不支持拷贝 */ std::unique_ptr up2(up1.release()); up2.reset(up0.release()); //up0 = up1; /* error 不支持赋值 */ std::unique_ptr up3(new int(20), del); } void weak_ptr_func() { std::shared_ptr sp0 = std::make_shared(int(10)); std::weak_ptr wp0(sp0); /* 不会改变sp0的引用计数 */ bool b1 = wp0.expired(); std::shared_ptr sp1 = wp0.lock(); std::weak_ptr wp1 = wp0.lock(); } int main(void) { shared_ptr_func(); unique_ptr_func(); weak_ptr_func(); return 0; } Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-25 18:31:45 "},"docs/cpp11/lib/pthread.html":{"url":"docs/cpp11/lib/pthread.html","title":"多线程","keywords":"","body":"多线程线程锁多线程 线程 std::thread 创建一个线程实例 锁 std::mutex 创建一个实例，虽然有lock和unlock方法，但最好使用RAII的智能锁进行管理。 使用RAII的智能锁 std::lock_guard std::unique_lock 详细一点的内容可以查看c++并发并行 #include #include #include #include #include static int g_val = 1; static std::mutex g_mtx; void foo(std::string name) { for (int i = 0; i lock(g_mtx); ++g_val; std::cout lock(g_mtx); for (int i = 0; i lock(g_mtx); std::cout Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-25 18:31:45 "},"docs/cpp11/lib/future.html":{"url":"docs/cpp11/lib/future.html","title":"future","keywords":"","body":"futurefuture 提供了访问异步操作结果的途径。 详细一点的内容可以查看c++并发并行 #include #include #include #include int main(void) { /* packaged_task也是c++11特性 */ std::packaged_task task([]() { sleep(2); return 5; }); std::future f = task.get_future(); std::thread(std::move(task)).detach(); std::cout Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-25 18:31:45 "},"docs/cpp11/lib/condition.html":{"url":"docs/cpp11/lib/condition.html","title":"条件变量","keywords":"","body":"条件变量使用示例条件变量 std::condition_variable 详细一点的内容可以查看c++并发并行 使用示例 #include #include #include #include #include #include int main(void) { std::queue nums; std::mutex mtx; std::condition_variable cv; bool notified = false; srandom(time(nullptr)); /* 生产者 */ auto producer = [&]() { while (true) { std::this_thread::sleep_for(std::chrono::milliseconds(1000)); std::unique_lock lock(mtx); int num = rand() % 100; std::cout lock(mtx); while (!notified) { cv.wait(lock); } lock.unlock(); std::this_thread::sleep_for(std::chrono::milliseconds(2500)); lock.lock(); if (!nums.empty()) { std::cout Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-25 18:31:45 "},"docs/cpp11/lib/atomic.html":{"url":"docs/cpp11/lib/atomic.html","title":"原子操作和内存模型","keywords":"","body":"原子操作与内存模型原子操作使用示例内存顺序原子操作与内存模型 这里用的不好，很容易出现不可预期的错误，用的好的话，可以提升效率。这里我还需要进一步的学习研究，先有个大概的了解。 原子操作 atomic 原子操作库 使用示例 #include #include #include std::atomic count = {0}; int main(void) { std::thread t1([]() { count.fetch_add(1); }); std::thread t2([]() { count++; /* 等价于fetch_add */ count += 1; /* 等价于fetch_add */ }); t1.join(); t2.join(); std::cout 内存顺序 略 Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-25 18:31:45 "},"docs/cpp14/auto_type.html":{"url":"docs/cpp14/auto_type.html","title":"类型推导","keywords":"","body":"类型推导返回值推导decltype(auto)类型推导 返回值推导 在c++11中，需要加上decltype进行后置式声明才能编译通过，在c++14中可以取消后置式，只使用auto就可以推导返回值。 #include using namespace std; template auto foo(T x, U y) { return x + y; } int main(void) { auto r = foo(20, 30); cout decltype(auto) 待补充 Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-25 18:31:45 "},"docs/cpp14/constexpr.html":{"url":"docs/cpp14/constexpr.html","title":"constexpr","keywords":"","body":"constexprconstexpr 该关键字在c++11已经出现，但在c++11里面constexpr函数有且仅有一条return语句，现在可以写多条语句了。 /* 这在cpp14里面是合法的 */ constexpr int foo(const int n) { if (n == 1 || n == 2) { return 1; } int tmp = 4; tmp++; return foo(n - 1) + foo(n - 2); } int main(void) { int k = foo(8); return 0; } Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-25 18:31:45 "},"docs/cpp14/lambda.html":{"url":"docs/cpp14/lambda.html","title":"lambda","keywords":"","body":"lambda表达式捕获泛型lambdalambda 表达式捕获 在14之前的lambda无法对表达式进行捕获。 #include int main(void) { auto add = [v1 = 1, v2 = 2 + 2]() -> int { return v1 + v2; }; std::cout 泛型lambda lambda函数的形参可以使用auto关键字产生意义上的泛型 #include int main(void) { auto add = [ ](auto x, auto y) { return x + y; }; std::cout Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-25 18:31:45 "},"docs/cpp14/uniqueptr.html":{"url":"docs/cpp14/uniqueptr.html","title":"unique_ptr","keywords":"","body":"unique_ptrunique_ptr std::unique_ptr 在c++11中已经出现，但是缺少构造创建的方法std::make_unique 在c++14中引入了std::make_unqiue #include #include int main (void) { /* c++14 支持 */ std::unique_ptr uq = std::make_unique(10); std::cout Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-25 18:31:45 "},"docs/cpp14/tuple.html":{"url":"docs/cpp14/tuple.html","title":"tuple","keywords":"","body":"tupletuple std::get在c++14增加了使用类型来获取元组中的对象。 #include #include #include int main(void) { std::tuple t1 = std::make_tuple(5, \"hello world1\"); /* c++14新增 */ std::cout (t1) (t1) Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-25 18:31:45 "}}