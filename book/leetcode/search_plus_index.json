{"./":{"url":"./","title":"前言","keywords":"","body":"简介我如何做题为什么写到博客参考简介 leetcode的题型很全面，种类多，很适合沉浸在里面刷题; 通过leetcode能够帮助自己提升编程思维、开阔大脑以及学习更优秀的思维。 我如何做题 审题后自己思考解题方法，能够想出来就先按照自己的思路去解题，不管有没有AC，我都会看题解，题解总会有很多不一样的思路和更好的方法，自己能从题解中学到很多； 在看到和自己不一样的题解时，我通常先看思路，然后尝试用这个思路去解题，如果解不出来，就再看题解代码。 总之，解题一定要有自己的思考，可以解不出来题，但一定要思考，这样才能让自己的思维越来越敏捷，学到真正的知识。 为什么写到博客 leetcode的题目很多，做了一部分题后，偶尔会看到很久以前自己做的题目，发现有些题还是会思考很久甚至做不出来，这我想是因为我当初没有把整个思路理解透彻，可能当初脑子里面以为明白了，但没过多久就已经忘记； 所以我想把我解的每一道题都记录下来，自己的思路以及题解的思路，这可以帮助我更透彻的理解，也能帮助我很好的表x述自己的思路。 如果自己写到东西会被别人看到，自己就会想着把内容写的很好！ 出发 ！ 参考 leetcode Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-25 18:31:45 "},"docs/leetcode/1-100/":{"url":"docs/leetcode/1-100/","title":"1~100","keywords":"","body":"题目目录1.两数之和题目目录 1.两数之和 Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-25 18:31:45 "},"docs/leetcode/1-100/1.html":{"url":"docs/leetcode/1-100/1.html","title":"1.两数之和","keywords":"","body":"两数之和(简单)解法一解法二解法三两数之和(简单) 给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出和为目标值 target 的那两个整数，并返回它们的数组下标。 你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。 你可以按任意顺序返回答案。 示例1： 输入：nums = [2,7,11,15], target = 9 输出：[0,1] 解释：因为 nums[0] + nums[1] == 9, 返回 [0, 1] 示例2： 输入：nums = [3,2,4], target = 6 输出：[1,2] 示例3： 输入：nums = [3,3], target = 6 输出：[0,1] 提示： 2 -10^9 -10^9 只会存在一个有效答案 解法一 暴力法, 直接两层循环求值与目标值比较 class Solution { public: vector twoSum(vector& nums, int target) { vector res(2); for (size_t i = 0; i 解法二 使用map存储 nums 的所有值, 然后再遍历一遍 nums 进行结果查询, 如果能在 nums 中找到 target 与 nums[i] 的差值, 就说明找到了答案, 有种情况是差值和 nums[i] 值相等, 因为题目要求不能重复, 所以需要在map中该值存在至少两次才可以, 也就是保存有两个 nums 的该值下标. class Solution { public: vector twoSum(vector& nums, int target) { vector res(2); multimap numMap; for (size_t i = 0; i 1) { res[0] = (it++)->second; res[1] = it->second; break; } } else if (it != numMap.end()) { res[0] = i; res[1] = it->second; break; } } return res; } }; 解法三 使用hashmap, 只需要遍历一遍数组即可找到 和等于目标值 的结果 如果hashmap中不存在 target - nums[i], 那么就把 nums[i] 保存下来, 这样既可以保证不会查询到自己, 又可以寻找到答案. class Solution { public: vector twoSum(vector& nums, int target) { unordered_map numMap; for (int i = 0; i second, i }; } numMap.insert(make_pair(nums[i], i)); } return {}; } }; Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-25 18:31:45 "},"docs/leetcode/1-100/2.html":{"url":"docs/leetcode/1-100/2.html","title":"2.两数相加","keywords":"","body":"两数相加(中等)解法一两数相加(中等) 给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。 请你将两个数相加，并以相同形式返回一个表示和的链表。 你可以假设除了数字 0 之外，这两个数都不会以 0 开头。 示例 1： 输入：l1 = [2,4,3], l2 = [5,6,4] 输出：[7,0,8] 解释：342 + 465 = 807. 示例 2： 输入：l1 = [0], l2 = [0] 输出：[0] 示例 3： 输入：l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9] 输出：[8,9,9,9,0,0,0,1] 提示： 每个链表中的节点数在范围 [1, 100] 内 0 题目数据保证列表表示的数字不含前导零 解法一 因为链表是逆序的，个位是链表头，最高位是链表尾，所以可以很好的从个位开始逐步进行正常的加法运算，运算过程中需要保存进位值，用于下一位运算； 最后要记得最后一位可能需要进位，这个很容易遗漏。 /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public: ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) { int val = l1->val + l2->val; ListNode *pHead = new ListNode(val % 10); int c = val / 10; ListNode *p = pHead; l1 = l1->next; l2 = l2->next; while (l1 && l2) { val = l1->val + l2->val + c; ListNode *pl = new ListNode(val % 10); c = val / 10; p->next = pl; p = pl; l1 = l1->next; l2 = l2->next; } while (l1) { val = l1->val + c; ListNode *pl = new ListNode(val % 10); c = val / 10; p->next = pl; p = pl; l1 = l1->next; } while (l2) { val = l2->val + c; ListNode *pl = new ListNode(val % 10); c = val / 10; p->next = pl; p = pl; l2 = l2->next; } if (c) { p->next = new ListNode(c); } return pHead; } }; 上面的代码可能看起来很冗余 优化代码一 把所有计算放到一个循环里面，在循环里面进行头判断和空判断 /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public: ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) { ListNode *pHead = nullptr; ListNode *pTail = nullptr; int c = 0; while (l1 || l2 || c) { int sum = (l1 ? l1->val : 0) + (l2 ? l2->val : 0) + c; ListNode *p = new ListNode(sum % 10); c = sum > 9 ? 1 : 0; if (!pHead) { pHead = pTail = p; } else { pTail->next = p; pTail = p; } l1 = l1 ? l1->next : nullptr; l2 = l2 ? l2->next : nullptr; } return pHead; } }; 优化代码二 /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public: ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) { ListNode *pHead = new ListNode(); ListNode *pTail = pHead; int c = 0; while (l1 || l2 || c) { int sum = (l1 ? l1->val : 0) + (l2 ? l2->val : 0) + c; c = sum > 9 ? 1 : 0; pTail->next = new ListNode(sum % 10); pTail = pTail->next; l1 = l1 ? l1->next : nullptr; l2 = l2 ? l2->next : nullptr; } ListNode *p = pHead->next; delete pHead; return p; } }; Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-25 18:31:45 "},"docs/leetcode/1-100/3.html":{"url":"docs/leetcode/1-100/3.html","title":"3.无重复字符的最长子串","keywords":"","body":"无重复字符的最长子串(中等)解法一无重复字符的最长子串(中等) 给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。 示例 1: 输入: s = \"abcabcbb\" 输出: 3 解释: 因为无重复字符的最长子串是 \"abc\"，所以其长度为 3。 示例 2: 输入: s = \"bbbbb\" 输出: 1 解释: 因为无重复字符的最长子串是 \"b\"，所以其长度为 1。 示例 3: 输入: s = \"pwwkew\" 输出: 3 解释: 因为无重复字符的最长子串是 \"wke\"，所以其长度为 3。 请注意，你的答案必须是 子串 的长度，\"pwke\" 是一个子序列，不是子串。 示例 4: 输入: s = \"\" 输出: 0 提示： 0 s 由英文字母、数字、符号和空格组成 解法一 使用一个数组保存对应字符下标的不重复子串长度 用map来检查字符是否已经重复, 并保存最后的重复字符的下标 lastidx, 这个下标用来计算出重复位置到目前字符的不重复子串长度(i - lastidx), 为了最后重复的字符下标和当前字符之间有重复字符, 用一个 curr 来保存最新的重复字符位置, 如果map中保存的字符位置大于 curr 说明在 lastidx ~ i 之间有重复的其它字符, 这时需要从 curr 起计算(i - curr). 用 max 来记录最长子串长度 class Solution { public: int lengthOfLongestSubstring(string s) { if (s.size() == 0) { return 0; } vector dp(s.size()); dp[0] = 1; map strMap; int max = 1; int curr = 0; strMap[s[0]] = 0; for (int i = 1; i second) { dp[i] = i - it->second; curr = it->second; } else { dp[i] = i - curr; } } strMap[s[i]] = i; if (max Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-25 18:31:45 "},"docs/leetcode/1-100/4.html":{"url":"docs/leetcode/1-100/4.html","title":"4.寻找两个正序数组的中位数","keywords":"","body":"寻找两个正序数组的中位数(困难)解法一解法二解法三寻找两个正序数组的中位数(困难) 给定两个大小分别为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出并返回这两个正序数组的 中位数 。 示例 1： 输入：nums1 = [1,3], nums2 = [2] 输出：2.00000 解释：合并数组 = [1,2,3] ，中位数 2 示例 2： 输入：nums1 = [1,2], nums2 = [3,4] 输出：2.50000 解释：合并数组 = [1,2,3,4] ，中位数 (2 + 3) / 2 = 2.5 示例 3： 输入：nums1 = [0,0], nums2 = [0,0] 输出：0.00000 示例 4： 输入：nums1 = [], nums2 = [1] 输出：1.00000 示例 5： 输入：nums1 = [2], nums2 = [] 输出：2.00000 提示： nums1.length == m nums2.length == n 0 0 1 -106 解法一 看到是两个有序的数组, 我首先想到的就是归并, 但是新建一个数组会有不小的开销, 而且只是找一个中位数, 所以就只寻找就可以了 这里采用归并的思想, 来直接寻找中位数. 偶数时需要计算最中间两个值的平均值, 奇数时直接返回最中间的值就行 class Solution { public: double findMedianSortedArrays(vector& nums1, vector& nums2) { int i1 = 0, i2 = 0, i = -1; int len = nums1.size() + nums2.size(); vector res(2); int mid = len / 2; while (i1 ((res[0] + res[1])) / 2; } }; 解法二 看了其他题解后, 我才发现我的编码过于复杂, 同样是归并思想寻找中位数, 这个解法就很简洁 归并的时候可以直接在一个循环里面完成, 而且只需要遍历 len / 2 次即可 class Solution { public: double findMedianSortedArrays(vector& nums1, vector& nums2) { int m = nums1.size(); int n = nums2.size(); int len = m + n; int mid[2] = { -1, -1 }; int idx1 = 0, idx2 = 0; for (int i = 0; i = n || nums1[idx1] 解法三 既然是有序的数组, 那就可以使用二分查找的方法, 这样能够把时间复杂度降低到 O(log n) 这是题解里面的一个二分查找的实现 寻找中位数, 就是寻找第k小的数, 这里是在两个数组中寻找, 就寻找 nums1[k / 2] 与 nums[k / 2] 比较大小, 如果 nums1[k / 2] 那么 nums[k / 2] 之前的数一定小于 nums2[k / 2], 这样就可以排除 nums1[k / 2] 及其之前的数. 然后 nums1 数组以 nums1[k / 2 + 1] 为起点在于 nums2 进行二分查找, 并且缩小k的值(k = k / 2) 当然有可能发生越界的情况, 这时需要使用 nums 的长度值来保证不能越界, 并且 k 减少的值为nums的相对长度 class Solution { private: double getKthElement(vector &nums1, vector &nums2, int k) { int m = nums1.size(); int n = nums2.size(); int offset1 = 0, offset2 = 0; while (true) { if (offset1 == m) { return nums2[offset2 + k - 1]; } else if (offset2 == n) { return nums1[offset1 + k - 1]; } if (k == 1) { return min(nums1[offset1], nums2[offset2]); } int newOffset1 = min(k / 2 - 1 + offset1, m - 1); int newOffset2 = min(k / 2 - 1 + offset2, n - 1); if (nums1[newOffset1] & nums1, vector& nums2) { int len = nums1.size() + nums2.size(); if (len % 2) { return getKthElement(nums1, nums2, len / 2 + 1); } else { return (getKthElement(nums1, nums2, len / 2) + getKthElement(nums1, nums2, len / 2 + 1)) / 2.0; } } }; 题解里面还有一种划分数组的方法, 复杂度更低 Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-25 18:31:45 "},"docs/leetcode/1-100/5.html":{"url":"docs/leetcode/1-100/5.html","title":"5.最长回文子串","keywords":"","body":"最长回文子串(中等)解法一解法二解法三最长回文子串(中等) 给你一个字符串 s，找到 s 中最长的回文子串。 示例 1： 输入：s = \"babad\" 输出：\"bab\" 解释：\"aba\" 同样是符合题意的答案。 示例 2： 输入：s = \"cbbd\" 输出：\"bb\" 示例 3： 输入：s = \"a\" 输出：\"a\" 示例 4： 输入：s = \"ac\" 输出：\"a\" 提示： 1 s 仅由数字和英文字母（大写和/或小写）组成 解法一 使用一个数组保存每一个字符对应的最长回文子串的长度 \"aaabaaaa\" 下标: 0 1 2 3 4 5 6 7 字符: a a a b a a a a 回文长度len : 1 2 3 1 3 5 7 4 设置一个 step 的值为回文长度 +1, 用于定位到回文串的开头 第i个字符如果与 i - step 字符相等, 并检测 s 从 i - step 到 i 的这段字符串(str)是不是回文串 如果 str 是回文串, 那么 dp[i] = step + 1; 如果 str 不是回文串, 那么就缩减step, 直到检测到一个回文串, 并且有: dp[i] = step + 1; 需要注意的是step可能会大于i, 需要注意越界问题 class Solution { public: string longestPalindrome(string s) { vector dp(s.size()); vector idx { 0, 1 }; int max = 1; dp[0] = 1; for (int i = 1; i dp[i - 1] ? dp[i - 1] + 1 : i; dp[i] = 1; while (step > 0) { if (s[i] == s[i - step]) { if (this->check(s.substr(i - step, step + 1))) { dp[i] = step + 1; break; } } --step; } if (dp[i] > max) { max = dp[i]; idx[0] = i - dp[i] + 1; idx[1] = i + 1; } } return s.substr(idx[0], idx[1] - idx[0]); } private: bool check(const string &s) { if (s.size() == 0) { return false; } int r = s.size() - 1; int l = 0; while (l 解法二 动态规划 对于一个长度大于2的字符串如果一个字符串是回文串, 那么它去除首尾的两个字符后, 仍然是一个回文串 用i和j表示一个子字符串的开始和结尾, P表示该字符串的状态(true表示是回文串)如过P(i + 1, j - 1)的状态是回文串, 且 s[i] == s[j]有 P(i, j) = true否则 P(i, j) = false 当字符串长度小于等于2时 一个字符肯定是回文串: P(i, i) = true两个字符只有相等时才是回文串: P(i, i + 1) = s[i] == s[i + 1] ? true : false class Solution { public: string longestPalindrome(string s) { int n = s.size(); if (n > dp(n, vector(n)); // 初始化：所有长度为 1 的子串都是回文串 for (int i = 0; i = n) { break; } if (s[i] != s[j]) { dp[i][j] = false; } else { if (j - i maxLen) { maxLen = j - i + 1; begin = i; } } } return s.substr(begin, maxLen); } }; 解法三 中心扩展方法 如果一个字符串是是回文串, 那么就往两遍扩展, 一直到不是回文串为止. 扩展的开始是从一个边界, 即字符串的长度为1或2. 临界点 --> ... ... P(i + 2, i - 2) --> P(i + 1, j- 1) --> P(i, j) class Solution { public: string longestPalindrome(string s) { int start = 0; int end = 0; for (int i = 0; i end - start) { start = l1; end = r1; } if (r2 - l2 > end - start) { start = l2; end = r2; } } return s.substr(start, end - start + 1); } private: pair expandAroundCenter(const string &s, int left, int right) { while (left >= 0 && right Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-25 18:31:45 "},"docs/leetcode/1-100/6.html":{"url":"docs/leetcode/1-100/6.html","title":"6.Z字形变换","keywords":"","body":"Z字形变换(中等)解法一解法二Z字形变换(中等) 将一个给定字符串 s 根据给定的行数 numRows ，以从上往下、从左到右进行 Z 字形排列。 比如输入字符串为 \"PAYPALISHIRING\" 行数为 3 时，排列如下： P A H N A P L S I I G Y I R 之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：\"PAHNAPLSIIGYIR\"。 请你实现这个将字符串进行指定行数变换的函数： string convert(string s, int numRows); 示例 1： 输入：s = \"PAYPALISHIRING\", numRows = 3 输出：\"PAHNAPLSIIGYIR\" 示例 2： 输入：s = \"PAYPALISHIRING\", numRows = 4 输出：\"PINALSIGYAHRPI\" 解释： P I N A L S I G Y A H R P I 示例 3： 输入：s = \"A\", numRows = 1 输出：\"A\" 提示： 1 s 由英文字母（小写和大写）、',' 和 '.' 组成 1 解法一 使用多维数组, 来模拟z形 没有字符的地方用其它符号填充 通过观察z形的排列, 可以找到每轮询 (numRows - 1) * 2 次是一圈 然后对该值取模, 小于行数, 那么就是在列上补充全字符 如果不小于 numRows 那么就是拐弯的斜线上, 这时需要控制好填充字符. class Solution { public: string convert(string s, int numRows) { string res; vector > z; if (numRows == 1) { return s; } int mod = (numRows - 1) * 2; int space = 0; for (int i = 0; i = numRows) { z.push_back(vector()); } if (i % mod 0) { z.back().push_back('-'); } z.back().push_back(s[i]); } } for (int i = 0; i 题解答案 按行排序, 我们可以使用 \\text{min}( \\text{numRows}, \\text{len}(s))min(numRows,len(s)) 个列表来表示 Z 字形图案中的非空行。 从左到右迭代 ss，将每个字符添加到合适的行。可以使用当前行和当前方向这两个变量对合适的行进行跟踪。 只有当我们向上移动到最上面的行或向下移动到最下面的行时，当前方向才会发生改变。 class Solution { public: string convert(string s, int numRows) { if (numRows == 1) return s; vector rows(min(numRows, int(s.size()))); int curRow = 0; bool goingDown = false; for (char c : s) { rows[curRow] += c; if (curRow == 0 || curRow == numRows - 1) goingDown = !goingDown; curRow += goingDown ? 1 : -1; } string ret; for (string row : rows) ret += row; return ret; } }; 解法二 0 6 12 1 5 7 11 2 4 8 10 3 9 通过观察规律, 可以知道, 每过 (numRows - 1) * 2 次一个轮询 可以计算出第一排的所有下标对应于 字符串 s 的 (numRows - 1) * 2 的取模为0的值 从第二排开始到倒数第二排, 每个轮询里面都会多一个z拐弯直线上的字符, 这个字符根据 排 的序号与 当前的下标值有对应关系 假设在第 n - 1 排(n - 1排对应于序号是i), mod = (numRows - 1) * 2 就有z的拐弯直线上的字符对应 s 的下标就是 j + mod - (2 * i) 这样就可以按照排直接转换z形, 时间复杂度为O(n) ```cpp class Solution { public: string convert(string s, int numRows) { string res; if (numRows == 1) { return s; } int mod = (numRows - 1) * 2; for (int i = 0; i 0 && i j) { res.push_back(s[z]); } } } return res; } }; ``` Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-25 18:31:45 "},"docs/leetcode/1-100/7.html":{"url":"docs/leetcode/1-100/7.html","title":"7.整数反转","keywords":"","body":"整数反转(简单)解法一整数反转(简单) 给你一个 32 位的有符号整数 x ，返回将 x 中的数字部分反转后的结果。 如果反转后整数超过 32 位的有符号整数的范围 [−231, 231 − 1] ，就返回 0。 假设环境不允许存储 64 位整数（有符号或无符号）。 示例 1： 输入：x = 123 输出：321 示例 2： 输入：x = -123 输出：-321 示例 3： 输入：x = 120 输出：21 示例 4： 输入：x = 0 输出：0 提示： -2^31 解法一 通过取模一位一位的获取数字，在计算之前，先判断是否达到了临界点的地方，如果再乘以10就要越过临界点，就需要提前返回0，否则越界后会从0开始或者报错 class Solution { public: int reverse(int x) { int res = 0; int n = x; while (n) { if (res > big1 || res Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-25 18:31:45 "},"docs/leetcode/1-100/8.html":{"url":"docs/leetcode/1-100/8.html","title":"8.字符串转换整数","keywords":"","body":"字符串转换整数(中等)解法一解法二字符串转换整数(中等) 请你来实现一个 myAtoi(string s) 函数，使其能将字符串转换成一个 32 位有符号整数（类似 C/C++ 中的 atoi 函数）。 函数 myAtoi(string s) 的算法如下： 读入字符串并丢弃无用的前导空格 检查下一个字符（假设还未到字符末尾）为正还是负号，读取该字符（如果有）。 确定最终结果是负数还是正数。 如果两者都不存在，则假定结果为正。 读入下一个字符，直到到达下一个非数字字符或到达输入的结尾。字符串的其余部分将被忽略。 将前面步骤读入的这些数字转换为整数（即，\"123\" -> 123， \"0032\" -> 32）。如果没有读入数字，则整数为 0 。必要时更改符号（从步骤 2 开始）。 如果整数数超过 32 位有符号整数范围 [−2^31, 2^31 − 1] ，需要截断这个整数，使其保持在这个范围内。具体来说，小于 −2^31 的整数应该被固定为 −2^31 ，大于 2^31 − 1 的整数应该被固定为 2^31 − 1 。 返回整数作为最终结果。 注意： 本题中的空白字符只包括空格字符 ' ' 。 除前导空格或数字后的其余字符串外，请勿忽略 任何其他字符。 示例 1： 输入：s = \"42\" 输出：42 解释：加粗的字符串为已经读入的字符，插入符号是当前读取的字符。 第 1 步：\"42\"（当前没有读入字符，因为没有前导空格） ^ 第 2 步：\"42\"（当前没有读入字符，因为这里不存在 '-' 或者 '+'） ^ 第 3 步：\"42\"（读入 \"42\"） ^ 解析得到整数 42 。 由于 \"42\" 在范围 [-231, 231 - 1] 内，最终结果为 42 。 示例 2： 输入：s = \" -42\" 输出：-42 解释： 第 1 步：\" -42\"（读入前导空格，但忽视掉） ^ 第 2 步：\" -42\"（读入 '-' 字符，所以结果应该是负数） ^ 第 3 步：\" -42\"（读入 \"42\"） ^ 解析得到整数 -42 。 由于 \"-42\" 在范围 [-231, 231 - 1] 内，最终结果为 -42 。 示例 3： 输入：s = \"4193 with words\" 输出：4193 解释： 第 1 步：\"4193 with words\"（当前没有读入字符，因为没有前导空格） ^ 第 2 步：\"4193 with words\"（当前没有读入字符，因为这里不存在 '-' 或者 '+'） ^ 第 3 步：\"4193 with words\"（读入 \"4193\"；由于下一个字符不是一个数字，所以读入停止） ^ 解析得到整数 4193 。 由于 \"4193\" 在范围 [-231, 231 - 1] 内，最终结果为 4193 。 示例 4： 输入：s = \"words and 987\" 输出：0 解释： 第 1 步：\"words and 987\"（当前没有读入字符，因为没有前导空格） ^ 第 2 步：\"words and 987\"（当前没有读入字符，因为这里不存在 '-' 或者 '+'） ^ 第 3 步：\"words and 987\"（由于当前字符 'w' 不是一个数字，所以读入停止） ^ 解析得到整数 0 ，因为没有读入任何数字。 由于 0 在范围 [-231, 231 - 1] 内，最终结果为 0 。 示例 5： 输入：s = \"-91283472332\" 输出：-2147483648 解释： 第 1 步：\"-91283472332\"（当前没有读入字符，因为没有前导空格） ^ 第 2 步：\"-91283472332\"（读入 '-' 字符，所以结果应该是负数） ^ 第 3 步：\"-91283472332\"（读入 \"91283472332\"） ^ 解析得到整数 -91283472332 。 由于 -91283472332 小于范围 [-231, 231 - 1] 的下界，最终结果被截断为 -231 = -2147483648 。 提示： 0 s 由英文字母（大写和小写）、数字（0-9）、' '、'+'、'-' 和 '.' 组成 解法一 前一个循环先除去前导空格和符号, 后一个循环用来解析数字, 并转换, 过程需要注意临界问题, 这个问题搞得我很头疼. class Solution { public: const int MinNum = 0x80000000; const int MaxNum = 0x7fffffff; const int MinNumCrit = MinNum / 10; const int MaxNumCrit = MaxNum / 10; int myAtoi(string s) { char symbol = '+'; int num = 0; int i = 0; for (; i = '0' && s[i] = '0' && s[i] MaxNumCrit || num == MaxNumCrit && n > 6) { return MaxNum; } num = num * 10 + n; } else if (symbol == '-') { if (num > 0) { num = -num; } if (num 7) { return MinNum; } num = num * 10 - n; } } else { break; } } return num; } }; 解法二 有限状态机 从题目中可以知道, 可以分为开始状态、符号状态、数字状态和结束状态.开始遇到空格是一种状态,属于开始状态, 从开始状态可以遇到符号、数字或其它字符, 分别可以进入符号状态、数字状态和结束状态在符号状态除了遇到数字进入数字状态, 其它都会进入到结束状态在数字状态除了遇到数字进入数字状态, 其它都是结束状态在结束状态只能结束 class Solution { public: const int MinNum = 0x80000000; const int MaxNum = 0x7fffffff; typedef enum { START, SIGNED, IN_NUMBER, END } STATUS; int getCol(char ch) { switch (ch) { case ' ': return 0; case '+': ; case '-': return 1; default : { if (ch >= '0' && ch > st { { START, { START, SIGNED, IN_NUMBER, END } }, { SIGNED, { END, END, IN_NUMBER, END } }, { IN_NUMBER, { END, END, IN_NUMBER, END } }, { END, {END, END, END, END } } }; char sign = '+'; long long num = 0; STATUS status = START; for (auto ch : s) { status = st[status][getCol(ch)]; if (status == IN_NUMBER) { num = num * 10 + ch - '0'; if (sign == '+' && num >= MaxNum) { return MaxNum; } else if (sign == '-' && num >= -(long long)MinNum) { return MinNum; } } else if (status == SIGNED) { sign = ch; } else if (status == END) { break; } } return sign == '+' ? num : -num; } }; Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-25 18:31:45 "},"docs/leetcode/1-100/9.html":{"url":"docs/leetcode/1-100/9.html","title":"9.回文数","keywords":"","body":"回文数(简单)解法一解法二回文数(简单) 给你一个整数 x ，如果 x 是一个回文整数，返回 true ；否则，返回 false 。 回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。例如，121 是回文，而 123 不是。 示例 1： 输入：x = 121 输出：true 示例 2： 输入：x = -121 输出：false 解释：从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。 示例 3： 输入：x = 10 输出：false 解释：从右向左读, 为 01 。因此它不是一个回文数。 示例 4： 输入：x = -101 输出：false 提示： -2^31 进阶：你能不将整数转为字符串来解决这个问题吗？ 解法一 转成字符串，对字符串从两边向中间逐个字符比较。 class Solution { public: bool isPalindrome(int x) { string s(to_string(x)); int n = s.size() - 1; for (int i = 0; i 解法二 反转数字，为了防止越界，使用 long class Solution { public: bool isPalindrome(int x) { if (x 优化 看了题解，发现题解的思路很妙，只需要考虑反转一半就可以判断是否为回文数，不需要考虑溢出问题。 如何判断是否反转了一半？当反转的数字大于等于已经除以很多次10的原数字时，就说明已经反转了一半了。 题解 class Solution { public: bool isPalindrome(int x) { if (x Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-29 10:55:33 "},"docs/leetcode/1-100/10.html":{"url":"docs/leetcode/1-100/10.html","title":"10.正则表达式匹配","keywords":"","body":"正则表达式是匹配(困难)解法一解法二正则表达式是匹配(困难) 给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 '.' 和 '*' 的正则表达式匹配。 '.' 匹配任意单个字符 '*' 匹配零个或多个前面的那一个元素 所谓匹配，是要涵盖 整个 字符串 s的，而不是部分字符串。 示例 1： 输入：s = \"aa\" p = \"a\" 输出：false 解释：\"a\" 无法匹配 \"aa\" 整个字符串。 示例 2: 输入：s = \"aa\" p = \"a*\" 输出：true 解释：因为 '*' 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 'a'。因此，字符串 \"aa\" 可被视为 'a' 重复了一次。 示例 3： 输入：s = \"ab\" p = \".*\" 输出：true 解释：\".*\" 表示可匹配零个或多个（'*'）任意字符（'.'）。 示例 4： 输入：s = \"aab\" p = \"c*a*b\" 输出：true 解释：因为 '*' 表示零个或多个，这里 'c' 为 0 个, 'a' 被重复一次。因此可以匹配字符串 \"aab\"。 示例 5： 输入：s = \"mississippi\" p = \"mis*is*p*.\" 输出：false 提示： 0 0 s 可能为空，且只包含从 a-z 的小写字母。 p 可能为空，且只包含从 a-z 的小写字母，以及字符 . 和 *。 `保证每次出现字符 * 时，前面都匹配到有效的字符 解法一 回溯法 因为 * 号可以匹配0个或多个它前面的字符, 所以很有三种情况需要处理 情况一复制前面的字符 s = \"aaa\"; p = \"a*\"; 这个时候, 星号正常复制前面的字符与s的字符进行匹配 情况二停止复制 s = \"aaab\"; p = \"a*ab\"; 如果星号一直复制下去, 将导致星号后面的字符 a 匹配失败, 所以 星号 在匹配了一个 a 之后需要停止复制, 然后用后面的 a 继续匹配, 才能返回 true 情况三丢弃 s = \"aaab\"; p = \"aa*aab\"; 如果把 a* 匹配上去的话, 那么将多出来一个 a, 所以这里的 a* 需要丢弃掉, 才能返回 true class Solution { public: bool isMatch(string s, string p) { ssize_ = s.size(); psize_ = p.size(); memo_ = vector >(ssize_ + 1, vector(psize_ + 1, true)); return backtracking(s, p, 0, 0); } private: bool backtracking(const string &s, const string &p, int si, int pi) { if (!memo_[si][pi]) { return false; } if (si == ssize_) { memo_[si][pi] = pi == psize_ || (pi + 1 > memo_; }; 解法二 题解, 动态规划 正则表达式匹配题解 class Solution { public: bool isMatch(string s, string p) { int m = s.size(); int n = p.size(); auto matches = [&](int i, int j) { if (i == 0) { return false; } if (p[j - 1] == '.') { return true; } return s[i - 1] == p[j - 1]; }; vector> f(m + 1, vector(n + 1)); f[0][0] = true; for (int i = 0; i Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-25 18:31:45 "},"docs/leetcode/1-100/11.html":{"url":"docs/leetcode/1-100/11.html","title":"11.盛最多水的容器","keywords":"","body":"盛最多水的容器(中等)解法一盛最多水的容器(中等) 给你 n 个非负整数 a1，a2，...，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0) 。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。 说明：你不能倾斜容器。 示例 1： 输入：[1,8,6,2,5,4,8,3,7] 输出：49 解释：图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。 示例 2： 输入：height = [1,1] 输出：1 示例 3： 输入：height = [4,3,2,1,4] 输出：16 示例 4： 输入：height = [1,2,1] 输出：2 提示： n = height.length 2 0 解法一 双指针 这道题和接雨水的题目很相似, 解法也大同小异, 题解解释的也很清楚, 最好还是看题解的说明更好 题解 class Solution { public: int maxArea(vector& height) { int maxWater = 0; int lidx = 0; int ridx = height.size() - 1; while (lidx 优化一下代码 class Solution { public: int maxArea(vector& height) { int maxWater = 0; int lidx = 0; int ridx = height.size() - 1; while (lidx height[ridx] ? height[ridx--] : height[lidx++]; maxWater = max(maxWater, minh * (ridx - lidx + 1)); } return maxWater; } }; Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-25 18:31:45 "},"docs/leetcode/1-100/13.html":{"url":"docs/leetcode/1-100/13.html","title":"13.罗马数字转整数","keywords":"","body":"罗马数字转整数(简单)解法一罗马数字转整数(简单) 罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。 字符 数值 I 1 V 5 X 10 L 50 C 100 D 500 M 1000 例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做 XXVII, 即为 XX + V + II 。 通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况： I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。 X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。 给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。 示例 1: 输入: \"III\" 输出: 3 示例 2: 输入: \"IV\" 输出: 4 示例 3: 输入: \"IX\" 输出: 9 示例 4: 输入: \"LVIII\" 输出: 58 解释: L = 50, V= 5, III = 3. 示例 5: 输入: \"MCMXCIV\" 输出: 1994 解释: M = 1000, CM = 900, XC = 90, IV = 4. 提示： 1 s 仅含字符 ('I', 'V', 'X', 'L', 'C', 'D', 'M') 题目数据保证 s 是一个有效的罗马数字，且表示整数在范围 [1, 3999] 内 题目所给测试用例皆符合罗马数字书写规则，不会出现跨位等情况。 IL 和 IM 这样的例子并不符合题目要求，49 应该写作 XLIX，999 应该写作 CMXCIX 。 关于罗马数字的详尽书写规则，可以参考 罗马数字 - Mathematics 。 解法一 根据题意, 当一个小的数字在一个大的数字前面时, 那么这两个数的组合的数字必定是这个大的数字减去小的数字 否则就一直累加罗马数字对应的整数数字就可以了. 记得因为每次都累加, 所以当遇到相减的时候, 需要减去2倍(因为前面已经被累加过一次了). class Solution { public: int romanToInt(string s) { int ans; int num = getnum(s[0]); int lastnum = num; ans = num; for (int i = 1; i Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-25 18:31:45 "},"docs/leetcode/1-100/14.html":{"url":"docs/leetcode/1-100/14.html","title":"14.最长公共前缀","keywords":"","body":"最长公共前缀(简单)解法一解法二最长公共前缀(简单) 编写一个函数来查找字符串数组中的最长公共前缀。 如果不存在公共前缀，返回空字符串 \"\"。 示例 1： 输入：strs = [\"flower\",\"flow\",\"flight\"] 输出：\"fl\" 示例 2： 输入：strs = [\"dog\",\"racecar\",\"car\"] 输出：\"\" 解释：输入不存在公共前缀。 提示： 0 0 strs[i] 仅由小写英文字母组成 解法一 纵向比较 最长的公共前缀只能小于等于最短的字符串长度，先找出最短的字符串长度，以该长度为遍历基准，每次比较所有字符串的相同位置的字符，遇到不一样的就说明该字符前面的字符串是最长公共前缀。 class Solution { public: string longestCommonPrefix(vector& strs) { if (strs.empty()) { return \"\"; } int minLen = 0x7fffffff; for (const auto &str : strs) { minLen = min(minLen, (int)str.size()); } string ans(\"\"); for (int i = 0; i 把ans字符串替换为下标。 class Solution { public: string longestCommonPrefix(vector& strs) { if (strs.empty()) { return \"\"; } int minLen = 0x7fffffff; for (const auto &str : strs) { minLen = min(minLen, (int)str.size()); } int i = 0; for (; i 解法二 横向比较 字符串进行两两比较找两个字符串的最长公共前缀，然后以该前缀为一个新的字符串与下一个字符串进行最长前缀寻找，直到比较完所有字符串或找到的最长公共前缀为空时结束。 class Solution { public: string longestCommonPrefix(vector& strs) { if (strs.empty()) { return \"\"; } string preStr = strs[0]; for (int i = 1; i Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-25 18:31:45 "},"docs/leetcode/1-100/17.html":{"url":"docs/leetcode/1-100/17.html","title":"17.电话号码的字符组合","keywords":"","body":"电话号码的字符组合(中等)解法一解法二电话号码的字符组合(中等) 给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案可以按 任意顺序 返回。 给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。 示例 1： 输入：digits = \"23\" 输出：[\"ad\",\"ae\",\"af\",\"bd\",\"be\",\"bf\",\"cd\",\"ce\",\"cf\"] 示例 2： 输入：digits = \"\" 输出：[] 示例 3： 输入：digits = \"2\" 输出：[\"a\",\"b\",\"c\"] 提示： 0 digits[i] 是范围 ['2', '9'] 的一个数字。 解法一 回溯法 题解思路 首先使用哈希表存储每个数字对应的所有可能的字母，然后进行回溯操作。 回溯过程中维护一个字符串，表示已有的字母排列（如果未遍历完电话号码的所有数字，则已有的字母排列是不完整的）。该字符串初始为空。每次取电话号码的一位数字，从哈希表中获得该数字对应的所有可能的字母，并将其中的一个字母插入到已有的字母排列后面，然后继续处理电话号码的后一位数字，直到处理完电话号码中的所有数字，即得到一个完整的字母排列。然后进行回退操作，遍历其余的字母排列。 回溯算法用于寻找所有的可行解，如果发现一个解不可行，则会舍弃不可行的解。在这道题中，由于每个数字对应的每个字母都可能进入字母组合，因此不存在不可行的解，直接穷举所有的解即可。 class Solution { public: vector letterCombinations(string digits) { if (digits.empty()) { return vector(); } unordered_map charmap { {'2', \"abc\"}, {'3', \"def\"}, {'4', \"ghi\"}, {'5', \"jkl\"}, {'6', \"mno\"}, {'7', \"pqrs\"}, {'8', \"tuv\"}, {'9', \"wxyz\"} }; vector answer; string comb; backtrack(answer, charmap, digits, 0, comb); return answer; } private: void backtrack(vector &answer, unordered_map &charmap, const string &digits, int idx, string &comb) { if (comb.size() == digits.size()) { answer.push_back(comb); return ; } string letters = charmap[digits[idx]]; for (int i = 0; i 解法二 队列 相当于把回溯改为了这种方式, 使用队列很巧妙. 第一层是空字符串, 相当于起点, 每深入(digits的下个字符)一层字符, 就要多循环 数字对应字符的个数乘以之前的数字对应的字符数字 次 然后用队列保存所有的组合结果 class Solution { public: vector letterCombinations(string digits) { if (digits.empty()) { return vector(); } unordered_map charmap { {'2', \"abc\"}, {'3', \"def\"}, {'4', \"ghi\"}, {'5', \"jkl\"}, {'6', \"mno\"}, {'7', \"pqrs\"}, {'8', \"tuv\"}, {'9', \"wxyz\"} }; vector answer; string comb; queue q; q.push(\"\"); for (auto &digit : digits) { int size = q.size(); for (int i = 0; i Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-25 18:31:45 "},"docs/leetcode/1-100/19.html":{"url":"docs/leetcode/1-100/19.html","title":"19.删除链表的倒数第N个节点","keywords":"","body":"删除链表的倒数第N个节点(中等)解法一删除链表的倒数第N个节点(中等) 给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。 进阶： 你能尝试使用一趟扫描实现吗？ 示例 1： 输入：head = [1,2,3,4,5], n = 2 输出：[1,2,3,5] 示例 2： 输入：head = [1], n = 1 输出：[] 示例 3： 输入：head = [1,2], n = 1 输出：[1] 提示： 链表中结点的数目为 sz 1 0 1 解法一 使用快慢指针，先让快指针跑n个节点，然后再让快慢指针一起跑，用第三个指针记录慢指针的前一个节点的为止，用于删除慢指针节点。 /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public: ListNode* removeNthFromEnd(ListNode* head, int n) { ListNode *pFast = head; ListNode *pSlow = head; ListNode *pPreSlow = head; int count = 0; while (pFast && count next; ++count; } while (pFast) { pFast = pFast->next; pPreSlow = pSlow; pSlow = pSlow->next; } if (pPreSlow == pSlow) { head = pPreSlow->next; } else { pPreSlow->next = pSlow->next; } return head; } }; 优化 在上面的基础上，删除掉第三个指针，让慢指针再慢上一个节点，这样删除的就是慢指针的下一个节点了； 需要注意的是，删除头指针时特殊处理。 /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public: ListNode* removeNthFromEnd(ListNode* head, int n) { ListNode *pFast = head; ListNode *pSlow = head; int count = 0; while (pFast) { pFast = pFast->next; if (count++ > n) { pSlow = pSlow->next; } } if (pSlow == head && count == n) { head = pSlow->next; } else { pSlow->next = pSlow->next->next; } return head; } }; 哑节点优化 在头节点前再加一个节点，这个节点为哑节点，这样就可以不用判断头指针的特殊情况了。 /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public: ListNode* removeNthFromEnd(ListNode* head, int n) { ListNode *pFast = head; ListNode *pDummy = new ListNode(); ListNode *pSlow = pDummy; pSlow->next = head; int count = 0; while (pFast) { pFast = pFast->next; if (++count > n) { pSlow = pSlow->next; } } pSlow->next = pSlow->next->next; return pDummy->next; } }; Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-28 11:09:27 "},"docs/leetcode/1-100/21.html":{"url":"docs/leetcode/1-100/21.html","title":"21.合并两个有序链表","keywords":"","body":"合并两个有序链表(简单)解法一解法二合并两个有序链表(简单) 将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 示例 1： 输入：l1 = [1,2,4], l2 = [1,3,4] 输出：[1,1,2,3,4,4] 示例 2： 输入：l1 = [], l2 = [] 输出：[] 示例 3： 输入：l1 = [], l2 = [0] 输出：[0] 提示： 两个链表的节点数目范围是 [0, 50] -100 l1 和 l2 均按 非递减顺序 排列 解法一 直接归并。 /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public: ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) { ListNode head; ListNode *node = &head; while (l1 && l2) { if (l1->val > l2->val) { node->next = l2; l2 = l2->next; } else { node->next = l1; l1 = l1->next; } node = node->next; } node->next = l1 ? l1 : l2; return head.next; } }; 解法二 递归 /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public: ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) { if (!l1) { return l2; } else if (!l2) { return l1; } if (l1->val > l2->val) { l2->next = mergeTwoLists(l1, l2->next); return l2; } else { l1->next = mergeTwoLists(l1->next, l2); return l1; } } }; Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-28 17:31:37 "},"docs/leetcode/1-100/22.html":{"url":"docs/leetcode/1-100/22.html","title":"22.括号生成","keywords":"","body":"括号生成(中等)解法一解法二解法三括号生成(中等) 数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。 示例 1： 输入：n = 3 输出：[\"((()))\",\"(()())\",\"(())()\",\"()(())\",\"()()()\"] 示例 2： 输入：n = 1 输出：[\"()\"] 提示： 1 解法一 队列, bfs 括号一对一对的生成, 以第一个右括号开始, 第一对生成到第一个右括号的左边, 然后继续寻找右括号, 每次都生成一对括号到右括号左边 然后根据生成括号的对数一层层的深入增加 这样的方法在生成的过程中会保存一些重复的括号对, 这里使用了hashset进行去重剪枝 class Solution { public: vector generateParenthesis(int n) { queue que; que.push(\"()\"); for (int i = 1; i diff; for (int j = 0; j answer; while (!que.empty()) { answer.push_back(que.front()); que.pop(); } return answer; } }; 解法二 回溯, dfs 这种类型的题用回溯的方式比较容易想到, n对括号, 也就是需要生成 n 个左括号和 n 个右括号, 且在生成左右括号时, 在从左往右生成括号时, 右括号的数量不能多余左括号 在 n 个左括号和 n 个右括号都生成完毕时, 也就是达到了该路的底端, 组合的括号字符串就是一个结果. class Solution { public: vector generateParenthesis(int n) { vector answer; backtrack(answer, \"\", n, n); return answer; } private: void backtrack(vector &answer, string s, int left, int right) { if (left == 0 && right == 0) { answer.push_back(s); return ; } if (left == right) { backtrack(answer, s + \"(\", left - 1, right); } else { if (left > 0) { backtrack(answer, s + \"(\", left - 1, right); } backtrack(answer, s + \")\", left, right - 1); } } }; 解法三 bfs 把回溯转换成了bfs, 思路和dfs一样, 队列保存每一层级的所有有效括号情况. class Solution { public: vector generateParenthesis(int n) { vector answer; queue que; que.push({\"\", n, n}); while (!que.empty()) { Node node = que.front(); que.pop(); if (node.left == 0 && node.right == 0) { answer.push_back(node.s); } if (node.left > 0) { que.push({node.s + \"(\", node.left - 1, node.right}); } if (node.left 0) { que.push({node.s + \")\", node.left, node.right - 1}); } } return answer; } private: struct Node { string s; int left; int right; }; }; Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-25 18:31:45 "},"docs/leetcode/1-100/23.html":{"url":"docs/leetcode/1-100/23.html","title":"23.合并K个升序链表","keywords":"","body":"合并K个升序链表(困难)解法一解法二合并K个升序链表(困难) 给你一个链表数组，每个链表都已经按升序排列。 请你将所有链表合并到一个升序链表中，返回合并后的链表。 示例 1： 输入：lists = [[1,4,5],[1,3,4],[2,6]] 输出：[1,1,2,3,4,4,5,6] 解释：链表数组如下： [ 1->4->5, 1->3->4, 2->6 ] 将它们合并到一个有序链表中得到。 1->1->2->3->4->4->5->6 示例 2： 输入：lists = [] 输出：[] 示例 3： 输入：lists = [[]] 输出：[] 提示： k == lists.length 0 0 -10^4 lists[i] 按 升序 排列 lists[i].length 的总和不超过 10^4 解法一 暴力合并，每次都循环遍历所有的list，找到最小值的那个节点，然后归并到统一链表中，直到所有的list都被归并到统一链表； 设置一个最大值的哑节点，作为一个检测是否都归并到统一链表的依据。 /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public: ListNode* mergeKLists(vector& lists) { ListNode *head = nullptr; ListNode *dummy = new ListNode(10001); ListNode *node = nullptr; ListNode *minNode = dummy; int idx = -1; while (true) { for (int i = 0; i val > lists[i]->val) { minNode = lists[i]; idx = i; } } if (minNode == dummy) { break; } lists[idx] = lists[idx]->next; if (!head) { head = minNode; node = head; } else { node->next = minNode; node = node->next; } node->next = nullptr; minNode = dummy; } delete dummy; return head; } }; 优化 在上面代码段基础上，充分使用哑节点，把哑节点当做一个虚拟头指针，这样过程中就不用判断头指针的特殊情况了，最终返回哑节点的下一个节点就是真实的头节点。 /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public: ListNode* mergeKLists(vector& lists) { ListNode *dummy = new ListNode(10001); ListNode *node = dummy; ListNode *minNode = dummy; int idx = -1; while (true) { for (int i = 0; i val > lists[i]->val) { minNode = lists[i]; idx = i; } } if (minNode == dummy) { break; } lists[idx] = lists[idx]->next; node->next = minNode; node = node->next; node->next = nullptr; minNode = dummy; } node = dummy->next; delete dummy; return node; } }; 解法二 顺序合并，每每两个链表进行合并。 /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public: ListNode* mergeKLists(vector& lists) { if (lists.empty()) { return nullptr; } auto merge2Lists = [](ListNode *l1, ListNode *l2) { ListNode *dummy = new ListNode(); ListNode *node = dummy; while (l1 && l2) { if (l1->val val) { node->next = l1; l1 = l1->next; } else { node->next = l2; l2 = l2->next; } node = node->next; } node->next = l1 ? l1 : l2; node = dummy->next; delete dummy; return node; }; ListNode *ans = lists[0]; for (int i = 1; i Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-28 12:39:26 "},"docs/leetcode/1-100/24.html":{"url":"docs/leetcode/1-100/24.html","title":"24.两两交换链表中的节点","keywords":"","body":"两两交换链表中的节点(中等)解法一两两交换链表中的节点(中等) 给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。 你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。 示例 1： 输入：head = [1,2,3,4] 输出：[2,1,4,3] 示例 2： 输入：head = [] 输出：[] 示例 3： 输入：head = [1] 输出：[1] 提示： 链表中节点的数目在范围 [0, 100] 内 0 进阶：你能在不修改链表节点值的情况下解决这个问题吗?（也就是说，仅修改节点本身。） 解法一 /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public: ListNode* swapPairs(ListNode* head) { if (!head || !head->next) { return head; } ListNode newHead; ListNode *node1 = head; ListNode *node2 = head->next; newHead.next = node2; ListNode *tmp; while (node2) { if (!node2->next) { node2->next = node1; node1->next = nullptr; break; } node1->next = node2->next->next ? node2->next->next : node2->next; tmp = node1; node1 = node2->next; node2->next = tmp; node2 = node1->next; } return newHead.next; } }; 优化 参考题解思路，设置一个前置哑节点，哑节点是每次交换的两个节点的前置节点。 /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public: ListNode* swapPairs(ListNode* head) { ListNode dummy; dummy.next = head; ListNode *node = &dummy; while (node->next && node->next->next) { ListNode *node1 = node->next; ListNode *node2 = node->next->next; node->next = node2; node1->next = node2->next; node2->next= node1; node = node->next->next; } return dummy.next; } }; Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-29 08:52:27 "},"docs/leetcode/1-100/26.html":{"url":"docs/leetcode/1-100/26.html","title":"26.删除有序数组中的重复项","keywords":"","body":"删除有序数组中的重复项(简单)解法一删除有序数组中的重复项(简单) 给你一个有序数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。 不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。 说明: 为什么返回数值是整数，但输出的答案是数组呢? 请注意，输入数组是以「引用」方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。 你可以想象内部操作如下: // nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝 int len = removeDuplicates(nums); // 在函数里修改输入数组对于调用者是可见的。 // 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。 for (int i = 0; i 示例 1： 输入：nums = [1,1,2] 输出：2, nums = [1,2] 解释：函数应该返回新的长度 2 ，并且原数组 nums 的前两个元素被修改为 1, 2 。不需要考虑数组中超出新长度后面的元素。 示例 2： 输入：nums = [0,0,1,1,1,2,2,3,3,4] 输出：5, nums = [0,1,2,3,4] 解释：函数应该返回新的长度 5 ， 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4 。不需要考虑数组中超出新长度后面的元素。 提示： 0 -104 nums 已按升序排列 解法一 class Solution { public: int removeDuplicates(vector& nums) { if(nums.empty()) { return 0; } int preIdx = 1; for (int i = 1; i Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-25 18:31:45 "},"docs/leetcode/1-100/28.html":{"url":"docs/leetcode/1-100/28.html","title":"28.实现strStr()","keywords":"","body":"实现strStr()(简单)解法一实现strStr()(简单) 给你两个字符串 haystack 和 needle ，请你在 haystack 字符串中找出 needle 字符串出现的第一个位置（下标从 0 开始）。如果不存在，则返回 -1 。 说明： 当 needle 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。 对于本题而言，当 needle 是空字符串时我们应当返回 0 。这与 C 语言的 strstr() 以及 Java 的 indexOf() 定义相符。 示例 1： 输入：haystack = \"hello\", needle = \"ll\" 输出：2 示例 2： 输入：haystack = \"aaaaa\", needle = \"bba\" 输出：-1 示例 3： 输入：haystack = \"\", needle = \"\" 输出：0 提示： 0 haystack 和 needle 仅由小写英文字符组成 解法一 使用string的find功能, 直接可以寻找字符串, 注意处理寻找不到的情况pos的值与题目要求不一样, 需要转换一下. class Solution { public: int strStr(string haystack, string needle) { if (needle.empty()) { return 0; } string::size_type pos = haystack.find(needle); return pos == string::npos ? -1 : pos; } }; Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-25 18:31:45 "},"docs/leetcode/1-100/32.html":{"url":"docs/leetcode/1-100/32.html","title":"32.最长有效括号","keywords":"","body":"最长有效括号(困难)解法一解法二最长有效括号(困难) 给你一个只包含 '(' 和 ')' 的字符串，找出最长有效（格式正确且连续）括号子串的长度。 示例 1： 输入：s = \"(()\" 输出：2 解释：最长有效括号子串是 \"()\" 示例 2： 输入：s = \")()())\" 输出：4 解释：最长有效括号子串是 \"()()\" 示例 3： 输入：s = \"\" 输出：0 提示： 0 s[i] 为 '(' 或 ')' 解法一 bfs 使用栈来模拟括号配对 如果是左括号, 就入栈, 如果是右括号, 就出栈, 说明一对括号匹配成功 在匹配的过程中, 需要记录最后一次匹配失败的地方, 也就是栈为空的时候, 匹配到了 右括号的地方, 这是后面匹配成功最长有效括号的起点 因为一开始的时候栈就为空, 所以规定往栈里面添加一个 -1, 用于记录最开始的下标 // 开始为空, 匹配两对括号后, 需要从 0 到 最后匹配的长度 1. ()() // 直接匹配到左括号 2. )() class Solution { public: int longestValidParentheses(string s) { stack stk; stk.push(-1); int validMax = 0; for (int i = 0; i 解法二 题解答案 在此方法中，我们利用两个计数器 left 和 right 。首先，我们从左到右遍历字符串，对于遇到的每个 '('，我们增加 left 计数器，对于遇到的每个 ')' ，我们增加 right 计数器。每当 left 计数器与 right 计数器相等时，我们计算当前有效字符串的长度，并且记录目前为止找到的最长子字符串。当 right 计数器比 left 计数器大时，我们将 left 和 right 计数器同时变回 0 这样的做法贪心地考虑了以当前字符下标结尾的有效括号长度，每次当右括号数量多于左括号数量的时候之前的字符我们都扔掉不再考虑，重新从下一个字符开始计算，但这样会漏掉一种情况，就是遍历的时候左括号的数量始终大于右括号的数量，即 (() ，这种时候最长有效括号是求不出来的。 解决的方法也很简单，我们只需要从右往左遍历用类似的方法计算即可，只是这个时候判断条件反了过来： 当 left 计数器比 right 计数器大时，我们将 left 和 right 计数器同时变回 0 当 left 计数器与 right 计数器相等时，我们计算当前有效字符串的长度，并且记录目前为止找到的最长子字符串 class Solution { public: int longestValidParentheses(string s) { int left = 0, right = 0, maxlength = 0; for (int i = 0; i left) { left = right = 0; } } left = right = 0; for (int i = (int)s.length() - 1; i >= 0; i--) { if (s[i] == '(') { left++; } else { right++; } if (left == right) { maxlength = max(maxlength, 2 * left); } else if (left > right) { left = right = 0; } } return maxlength; } }; Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-25 18:31:45 "},"docs/leetcode/1-100/37.html":{"url":"docs/leetcode/1-100/37.html","title":"37.解数独","keywords":"","body":"解数独(困难)解法一解数独(困难) 编写一个程序，通过填充空格来解决数独问题。 数独的解法需 遵循如下规则： 数字 1-9 在每一行只能出现一次。 数字 1-9 在每一列只能出现一次。 数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。（请参考示例图） 数独部分空格内已填入了数字，空白格用 '.' 表示。 示例： 输入：board = [[\"5\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"],[\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"],[\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"],[\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"],[\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"],[\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"],[\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"],[\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"]] 输出：[[\"5\",\"3\",\"4\",\"6\",\"7\",\"8\",\"9\",\"1\",\"2\"],[\"6\",\"7\",\"2\",\"1\",\"9\",\"5\",\"3\",\"4\",\"8\"],[\"1\",\"9\",\"8\",\"3\",\"4\",\"2\",\"5\",\"6\",\"7\"],[\"8\",\"5\",\"9\",\"7\",\"6\",\"1\",\"4\",\"2\",\"3\"],[\"4\",\"2\",\"6\",\"8\",\"5\",\"3\",\"7\",\"9\",\"1\"],[\"7\",\"1\",\"3\",\"9\",\"2\",\"4\",\"8\",\"5\",\"6\"],[\"9\",\"6\",\"1\",\"5\",\"3\",\"7\",\"2\",\"8\",\"4\"],[\"2\",\"8\",\"7\",\"4\",\"1\",\"9\",\"6\",\"3\",\"5\"],[\"3\",\"4\",\"5\",\"2\",\"8\",\"6\",\"1\",\"7\",\"9\"]] 解释：输入的数独如上图所示，唯一有效的解决方案如下所示： 提示： board.length == 9 board[i].length == 9 board[i][j] 是一位数字或者 '.' 题目数据 保证 输入数独仅有一个解 解法一 用三个数组表示行、列和小九方格中1-9数字的使用情况, 用另外一个容器存储下空白方格的下标, 用于回溯尝试填写数字. 注意只有当三个标记数字使用情况的标记都没有使用过该数字时, 表示可以填写. class Solution { public: void solveSudoku(vector>& board) { int idx = 0; for (int i = 0; i > &board, int idx) { if (idx == space_.size()) { volid_ = true; return ; } auto [i, j] = space_[idx]; for (int digit = 1; digit , 9> line_; array, 9> col_; array, 3>, 3> block_; vector > space_; bool volid_ = false; }; Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-25 18:31:45 "},"docs/leetcode/1-100/39.html":{"url":"docs/leetcode/1-100/39.html","title":"39.组合总和","keywords":"","body":"组合总和解法一组合总和 给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。 candidates 中的数字可以无限制重复被选取。 说明： 所有数字（包括 target）都是正整数。 解集不能包含重复的组合。 示例 1： 输入：candidates = [2,3,6,7], target = 7, 所求解集为： [ [7], [2,2,3] ] 示例 2： 输入：candidates = [2,3,5], target = 8, 所求解集为： [ [2,2,2,2], [2,3,3], [3,5] ] 提示： 1 1 candidate 中的每个元素都是独一无二的。 1 解法一 使用回溯的方法解题, 这个是题解的思路答案, 没有剪枝 对于这类寻找所有可行解的题，我们都可以尝试用「搜索回溯」的方法来解决。 回到本题，我们定义递归函数 dfs(target, combine, idx) 表示当前在 candidates 数组的第 idx 位，还剩 target 要组合，已经组合的列表为 combine。递归的终止条件为 target 更形象化地说，如果我们将整个搜索过程用一个树来表达，即如下图呈现，每次的搜索都会延伸出两个分叉，直到递归的终止条件，这样我们就能不重复且不遗漏地找到所有可行解： class Solution { public: vector> combinationSum(vector& candidates, int target) { vector > ans; vector combine; dfs(target, candidates, ans, combine, 0); return ans; } private: void dfs(int target, const vector &candidates, vector > &ans, vector &combine, int idx) { if (idx == candidates.size()) { return ; } if (target == 0) { ans.emplace_back(combine); return ; } dfs(target, candidates, ans, combine, idx + 1); if (target - candidates[idx] >= 0) { combine.emplace_back(candidates[idx]); dfs(target - candidates[idx], candidates, ans, combine, idx); combine.pop_back(); } } }; Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-25 18:31:45 "},"docs/leetcode/1-100/42.html":{"url":"docs/leetcode/1-100/42.html","title":"42.接雨水","keywords":"","body":"接雨水(困难)解法一解法二解法三解法四接雨水(困难) 给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。 示例 1： 输入：height = [0,1,0,2,1,0,1,3,2,1,2,1] 输出：6 解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 示例 2： 输入：height = [4,2,0,3,2,5] 输出：9 提示： n == height.length 0 0 解法一 暴力法, 时间复杂度(On^2) 假设左边有一个左边界柱子, 想找到一个纯更多水的容器, 只有寻找一个不比左边边界柱子矮的一个右柱子或找到一个整个柱子数组中除左边界柱子外的最大值高度, 只有这样组成的范围, 才是最大的盛水范围. 把高度数组保存到一个list中, 然后对list升序排序, 这为了方便找到最大高度 左边从第一个柱子开始, 当找到最大高度或比左边界高的柱子时, 就计算该范围的盛水量, 然后以右边界柱子为起始点继续向右寻找. 在计算的过程中, 需要去除已经计算过的柱子, 是为了防止这些柱子中有较高的柱子对后面的寻找造成影响. class Solution { public: int trap(vector& height) { if (height.size() h { ++height.begin(), height.end() }; h.sort(); int ans = 0; pair l {height[0], 0}; for (int i = 1; i = l.first || height[i] == h.back()) { int lowWater; if (height[i] >= l.first) { lowWater = l.first; h.erase(find(h.begin(), h.end(), height[i])); } else { lowWater = height[i]; h.pop_back(); } while (++l.second 解法二 动态规划 从左往右遍历，可以获取每个柱子的左边界最大值从右往左遍历，可以获取每个柱子的右边的最大值 柱子的左边最大值和右边最大值取其小值，再去掉柱子的高度，就是盛水量。 class Solution { public: int trap(vector& height) { if (height.size() =0; --i) { right[i] = max(height[i], right[i + 1]); } int ans = 0; for (int i = 0; i 解法三 单调栈 用一个栈来存放柱子的下标，且要保证栈低到栈顶是从大到小的顺序排列 栈顶下面的一个元素称之为 left 每当遇到一个柱子的高度大于当前栈顶时，且栈内元素大于2，则从 left 到该柱子之间是可以盛水的 class Solution { public: int trap(vector& height) { stack stk; int ans = 0; for (int i = 0; i height[stk.top()]) { int top = stk.top(); stk.pop(); if (stk.empty()) { break; } int width = i - stk.top() - 1; int currHeight = min(height[i], height[stk.top()]) - height[top]; ans += currHeight * width; } stk.push(i); } return ans; } }; 解法四 双指针 题解 class Solution { public: int trap(vector& height) { if (height.size() = rmax) { ans += rmax - height[ridx--]; } else { ans += lmax - height[lidx++]; } } return ans; } }; Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-25 18:31:45 "},"docs/leetcode/1-100/43.html":{"url":"docs/leetcode/1-100/43.html","title":"43.字符串相乘","keywords":"","body":"字符串相乘(中等)解法一字符串相乘(中等) 给定两个以字符串形式表示的非负整数 num1 和 num2，返回 num1 和 num2 的乘积，它们的乘积也表示为字符串形式。 示例 1: 输入: num1 = \"2\", num2 = \"3\" 输出: \"6\" 示例 2: 输入: num1 = \"123\", num2 = \"456\" 输出: \"56088\" 说明： num1 和 num2 的长度小于 110。 num1 和 num2 只包含数字 0-9。 num1 和 num2 均不以零开头，除非是数字 0 本身。 不能使用任何标准库的大数类型（比如 BigInteger）或直接将输入转换为整数来处理。 解法一 模拟 模拟两个数字相乘的过程，逐位计算 需要注意的是，在模拟计算中，num1的十位与num2相乘时，在与个位计算的结果想加时，要注意错位(十位的要多一个0)，同样百位，千万都是如此。 class Solution { public: string multiply(string num1, string num2) { if (num1 == \"0\" || num2 == \"0\") { return \"0\"; } int k = 0; int result = 0; string ans; int cnt = 0; int idx = 0; for (int i = num1.size() - 1; i >= 0; --i) { int n1 = num1[i] - '0'; idx = cnt; for (int j = num2.size() - 1; j >= 0; --j) { int calIdx = cnt + (num2.size() - 1 - j); result = (num2[j] - '0') * n1 + (ans.size() > calIdx ? ans[calIdx] - '0' : 0); char calVal = ((result + k) % 10) + '0'; if (ans.size() Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-25 18:31:45 "},"docs/leetcode/1-100/45.html":{"url":"docs/leetcode/1-100/45.html","title":"45.跳跃游戏2","keywords":"","body":"跳跃游戏2(中等)解法一解法二跳跃游戏2(中等) 给定一个非负整数数组，你最初位于数组的第一个位置。 数组中的每个元素代表你在该位置可以跳跃的最大长度。 你的目标是使用最少的跳跃次数到达数组的最后一个位置。 假设你总是可以到达数组的最后一个位置。 示例 1: 输入: [2,3,1,1,4] 输出: 2 解释: 跳到最后一个位置的最小跳跃数是 2。 从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。 示例 2: 输入: [2,3,0,1,4] 输出: 2 提示: 1 0 解法一 贪心算法 倒序查找, 寻找最后一步能到达目的地的最大值, 这样就能找到整个结果的最优解 class Solution { public: int jump(vector& nums) { int ans = 0; int idx = nums.size() - 1; while(idx > 0) { for (int i = 0; i 解法二 题解答案 与贪心的查找相反, 该方法正向查找, 每次寻找最大的能跳跃的点, 并且要记录该路径上哪一个点的值能够让自己跳到更远的地方, 并以该点为基础再次跳跃. 例如，对于数组 [2,3,1,2,4,2,3]，初始位置是下标 0，从下标 0 出发，最远可到达下标 2。下标 0 可到达的位置中，下标 1 的值是 3，从下标 1 出发可以达到更远的位置，因此第一步到达下标 1。从下标 1 出发，最远可到达下标 4。下标 1 可到达的位置中，下标 4 的值是 4 ，从下标 4 出发可以达到更远的位置，因此第二步到达下标 4。 class Solution { public: int jump(vector& nums) { int step = 0; int maxpos = 0; int end = 0; for (int i = 0; i Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-25 18:31:45 "},"docs/leetcode/1-100/53.html":{"url":"docs/leetcode/1-100/53.html","title":"53.最大子序和","keywords":"","body":"最大子序和(简单)解法一解法二最大子序和(简单) 给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。 示例 1： 输入：nums = [-2,1,-3,4,-1,2,1,-5,4] 输出：6 解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。 示例 2： 输入：nums = [1] 输出：1 示例 3： 输入：nums = [0] 输出：0 示例 4： 输入：nums = [-1] 输出：-1 示例 5： 输入：nums = [-100000] 输出：-100000 提示： 1 -10^5 解法一 暴力法 求出前缀和, 任意两个前缀和相减, 就是任意一个子数组的和, 求出最大的前缀和差值, 就是最大的子数组和 有可能最大的子数组就是原数组, 所以这里需留一个空位用于计算整个数组的差, 就把第0个前缀和规定为 0, class Solution { public: int maxSubArray(vector& nums) { vector sum(nums.size() + 1); int prefixSum = 0; sum[0] = 0; for (int i = 1; i 解法二 记录当前和, 如果当前和小于0, 或者当前和与当前的num值的和小于0, 那么就更新当前和为当前的num值, 否则就把当前和加上当前值 当前和相当于一个数组的第一个值, 如果一个数组的第一个值为正值, 那么它就可以作为一个可以把和变得跟大的计算成员, 如果为负值, 那它与其他数的和只会更小 class Solution { public: int maxSubArray(vector& nums) { int maxSum = nums[0]; int currSum = nums[0]; for (int i = 1; i = 0 && currSum >= 0) { currSum += nums[i]; } else { currSum = nums[i]; } maxSum = max(maxSum, currSum); } return maxSum; } }; Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-25 18:31:45 "},"docs/leetcode/1-100/65.html":{"url":"docs/leetcode/1-100/65.html","title":"65.有效数字","keywords":"","body":"有效数字(困难)解法一解法二有效数字(困难) 有效数字（按顺序）可以分成以下几个部分： 一个 小数 或者 整数 （可选）一个 'e' 或 'E' ，后面跟着一个 整数 小数（按顺序）可以分成以下几个部分： （可选）一个符号字符（'+' 或 '-'） 下述格式之一： 至少一位数字，后面跟着一个点 '.' 至少一位数字，后面跟着一个点 '.' ，后面再跟着至少一位数字 一个点 '.' ，后面跟着至少一位数字 整数（按顺序）可以分成以下几个部分： （可选）一个符号字符（'+' 或 '-'） 至少一位数字 部分有效数字列举如下： [\"2\", \"0089\", \"-0.1\", \"+3.14\", \"4.\", \"-.9\", \"2e10\", \"-90E3\", \"3e+7\", \"+6e-1\", \"53.5e93\", \"-123.456e789\"] 部分无效数字列举如下： [\"abc\", \"1a\", \"1e\", \"e3\", \"99e2.5\", \"--6\", \"-+3\", \"95a54e53\"] 给你一个字符串 s ，如果 s 是一个 有效数字 ，请返回 true 。 示例 1： 输入：s = \"0\" 输出：true 示例 2： 输入：s = \"e\" 输出：false 示例 3： 输入：s = \".\" 输出：false 示例 4： 输入：s = \".1\" 输出：true 提示： 1 s 仅含英文字母（大写和小写），数字（0-9），加号 '+' ，减号 '-' ，或者点 '.' 。 解法一 通过分情况的方式，逐步判断出字符串是否为有效数字 首先通找有没有 eE 字符 没有 eE 那么字符串就只能是一个小数或者整数 有 eE 那 eE 之前的必须是一个小数或整数，后面的必须是一个整数 然后根据小数和整数要求再完成 小数检测 和 整数检测 的方法就可以了 class Solution { public: bool isNumber(string s) { string::size_type pos = s.find_first_of(\"eE\"); if (pos == string::npos) { return isInt(s) || isDecimal(s); } string s1 = s.substr(0, pos); string s2 = s.substr(pos + 1, s.size() - pos - 1); return !s1.empty() && !s2.empty() && (isInt(s1) || isDecimal(s1)) && isInt(s2); } private: bool isSymbol(char ch) { return ch == '+' || ch == '-'; } bool isNum(char ch) { return ch >= '0' && ch isSymbol(s[0]) && s.size() > 1) { idx = 1; } while (idx isNum(s[idx++])) { return false; } } return true; } bool isDecimal(string s) { int idx = 0; int symbolCount = 0; if (this->isSymbol(s[0])) { symbolCount = 1; idx = 1; } int count = 0; int intCount = 0; while (idx isNum(s[idx])) { ++intCount; } else if (s[idx] == '.' && ++count > 1) { return false; } ++idx; } return count == 1 && intCount > 0 && intCount + count + symbolCount == s.size(); } }; 解法二 题解 有限状态自动机 class Solution { public: enum State { STATE_INITIAL, STATE_INT_SIGN, STATE_INTEGER, STATE_POINT, STATE_POINT_WITHOUT_INT, STATE_FRACTION, STATE_EXP, STATE_EXP_SIGN, STATE_EXP_NUMBER, STATE_END }; enum CharType { CHAR_NUMBER, CHAR_EXP, CHAR_POINT, CHAR_SIGN, CHAR_ILLEGAL }; CharType toCharType(char ch) { if (ch >= '0' && ch > transfer { { STATE_INITIAL, { { CHAR_NUMBER, STATE_INTEGER }, { CHAR_POINT, STATE_POINT_WITHOUT_INT }, { CHAR_SIGN, STATE_INT_SIGN } } }, { STATE_INT_SIGN, { { CHAR_NUMBER, STATE_INTEGER }, { CHAR_POINT, STATE_POINT_WITHOUT_INT }, } }, { STATE_INTEGER, { { CHAR_NUMBER, STATE_INTEGER }, { CHAR_EXP, STATE_EXP }, { CHAR_POINT, STATE_POINT } } }, { STATE_POINT, { { CHAR_NUMBER, STATE_FRACTION }, { CHAR_EXP, STATE_EXP } } }, { STATE_POINT_WITHOUT_INT, { { CHAR_NUMBER, STATE_FRACTION } } }, { STATE_FRACTION, { { CHAR_NUMBER, STATE_FRACTION }, { CHAR_EXP, STATE_EXP } } }, { STATE_EXP, { { CHAR_NUMBER, STATE_EXP_NUMBER }, { CHAR_SIGN, STATE_EXP_SIGN } } }, { STATE_EXP_SIGN, { { CHAR_NUMBER, STATE_EXP_NUMBER } } }, { STATE_EXP_NUMBER, { { CHAR_NUMBER, STATE_EXP_NUMBER } } } }; int len = s.size(); State st = STATE_INITIAL; for (int i = 0; i Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-25 18:31:45 "},"docs/leetcode/101-200/":{"url":"docs/leetcode/101-200/","title":"101~200","keywords":"","body":"题目目录题目目录 Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-25 18:31:45 "},"docs/leetcode/101-200/138.html":{"url":"docs/leetcode/101-200/138.html","title":"138.复制带随机指针的链表","keywords":"","body":"复制带随机指针的链表(中等)解法一解法二解法三解法四复制带随机指针的链表(中等) 给你一个长度为 n 的链表，每个节点包含一个额外增加的随机指针 random ，该指针可以指向链表中的任何节点或空节点。 构造这个链表的 深拷贝。 深拷贝应该正好由 n 个 全新 节点组成，其中每个新节点的值都设为其对应的原节点的值。新节点的 next 指针和 random 指针也都应指向复制链表中的新节点，并使原链表和复制链表中的这些指针能够表示相同的链表状态。复制链表中的指针都不应指向原链表中的节点 。 例如，如果原链表中有 X 和 Y 两个节点，其中 X.random --> Y 。那么在复制链表中对应的两个节点 x 和 y ，同样有 x.random --> y 。 返回复制链表的头节点。 用一个由 n 个节点组成的链表来表示输入/输出中的链表。每个节点用一个 [val, random_index] 表示： val：一个表示 Node.val 的整数。 random_index：随机指针指向的节点索引（范围从 0 到 n-1）；如果不指向任何节点，则为 null 。 你的代码 只 接受原链表的头节点 head 作为传入参数。 示例 1： 输入：head = [[7,null],[13,0],[11,4],[10,2],[1,0]] 输出：[[7,null],[13,0],[11,4],[10,2],[1,0]] 示例 2： 输入：head = [[1,1],[2,1]] 输出：[[1,1],[2,1]] 示例 3： 输入：head = [] 输出：[] 解释：给定的链表为空（空指针），因此返回 null。 提示： 0 -10000 Node.random 为空（null）或指向链表中的节点。 解法一 通过一个tab来存储旧的节点和其对应的序号, head序号为0, 依次递增. 用另一个newTab来存储新的节点, 当遍历时依次寻找旧的节点的random对应的序号, 就直接新节点的序号对应的节点赋值给当前节点的random指针即可. /* // Definition for a Node. class Node { public: int val; Node* next; Node* random; Node(int _val) { val = _val; next = NULL; random = NULL; } }; */ class Solution { public: Node* copyRandomList(Node* head) { if (head == nullptr) { return nullptr; } unordered_map tab; vector newTab; Node *p = head; Node *newp = new Node(p->val); newTab.push_back(newp); p = p->next; int idx = 0; while (p) { Node * newp = new Node(p->val); newTab[idx]->next = newp; newTab.push_back(newp); ++idx; tab[p] = idx; p = p->next; } p = head; for (int i = 0; i next) { if (p->random) { newTab[i]->random = newTab[tab[p->random]]; } } return newTab[0]; } }; 解法二 从题解看到一个比较妙的解法 用一个tab做旧节点和新节点的映射, 再遍历旧节点, 一一找出新节点的random. class Solution { public: Node* copyRandomList(Node* head) { if (head == nullptr) { return nullptr; } unordered_map tab; Node *p = head; while (p) { tab[p] = { new Node(p->val) }; p = p->next; } p = head; while (p) { auto it = tab.find(p); tab[p]->next = tab[p->next]; tab[p]->random = tab[p->random]; p = p->next; } return tab[head]; } }; 解法三 题解答案 题解 class Solution { public: Node* copyRandomList(Node* head) { if (head == nullptr) { return nullptr; } for (Node* node = head; node != nullptr; node = node->next->next) { Node* nodeNew = new Node(node->val); nodeNew->next = node->next; node->next = nodeNew; } for (Node* node = head; node != nullptr; node = node->next->next) { Node* nodeNew = node->next; nodeNew->random = (node->random != nullptr) ? node->random->next : nullptr; } Node* headNew = head->next; for (Node* node = head; node != nullptr; node = node->next) { Node* nodeNew = node->next; node->next = node->next->next; nodeNew->next = (nodeNew->next != nullptr) ? nodeNew->next->next : nullptr; } return headNew; } }; 解法四 题解答案 回溯 题解 回溯的这个原理和方法二的原理是相同的, 都是在一个tab里面做旧节点和新节点的映射. class Solution { public: unordered_map cachedNode; Node* copyRandomList(Node* head) { if (head == nullptr) { return nullptr; } if (!cachedNode.count(head)) { Node* headNew = new Node(head->val); cachedNode[head] = headNew; headNew->next = copyRandomList(head->next); headNew->random = copyRandomList(head->random); } return cachedNode[head]; } }; Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-25 18:31:45 "},"docs/leetcode/101-200/160.html":{"url":"docs/leetcode/101-200/160.html","title":"160.相交链表","keywords":"","body":"相交链表(简单)解法一相交链表(简单) 给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 null 。 图示两个链表在节点 c1 开始相交： 题目数据 保证 整个链式结构中不存在环。 注意，函数返回结果后，链表必须 保持其原始结构 。 示例1: 输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3 输出：Intersected at '8' 解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。 从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。 在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。 示例 2： 输入：intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1 输出：Intersected at '2' 解释：相交节点的值为 2 （注意，如果两个链表相交则不能为 0）。 从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。 在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。 示例 3： 输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2 输出：null 解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。 由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。 这两个链表不相交，因此返回 null 。 提示： listA 中节点数目为 m listB 中节点数目为 n 0 1 0 0 如果 listA 和 listB 没有交点，intersectVal 为 0 如果 listA 和 listB 有交点，intersectVal == listA[skipA + 1] == listB[skipB + 1] 解法一 两个链表 l1 和 l2 从 l1 头到相交的距离为 a 从 l2 头到相交的距离为 b 那么就有: l1.length - a = l2.length - b 也就是: l1.length + b = l2.length + a 也就是说, p1 指针把 l1 链表走完之后再从 l2 链表头出发, p2指针把 l2 链表走完再从 l1 链表出发, 最终两个指针会在交叉点相遇 如果两个链表没有相交, 那么最终 两个指针会同时为空, 退出循环 /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public: ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) { ListNode *p1 = headA; ListNode *p2 = headB; while (p1 != p2) { p1 = p1 ? p1->next : headB; p2 = p2 ? p2->next : headA; } return p1; } }; Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-25 18:31:45 "},"docs/leetcode/101-200/165.html":{"url":"docs/leetcode/101-200/165.html","title":"165.比价版本号","keywords":"","body":"比较版本号(中等)解法一比较版本号(中等) 给你两个版本号 version1 和 version2 ，请你比较它们。 版本号由一个或多个修订号组成，各修订号由一个 '.' 连接。每个修订号由 多位数字 组成，可能包含 前导零 。每个版本号至少包含一个字符。修订号从左到右编号，下标从 0 开始，最左边的修订号下标为 0 ，下一个修订号下标为 1 ，以此类推。例如，2.5.33 和 0.1 都是有效的版本号。 比较版本号时，请按从左到右的顺序依次比较它们的修订号。比较修订号时，只需比较 忽略任何前导零后的整数值 。也就是说，修订号 1 和修订号 001 相等 。如果版本号没有指定某个下标处的修订号，则该修订号视为 0 。例如，版本 1.0 小于版本 1.1 ，因为它们下标为 0 的修订号相同，而下标为 1 的修订号分别为 0 和 1 ，0 。 返回规则如下： 如果 version1 > version2 返回 1， 如果 version1 示例 1： 输入：version1 = \"1.01\", version2 = \"1.001\" 输出：0 解释：忽略前导零，\"01\" 和 \"001\" 都表示相同的整数 \"1\" 示例 2： 输入：version1 = \"1.0\", version2 = \"1.0.0\" 输出：0 解释：version1 没有指定下标为 2 的修订号，即视为 \"0\" 示例 3： 输入：version1 = \"0.1\", version2 = \"1.1\" 输出：-1 解释：version1 中下标为 0 的修订号是 \"0\"，version2 中下标为 0 的修订号是 \"1\" 。0 示例 4： 输入：version1 = \"1.0.1\", version2 = \"1\" 输出：1 示例 5： 输入：version1 = \"7.5.2.4\", version2 = \"7.5.3\" 输出：-1 提示： 1 version1 和 version2 仅包含数字和 '.' version1 和 version2 都是 有效版本号 version1 和 version2 的所有修订号都可以存储在 32 位整数 中 解法一 从左往右逐个数字比较, 每被一个点分割就是一个数字, 相等的话就继续后面比较, 不想等就根据大小结果来返回. 当某一个字符串找到末尾了, 就跳出循环, 继续寻找没有到末尾的那个字符串版本, 如果出现了非0值, 那这个版本就是大的. class Solution { public: int compareVersion(string version1, string version2) { string::size_type prePos1 = 0; string::size_type prePos2 = 0; string::size_type pos1, pos2; while (prePos1 != string::npos && prePos2 != string::npos) { string sv1, sv2; pos1 = version1.find(\".\", prePos1); pos2 = version2.find(\".\", prePos2); sv1 = pos1 != string::npos ? version1.substr(prePos1, pos1 - prePos1) : version1.substr(prePos1, version1.size() - prePos1); sv2 = pos2 != string::npos ? version2.substr(prePos2, pos2 - prePos2) : version2.substr(prePos2, version2.size() - prePos2); prePos1 = pos1 == string::npos ? string::npos : pos1 + 1; prePos2 = pos2 == string::npos ? string::npos : pos2 + 1; int v1 = stoi(sv1); int v2 = stoi(sv2); if (v1 == v2) { continue; } return v1 > v2 ? 1 : -1; } while (prePos1 != string::npos) { pos1 = version1.find(\".\", prePos1); string sv1 = pos1 != string::npos ? version1.substr(prePos1, pos1 - prePos1) : version1.substr(prePos1, version1.size() - prePos1); prePos1 = pos1 == string::npos ? string::npos : pos1 + 1; if (stoi(sv1) != 0) { return 1; } } while (prePos2 != string::npos) { pos2 = version2.find(\".\", prePos2); string sv2 = pos2 != string::npos ? version2.substr(prePos2, pos2 - prePos2) : version2.substr(prePos2, version2.size() - prePos2); prePos2 = pos2 == string::npos ? string::npos : pos2 + 1; if (stoi(sv2) != 0) { return -1; } } return 0; } }; Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-25 18:31:45 "},"docs/leetcode/101-200/166.html":{"url":"docs/leetcode/101-200/166.html","title":"166.分数到小数","keywords":"","body":"分数到小数(中等)解法一分数到小数(中等) 给定两个整数，分别表示分数的分子 numerator 和分母 denominator，以 字符串形式返回小数 。 如果小数部分为循环小数，则将循环的部分括在括号内。 如果存在多个答案，只需返回 任意一个 。 对于所有给定的输入，保证 答案字符串的长度小于 10^4 。 示例 1： 输入：numerator = 1, denominator = 2 输出：\"0.5\" 示例 2： 输入：numerator = 2, denominator = 1 输出：\"2\" 示例 3： 输入：numerator = 2, denominator = 3 输出：\"0.(6)\" 示例 4： 输入：numerator = 4, denominator = 333 输出：\"0.(012)\" 示例 5： 输入：numerator = 1, denominator = 5 输出：\"0.2\" 提示： -2^31 denominator != 0 解法一 模拟 模拟数学计算, 逐位计算整除数和余数, 特别需要注意符号和小数循环 小数部分用一个数组和哈希表来记录有没有重复过整除数和余数, 如果存在说明进入到了小数循环, 需要中断并加上小括号. class Solution { public: string fractionToDecimal(int numerator, int denominator) { if (!numerator) { return \"0\"; } bool symbol = true; long nt = numerator; long dt = denominator; if (nt > remTab(10); for (rem = (rem % dt) * 10; rem && ans.size() 优化一下代码 class Solution { public: string fractionToDecimal(int numerator, int denominator) { if (!numerator) { return \"0\"; } string ans; long nt = numerator; long dt = denominator; long num = nt / dt; bool symbol = true; nt = nt > remTab(10); for (rem = (rem % dt) * 10; rem && ans.size() 二次优化 发现只需要在哈希表里面记录余数和下标就可以了, 不需要在多记录除的商, 余数如果相等, 那就是循环 class Solution { public: string fractionToDecimal(int numerator, int denominator) { if (!numerator) { return \"0\"; } string ans; long nt = abs(numerator); long dt = abs(denominator); if (numerator remTab; for (rem = (rem % dt) * 10; rem && ans.size() Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-25 18:31:45 "},"docs/leetcode/101-200/168.html":{"url":"docs/leetcode/101-200/168.html","title":"168.Excel表列名称","keywords":"","body":"Excel表列名称(简单)解法一Excel表列名称(简单) 给你一个整数 columnNumber ，返回它在 Excel 表中相对应的列名称。 例如： A -> 1 B -> 2 C -> 3 ... Z -> 26 AA -> 27 AB -> 28 ... 示例 1： 输入：columnNumber = 1 输出：\"A\" 示例 2： 输入：columnNumber = 28 输出：\"AB\" 示例 3： 输入：columnNumber = 701 输出：\"ZY\" 示例 4： 输入：columnNumber = 2147483647 输出：\"FXSHRXW\" 提示： 1 解法一 其实就是把十进制转换为26进制 需要注意的是在26的整数倍时要防止最高位多出来一个数。 class Solution { public: string convertToTitle(int columnNumber) { string ans; while(columnNumber) { ans.push_back(((columnNumber - 1) % 26) + 'A'); columnNumber = ans.back() == 'Z' ? columnNumber / 26 - 1 : columnNumber / 26; } reverse(ans.begin(), ans.end()); return ans; } }; Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-25 18:31:45 "},"docs/leetcode/101-200/171.html":{"url":"docs/leetcode/101-200/171.html","title":"171.Excel表列序号","keywords":"","body":"Excel表列序号(简单)解法一Excel表列序号(简单) 给你一个字符串 columnTitle ，表示 Excel 表格中的列名称。返回该列名称对应的列序号。 例如， A -> 1 B -> 2 C -> 3 ... Z -> 26 AA -> 27 AB -> 28 ... 示例 1: 输入: columnTitle = \"A\" 输出: 1 示例 2: 输入: columnTitle = \"AB\" 输出: 28 示例 3: 输入: columnTitle = \"ZY\" 输出: 701 示例 4: 输入: columnTitle = \"FXSHRXW\" 输出: 2147483647 提示： 1 columnTitle 仅由大写英文组成 columnTitle 在范围 [\"A\", \"FXSHRXW\"] 内 解法一 相当于进制转换，转换成26进制。 字母从左往右，是按照从高位到低位的顺序，所以每次都把前面的数乘以26再加上下一位的数字。 class Solution { public: int titleToNumber(string columnTitle) { int ans = 0; for (const auto &ch : columnTitle) { ans = ans * 26 + (ch - 64); } return ans; } }; Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-25 18:31:45 "},"docs/leetcode/101-200/172.html":{"url":"docs/leetcode/101-200/172.html","title":"172.组合总和","keywords":"","body":"阶乘后的零(简单)解法一阶乘后的零(简单) 给定一个整数 n，返回 n! 结果尾数中零的数量。 示例 1: 输入: 3 输出: 0 解释: 3! = 6, 尾数中没有零。 示例 2: 输入: 5 输出: 1 解释: 5! = 120, 尾数中有 1 个零. 说明: 你算法的时间复杂度应为 O(log n) 。 解法一 本来这题是我硬看出来的规律, n每过5个数, n的阶乘就会多一个0, 而且每过一个5的x次方, 就额外多(x - 1)个零 后面看了题解也有这个方法的, 并且解释的也很清楚 首先末尾有多少个 0 ，只需要给当前数乘以一个 10 就可以加一个 0。 再具体对于 5!，也就是 5 4 3 2 1 = 120，我们发现结果会有一个 0，原因就是 2 和 5 相乘构成了一个 10。而对于 10 的话，其实也只有 2 * 5 可以构成，所以我们只需要找有多少对 2/5。 我们把每个乘数再稍微分解下，看一个例子。 11! = 11 10 9 8 7 6 5 4 3 2 1 = 11 (2 5) 9 (4 2) 7 (3 2) (1 5) (2 2) 3 (1 2) 1 对于含有 2 的因子的话是 1 2, 2 2, 3 2, 4 2 ... 对于含有 5 的因子的话是 1 5, 2 5... 含有 2 的因子每两个出现一次，含有 5 的因子每 5 个出现一次，所有 2 出现的个数远远多于 5，换言之找到一个 5，一定能找到一个 2 与之配对。所以我们只需要找有多少个 5。 直接的，我们只需要判断每个累乘的数有多少个 5 的因子即可。 因为每隔 5 个数出现一个 5，所以计算出现了多少个 5，我们只需要用 n/5 就可以算出来。 但还没有结束，继续分析。 ... (1 5) ... (1 5 5) ... (2 5 5) ... (3 5 5) ... n 每隔 25 个数字，出现的是两个 5，所以除了每隔 5 个数算作一个 5，每隔 25 个数，还需要多算一个 5。 也就是我们需要再加上 n / 25 个 5。 同理我们还会发现每隔 5 5 5 = 125 个数字，会出现 3 个 5，所以我们还需要再加上 n / 125 。 综上，规律就是每隔 5 个数，出现一个 5，每隔 25 个数，出现 2 个 5，每隔 125 个数，出现 3 个 5... 以此类推。 最终 5 的个数就是 n / 5 + n / 25 + n / 125 ... class Solution { public: int trailingZeroes(int n) { int count = 0; while (n) { n /= 5; count += n; } return count; } }; Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-25 18:31:45 "},"docs/leetcode/101-200/173.html":{"url":"docs/leetcode/101-200/173.html","title":"173.二叉搜索树迭代器","keywords":"","body":"二叉搜索树迭代器(中等)解法一解法二二叉搜索树迭代器(中等) 实现一个二叉搜索树迭代器类 BSTIterator ，表示一个按中序遍历二叉搜索树（BST）的迭代器： BSTIterator(TreeNode root) 初始化 BSTIterator 类的一个对象。BST 的根节点 root 会作为构造函数的一部分给出。指针应初始化为一个不存在于 BST 中的数字，且该数字小于 BST 中的任何元素。 boolean hasNext() 如果向指针右侧遍历存在数字，则返回 true ；否则返回 false 。 int next() 将指针向右移动，然后返回指针处的数字。 注意，指针初始化为一个不存在于 BST 中的数字，所以对 next() 的首次调用将返回 BST 中的最小元素。 你可以假设 next() 调用总是有效的，也就是说，当调用 next() 时，BST 的中序遍历中至少存在一个下一个数字。 示例： 输入 [\"BSTIterator\", \"next\", \"next\", \"hasNext\", \"next\", \"hasNext\", \"next\", \"hasNext\", \"next\", \"hasNext\"] [[[7, 3, 15, null, null, 9, 20]], [], [], [], [], [], [], [], [], []] 输出 [null, 3, 7, true, 9, true, 15, true, 20, false] 解释 BSTIterator bSTIterator = new BSTIterator([7, 3, 15, null, null, 9, 20]); bSTIterator.next(); // 返回 3 bSTIterator.next(); // 返回 7 bSTIterator.hasNext(); // 返回 True bSTIterator.next(); // 返回 9 bSTIterator.hasNext(); // 返回 True bSTIterator.next(); // 返回 15 bSTIterator.hasNext(); // 返回 True bSTIterator.next(); // 返回 20 bSTIterator.hasNext(); // 返回 False 提示： 树中节点的数目在范围 [1, 105] 内 0 最多调用 10^5 次 hasNext 和 next 操作 进阶： 你可以设计一个满足下述条件的解决方案吗？next() 和 hasNext() 操作均摊时间复杂度为 O(1) ，并使用 O(h) 内存。其中 h 是树的高度。 解法一 看到这一题我首先想到的是模拟, 用vector按照中序保存节点, 再用一个vector的迭代器记录当前中序迭代器的迭代器位置 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class BSTIterator { public: BSTIterator(TreeNode* root) { bst(root); currIt_ = bstVec_.begin(); } void bst(TreeNode *node) { if (node == nullptr) { return ; } bst(node->left); bstVec_.push_back(node); bst(node->right); } int next() { return (*currIt_++)->val; } bool hasNext() { return currIt_ != bstVec_.end(); } private: vector::iterator currIt_; vector bstVec_; }; /** * Your BSTIterator object will be instantiated and called as such: * BSTIterator* obj = new BSTIterator(root); * int param_1 = obj->next(); * bool param_2 = obj->hasNext(); */ 解法二 因为只需要返回结果, 不需要返回节点, 所以改进后只在vector中保存val, 这样就可以省去不少空间, 同时也能提升效率 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class BSTIterator { public: BSTIterator(TreeNode* root) { bst(root); currIt_ = bstVec_.begin(); } void bst(TreeNode *node) { if (node == nullptr) { return ; } bst(node->left); bstVec_.push_back(node->val); bst(node->right); } int next() { return *currIt_++; } bool hasNext() { return currIt_ != bstVec_.end(); } private: vector::iterator currIt_; vector bstVec_; }; /** * Your BSTIterator object will be instantiated and called as such: * BSTIterator* obj = new BSTIterator(root); * int param_1 = obj->next(); * bool param_2 = obj->hasNext(); */ Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-25 18:31:45 "},"docs/leetcode/101-200/192.html":{"url":"docs/leetcode/101-200/192.html","title":"192.统计词频","keywords":"","body":"统计词频(中等)解法一统计词频(中等) 写一个 bash 脚本以统计一个文本文件 words.txt 中每个单词出现的频率。 为了简单起见，你可以假设： words.txt 只包括小写字母和 ' ' 。 每个单词只由小写字母组成。 单词间由一个或多个空格字符分隔。 示例: 假设 words.txt 内容如下： the day is sunny the the the sunny is is 你的脚本应当输出（以词频降序排列）： the 4 is 3 sunny 2 day 1 说明: 不要担心词频相同的单词的排序问题，每个单词出现的频率都是唯一的。 你可以使用一行 Unix pipes 实现吗？ 解法一 按照示例的文本来做一下步骤解析 cat words.txt 把文本内容输出到标准输出并往后传递 awk -F ' ' '{ for (i=1; i 用来按照空格分割单词, 分割后如下 the day is sunny the the the sunny is is sort | uniq -c uniq可以对文本进行计数, 但只能对相邻的相同内容文本才能计数为多次, 所以前面需要 sort 排一下序, 使相同的文本都相邻 最后效果如下 1 day 3 is 2 sunny 4 the 最后我们需要按照词频倒排, 并且要把数字放在单词后面 sort -nr 按照数字排序, 并倒排awk -F ' ' '{print $2, $1}' 这一步为了把数字放到单词的后面 the 4 is 3 sunny 2 day 1 题解代码 # Read from the file words.txt and output the word frequency list to stdout. cat words.txt | awk -F ' ' '{ for (i=1; i Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-25 18:31:45 "},"docs/leetcode/101-200/193.html":{"url":"docs/leetcode/101-200/193.html","title":"193.有效电话号码","keywords":"","body":"有效电话号码(简单)解法一解法二有效电话号码(简单) 给定一个包含电话号码列表（一行一个电话号码）的文本文件 file.txt，写一个单行 bash 脚本输出所有有效的电话号码。 你可以假设一个有效的电话号码必须满足以下两种格式： (xxx) xxx-xxxx 或 xxx-xxx-xxxx。（x 表示一个数字） 你也可以假设每行前后没有多余的空格字符。 示例： 假设 file.txt 内容如下： 987-123-4567 123 456 7890 (123) 456-7890 你的脚本应当输出下列有效的电话号码： 987-123-4567 (123) 456-7890 解法一 这个题主要是熟悉正则表达式 主要分为两部分 前4位是 xxx- 或 前6位是 (xxx)空格 后面8位是 xxx-xxxx 格式 这样就可以过滤出想要的结果 # Read from the file file.txt and output all valid phone numbers to stdout. sed -n -r \"/^([0-9]{3}-|\\([0-9]{3}\\) )[0-9]{3}-[0-9]{4}$/p\" ./file.txt 解法二 正则还是那个正则, 只是使用 grep 命令, 这并没有多大影响 # Read from the file file.txt and output all valid phone numbers to stdout. grep -E \"^([0-9]{3}-|\\([0-9]{3}\\) )[0-9]{3}-[0-9]{4}$\" ./file.txt 同样还可以使用其他文本处理的命令(awk), 只要支持正则表达式即可 Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-25 18:31:45 "},"docs/leetcode/101-200/195.html":{"url":"docs/leetcode/101-200/195.html","title":"195.第十行","keywords":"","body":"第十行(简单)解法一解法二解法三第十行(简单) 给定一个文本文件 file.txt，请只打印这个文件中的第十行。 示例: 假设 file.txt 有如下内容： Line 1 Line 2 Line 3 Line 4 Line 5 Line 6 Line 7 Line 8 Line 9 Line 10 你的脚本应当显示第十行： Line 10 说明: 如果文件少于十行，你应当输出什么？ 至少有三种不同的解法，请尝试尽可能多的方法来解题。 解法一 # Read from the file file.txt and output the tenth line to stdout. cat ./file.txt | awk \"NR == 10\" 解法二 # Read from the file file.txt and output the tenth line to stdout. head -n 10 ./file.txt | awk \"NR == 10\" 解法三 # Read from the file file.txt and output the tenth line to stdout. awk \"NR == 10\" ./file.txt Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-25 18:31:45 "},"docs/leetcode/201-300/":{"url":"docs/leetcode/201-300/","title":"201~300","keywords":"","body":"题目目录题目目录 Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-25 18:31:45 "},"docs/leetcode/201-300/205.html":{"url":"docs/leetcode/201-300/205.html","title":"205.同构字符串","keywords":"","body":"同构字符串(简单)解法一同构字符串(简单) 给定两个字符串 s 和 t，判断它们是否是同构的。 如果 s 中的字符可以按某种映射关系替换得到 t ，那么这两个字符串是同构的。 每个出现的字符都应当映射到另一个字符，同时不改变字符的顺序。不同字符不能映射到同一个字符上，相同字符只能映射到同一个字符上，字符可以映射到自己本身。 示例 1: 输入：s = \"egg\", t = \"add\" 输出：true 示例 2： 输入：s = \"foo\", t = \"bar\" 输出：false 示例 3： 输入：s = \"paper\", t = \"title\" 输出：true 提示： 可以假设 s 和 t 长度相同。 解法一 使用双表, 表一用来做s到t的映射, 表二用来检查t中的字符是否被s中的字符映射过. class Solution { public: bool isIsomorphic(string s, string t) { map tab1; map tab2; for (int i = 0; i second != t[i]) { return false; } } } return true; } }; 优化 s和t都为字符, 所以可以定义一个有效字符的取值范围数组, 作为一个映射表. 表二只是查看t的字符有没有被s中的字符映射过, 所以用一个bool数组作为映射表即可. class Solution { public: bool isIsomorphic(string s, string t) { char t1[128] = { 0 }; bool t2[128] = { false }; for (int i = 0; i Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-25 18:31:45 "},"docs/leetcode/201-300/231.html":{"url":"docs/leetcode/201-300/231.html","title":"231.2的幂","keywords":"","body":"2的幂(简单)解法一解法二解法三2的幂(简单) 给你一个整数 n，请你判断该整数是否是 2 的幂次方。如果是，返回 true ；否则，返回 false 。 如果存在一个整数 x 使得 n == 2^x ，则认为 n 是 2 的幂次方。 示例 1： 输入：n = 1 输出：true 解释：20 = 1 示例 2： 输入：n = 16 输出：true 解释：24 = 16 示例 3： 输入：n = 3 输出：false 示例 4： 输入：n = 4 输出：true 示例 5： 输入：n = 5 输出：false 提示： -231 解法一 首先想到的是逐一比较2的所有幂, 这样也只比较30次 class Solution { public: bool isPowerOfTwo(int n) { int x = 1; while (x >= 0) { if (n == x) { return true; } x 解法二 如果是2的幂次方, 那么这个数的二进制一定只有一个1, 所以只需要计算这个数1的个数就可以求出是不是2的幂次方了 0100 0100 - 1 0011 & 0000 一个2的幂次方的数, 与它减一的数按位与, 一定是等于0的 代码 class Solution { public: bool isPowerOfTwo(int n) { return n > 0 ? (n & (n - 1)) == 0 : false; } }; 解法三 看了题解后, 还有其它的解法 既然是2的幂次方, 那么这个数只有是最大的2的幂次方的约数才是2的幂次方数 class Solution { public: bool isPowerOfTwo(int n) { return n > 0 && big % n == 0; } private: const int big = 1 Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-25 18:31:45 "},"docs/leetcode/201-300/233.html":{"url":"docs/leetcode/201-300/233.html","title":"233.数字1的个数","keywords":"","body":"数字1个数(困难)解法一解法二数字1个数(困难) 给定一个整数 n，计算所有小于等于 n 的非负整数中数字 1 出现的个数。 示例 1： 输入：n = 13 输出：6 示例 2： 输入：n = 0 输出：0 提示： 0 解法一 暴力法(超时) 逐个数字寻找1的个数 class Solution { public: int countDigitOne(int n) { int ans = 0; for (int i = 1; i 解法二 数学方法 题解 class Solution { public: int countDigitOne(int n) { int ans = 0; long long mulk = 1; for (int k = 0; n >= mulk; ++k) { ans += (n / (mulk * 10)) * mulk + min(max(n % (mulk * 10) - mulk + 1, 0LL), mulk); mulk *= 10; } return ans; } }; Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-25 18:31:45 "},"docs/leetcode/201-300/274.html":{"url":"docs/leetcode/201-300/274.html","title":"274.H指数","keywords":"","body":"H指数(中等)解法一解法二解法三H指数(中等) 给定一位研究者论文被引用次数的数组（被引用次数是非负整数）。编写一个方法，计算出研究者的 h 指数。 h 指数的定义：h 代表“高引用次数”（high citations），一名科研人员的 h 指数是指他（她）的 （N 篇论文中）总共有 h 篇论文分别被引用了至少 h 次。且其余的 N - h 篇论文每篇被引用次数 不超过 h 次。 例如：某人的 h 指数是 20，这表示他已发表的论文中，每篇被引用了至少 20 次的论文总共有 20 篇。 示例： 输入：citations = [3,0,6,1,5] 输出：3 解释：给定数组表示研究者总共有 5 篇论文，每篇论文相应的被引用了 3, 0, 6, 1, 5 次。 由于研究者有 3 篇论文每篇 至少 被引用了 3 次，其余两篇论文每篇被引用 不多于 3 次，所以她的 h 指数是 3。 提示： 如果 h 有多种可能的值，h 指数是其中最大的那个。 解法一 二分查找 对于一个有序的数组 arr, 找到一个下标 index, 且有 h = arr.size() - index, 保证 arr[index] 的值大于等于 h, 且 index 之前的数字都不能大于 h; 根据这样的条件就可以使用二分查找的方法一步步找到符合要求的 h 值 class Solution { public: int hIndex(vector& citations) { if (citations.empty()) { return 0; } vector ct = citations; sort(ct.begin(), ct.end()); int size = ct.size(); int l = 0; int r = ct.size() - 1; int hlen = 0; int mid = 0; while (l = hlen) { // 符合 if (mid > 0 && ct[mid - 1] > hlen) { r = mid - 1; } else { return hlen; } } else { l = mid + 1; } } if (ct[mid] == 0) { return 0; } return hlen; } }; 解法二 题解 首先我们可以将初始的 H 指数 h 设为 0，然后将引用次数排序，并且对排序后的数组从大到小遍历。 根据 H 指数的定义，如果当前 H 指数为 h 并且在遍历过程中找到当前值 citations[i] > h，则说明我们找到了一篇被引用了至少 h + 1 次的论文，所以将现有的 h 值加 1。继续遍历直到 h 无法继续增大。最后返回 h 作为最终答案。 class Solution { public: int hIndex(vector& citations) { sort(citations.begin(), citations.end()); int h = 0, i = citations.size() - 1; while (i >= 0 && citations[i] > h) { h++; i--; } return h; } }; 解法三 题解 计数排序 根据定义，我们可以发现 H 指数不可能大于总的论文发表数，所以对于引用次数超过论文发表数的情况，我们可以将其按照总的论文发表数来计算即可。这样我们可以限制参与排序的数的大小为 [0,n]（其中 n 为总的论文发表数），使得计数排序的时间复杂度降低到 O(n)。 最后我们可以从后向前遍历数组 counter，对于每个 0≤ i ≤ n，在数组 counter 中得到大于或等于当前引用次数 i 的总论文数。当我们找到一个 H 指数时跳出循环，并返回结果。 class Solution { public: int hIndex(vector& citations) { int n = citations.size(), tot = 0; vector counter(n + 1); for (int i = 0; i = n) { counter[n]++; } else { counter[citations[i]]++; } } for (int i = n; i >= 0; i--) { tot += counter[i]; if (tot >= i) { return i; } } return 0; } }; Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-25 18:31:45 "},"docs/leetcode/201-300/275.html":{"url":"docs/leetcode/201-300/275.html","title":"275.H指数2","keywords":"","body":"H指数2(中等)解法一H指数2(中等) 给定一位研究者论文被引用次数的数组（被引用次数是非负整数），数组已经按照 升序排列 。编写一个方法，计算出研究者的 h 指数。 h 指数的定义: “h 代表“高引用次数”（high citations），一名科研人员的 h 指数是指他（她）的 （N 篇论文中）总共有 h 篇论文分别被引用了至少 h 次。（其余的 N - h 篇论文每篇被引用次数不多于 h 次。）\" 示例: 输入: citations = [0,1,3,5,6] 输出: 3 解释: 给定数组表示研究者总共有 5 篇论文，每篇论文相应的被引用了 0, 1, 3, 5, 6 次。 由于研究者有 3 篇论文每篇至少被引用了 3 次，其余两篇论文每篇被引用不多于 3 次，所以她的 h 指数是 3。 说明: 如果 h 有多有种可能的值 ，h 指数是其中最大的那个。 进阶： 这是 H 指数 的延伸题目，本题中的 citations 数组是保证有序的。 你可以优化你的算法到对数时间复杂度吗？ 解法一 二分查找 与H指数解法相似，citations 本身已有序，少了排序的步骤。 看了题解后，优化了以下H指数的二分查找方法，更加的简洁一些。 class Solution { public: int hIndex(vector& citations) { int l = 0; int r = citations.size() - 1; while (l = citations.size() - mid) { r = mid - 1; } else { l = mid + 1; } } return citations.size() - l; } }; Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-25 18:31:45 "},"docs/leetcode/201-300/278.html":{"url":"docs/leetcode/201-300/278.html","title":"278.第一个错误的版本","keywords":"","body":"第一个错误的版本(简单)解法一解法二解法三第一个错误的版本(简单) 你是产品经理，目前正在带领一个团队开发新的产品。不幸的是，你的产品的最新版本没有通过质量检测。由于每个版本都是基于之前的版本开发的，所以错误的版本之后的所有版本都是错的。 假设你有 n 个版本 [1, 2, ..., n]，你想找出导致之后所有版本出错的第一个错误的版本。 你可以通过调用 bool isBadVersion(version) 接口来判断版本号 version 是否在单元测试中出错。实现一个函数来查找第一个错误的版本。你应该尽量减少对调用 API 的次数。 示例 1： 输入：n = 5, bad = 4 输出：4 解释： 调用 isBadVersion(3) -> false 调用 isBadVersion(5) -> true 调用 isBadVersion(4) -> true 所以，4 是第一个错误的版本。 示例 2： 输入：n = 1, bad = 1 输出：1 提示： 1 解法一 暴力法, 超时 逐个寻找错误的版本 // The API isBadVersion is defined for you. // bool isBadVersion(int version); class Solution { public: int firstBadVersion(int n) { for (int i = 1; i 解法二 设计步长, 步长(step)为n的开方, 这样最多遍历 2 * step 次, // The API isBadVersion is defined for you. // bool isBadVersion(int version); class Solution { public: int firstBadVersion(int n) { int step = sqrt(n); int i = n; int size = n - step; for (; i > 0; i -= step) { if (!isBadVersion(i)) { break; } } i = i 解法三 二分法 正确的都在左边, 错误的都在右边, 可以用二分查找快速定位到临界点. // The API isBadVersion is defined for you. // bool isBadVersion(int version); class Solution { public: int firstBadVersion(int n) { long l = 1; long r = n; while (l Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-25 18:31:45 "},"docs/leetcode/201-300/295.html":{"url":"docs/leetcode/201-300/295.html","title":"295.数据流的中位数","keywords":"","body":"数据流的中位数(困难)解法一数据流的中位数(困难) 中位数是有序列表中间的数。如果列表长度是偶数，中位数则是中间两个数的平均值。 例如， [2,3,4] 的中位数是 3 [2,3] 的中位数是 (2 + 3) / 2 = 2.5 设计一个支持以下两种操作的数据结构： void addNum(int num) - 从数据流中添加一个整数到数据结构中。 double findMedian() - 返回目前所有元素的中位数。 示例： addNum(1) addNum(2) findMedian() -> 1.5 addNum(3) findMedian() -> 2 进阶: 如果数据流中所有整数都在 0 到 100 范围内，你将如何优化你的算法？ 如果数据流中 99% 的整数都在 0 到 100 范围内，你将如何优化你的算法？ 解法一 参考了题解的思路，做两个队列或者集合(numsMin, numsMax)，一个用于存放中位数之前的数，另一个存放中位数之后的数； 需要注意的是，要保证两个集合的元素数量最多差1，来保证方便取到中位数 如果当前数个数之和为偶数，那么就取numsMin 的最大值和numsMax的最小值，取平均数为中位数 如果当前数个数之和为奇数，那么就取numsMin的最大值为中位数。 class MedianFinder { public: /** initialize your data structure here. */ MedianFinder() { } void addNum(int num) { if (_numsMin.empty()) { _numsMin.insert(num); return ; } if (num _numsMin.size()) { _numsMin.insert(*_numsMax.begin()); _numsMax.erase(_numsMax.begin()); } } } double findMedian() { if (_numsMin.size() != _numsMax.size()) { return *_numsMin.begin(); } else { return ((double)(*_numsMin.begin()) + *_numsMax.begin()) / 2; } } private: multiset > _numsMin; multiset > _numsMax; }; /** * Your MedianFinder object will be instantiated and called as such: * MedianFinder* obj = new MedianFinder(); * obj->addNum(num); * double param_2 = obj->findMedian(); */ Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-27 18:55:00 "},"docs/leetcode/301-400/":{"url":"docs/leetcode/301-400/","title":"301~400","keywords":"","body":"题目目录题目目录 Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-25 18:31:45 "},"docs/leetcode/301-400/342.html":{"url":"docs/leetcode/301-400/342.html","title":"342.4的幂","keywords":"","body":"4的幂(简单)解法一解法二解法三4的幂(简单) 给定一个整数，写一个函数来判断它是否是 4 的幂次方。如果是，返回 true ；否则，返回 false 。 整数 n 是 4 的幂次方需满足：存在整数 x 使得 n == 4x 示例 1： 输入：n = 16 输出：true 示例 2： 输入：n = 5 输出：false 示例 3： 输入：n = 1 输出：true 提示： -2^31 进阶： 你能不使用循环或者递归来完成本题吗？ 解法一 比较笨的一种方法，用求2的幂的方法，来筛选出2的幂，然后再检查二进制1的位置 4的幂的二进制1的位置，一定是在偶数上，所以检查的时候从0开始，每次递增2位 class Solution { public: bool isPowerOfFour(int n) { if (n 解法二 因为4的幂的二进制1的位置一定在偶数位上，又知道筛选2的幂的方法 所以可以直接找一个二进制偶数位全是0或1的数，来和n按位与 二进制偶数为1的数 1010 1010 1010 1010 1010 1010 1010 1010 转换成16进制 0xaaaaaaaa class Solution { public: bool isPowerOfFour(int n) { return n > 0 && (n & (n - 1)) == 0 && (n & 0xaaaaaaaa) == 0; } }; 解法三 4的幂对3取模一定为1，而2的幂对3取模一定为2，所以在筛选出为2的幂时，再对3取模就可以求出结果 class Solution { public: bool isPowerOfFour(int n) { return n > 0 && (n & (n - 1)) == 0 && n % 3 == 1; } }; Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-25 18:31:45 "},"docs/leetcode/301-400/345.html":{"url":"docs/leetcode/301-400/345.html","title":"345.反转字符串中的元音字母","keywords":"","body":"反转字符串中的元音字母(简单)解法一反转字符串中的元音字母(简单) 编写一个函数，以字符串作为输入，反转该字符串中的元音字母。 示例 1： 输入：\"hello\" 输出：\"holle\" 示例 2： 输入：\"leetcode\" 输出：\"leotcede\" 提示： 元音字母不包含字母 \"y\" 。 解法一 双指针，左右各一个指针，遇到元音字母就进行互换。 class Solution { public: string reverseVowels(string s) { int n = s.size(); int left = 0; int right = n - 1; unordered_set tab { 'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U' }; while (left 优化 把hash表换成一个数组，可以提升效率 class Solution { public: string reverseVowels(string s) { int n = s.size(); int left = 0; int right = n - 1; bool tab[127]; memset(tab, 0x00, sizeof(tab)); string vowel(\"aeiouAEIOU\"); for (const auto &ch : vowel) { tab[ch] = true; } while (left Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-25 18:31:45 "},"docs/leetcode/401-500/":{"url":"docs/leetcode/401-500/","title":"401~500","keywords":"","body":"题目目录题目目录 Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-25 18:31:45 "},"docs/leetcode/401-500/401.html":{"url":"docs/leetcode/401-500/401.html","title":"401.二进制手表","keywords":"","body":"二进制手表(简单)解法一解法二二进制手表(简单) 二进制手表顶部有 4 个 LED 代表 小时（0-11），底部的 6 个 LED 代表 分钟（0-59）。每个 LED 代表一个 0 或 1，最低位在右侧。 例如，下面的二进制手表读取 \"3:25\" 。 给你一个整数 turnedOn ，表示当前亮着的 LED 的数量，返回二进制手表可以表示的所有可能时间。你可以 按任意顺序 返回答案。 小时不会以零开头： 例如，\"01:00\" 是无效的时间，正确的写法应该是 \"1:00\" 。 分钟必须由两位数组成，可能会以零开头： 例如，\"10:2\" 是无效的时间，正确的写法应该是 \"10:02\" 。 示例 1： 输入：turnedOn = 1 输出：[\"0:01\",\"0:02\",\"0:04\",\"0:08\",\"0:16\",\"0:32\",\"1:00\",\"2:00\",\"4:00\",\"8:00\"] 示例 2： 输入：turnedOn = 9 输出：[] 提示： 0 解法一 枚举小时和分钟的所有组合，然后计算二进制中1的个数，与 turneOn 相等的既为正确结果。 class Solution { public: vector readBinaryWatch(int turnedOn) { if (turnedOn > 8) { return {}; } if (turnedOn == 0) { vector { \"0:00\" }; } vector ans; for (int h = 0; h 解法二 一共10个灯，枚举所有灯的情况 2^10 ，高4位为小时，低6位为分钟； 然后过滤出有效的时间组合，并计算二进制1的个数与 turnenOn 相等的既为正确结果。 class Solution { public: vector readBinaryWatch(int turnedOn) { if (turnedOn > 8) { return {}; } if (turnedOn == 0) { vector { \"0:00\" }; } vector ans; for (int i = 0; i > 6; int m = i & 63; if (h Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-25 18:31:45 "},"docs/leetcode/401-500/413.html":{"url":"docs/leetcode/401-500/413.html","title":"413.等差数列划分","keywords":"","body":"等差数列划分(中等)解法一等差数列划分(中等) 如果一个数列 至少有三个元素 ，并且任意两个相邻元素之差相同，则称该数列为等差数列。 例如，[1,3,5,7,9]、[7,7,7,7] 和 [3,-1,-5,-9] 都是等差数列。给你一个整数数组 nums ，返回数组 nums 中所有为等差数组的 子数组 个数。 子数组 是数组中的一个连续序列。 示例 1： 输入：nums = [1,2,3,4] 输出：3 解释：nums 中有三个子等差数组：[1, 2, 3]、[2, 3, 4] 和 [1,2,3,4] 自身。 示例 2： 输入：nums = [1] 输出：0 提示： 1 -1000 解法一 这道题和1513题原理一样，只是这里把3个数归并成一个整体, 尽可能找最大的连续等差子数组，然后通过数学的方式计算出该子数组的包含所有的等差数列的个数，依次列推，直到遍历完整个数组。 class Solution { public: int numberOfArithmeticSlices(vector& nums) { if(nums.size() 优化代码 class Solution { public: int numberOfArithmeticSlices(vector& nums) { int ans = 0; int cnt = 0; for (int i = 2; i Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-25 18:31:45 "},"docs/leetcode/401-500/443.html":{"url":"docs/leetcode/401-500/443.html","title":"443.压缩字符串","keywords":"","body":"压缩字符串(中等)解法一压缩字符串(中等) 给你一个字符数组 chars ，请使用下述算法压缩： 从一个空字符串 s 开始。对于 chars 中的每组 连续重复字符 ： 如果这一组长度为 1 ，则将字符追加到 s 中。 否则，需要向 s 追加字符，后跟这一组的长度。 压缩后得到的字符串 s 不应该直接返回 ，需要转储到字符数组 chars 中。需要注意的是，如果组长度为 10 或 10 以上，则在 chars 数组中会被拆分为多个字符。 请在 修改完输入数组后 ，返回该数组的新长度。 你必须设计并实现一个只使用常量额外空间的算法来解决此问题。 示例 1： 输入：chars = [\"a\",\"a\",\"b\",\"b\",\"c\",\"c\",\"c\"] 输出：返回 6 ，输入数组的前 6 个字符应该是：[\"a\",\"2\",\"b\",\"2\",\"c\",\"3\"] 解释： \"aa\" 被 \"a2\" 替代。\"bb\" 被 \"b2\" 替代。\"ccc\" 被 \"c3\" 替代。 示例 2： 输入：chars = [\"a\"] 输出：返回 1 ，输入数组的前 1 个字符应该是：[\"a\"] 解释： 没有任何字符串被替代。 示例 3： 输入：chars = [\"a\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\"] 输出：返回 4 ，输入数组的前 4 个字符应该是：[\"a\",\"b\",\"1\",\"2\"]。 解释： 由于字符 \"a\" 不重复，所以不会被压缩。\"bbbbbbbbbbbb\" 被 “b12” 替代。 注意每个数字在数组中都有它自己的位置。 提示： 1 chars[i] 可以是小写英文字母、大写英文字母、数字或符号 解法一 模拟, count 计数连续相同的字符, 不相等时, 就压缩字符, 需要注意 count 为1时, 是不添加数字的. class Solution { public: int compress(vector& chars) { int start = 0; int n = chars.size(); int count = 0; int idx = 0; for (int i = 0; i 优化 不使用count, 直接用最后不一样的字符位置i 减去 start 位置, 既相同字符长度 class Solution { public: int compress(vector& chars) { int start = 0; int n = chars.size(); int idx = 0; for (int i = 0; i = n || chars[start] != chars[i]) { string countStr(to_string(i - start)); chars[idx++] = chars[start]; if (i - start != 1) { for (const auto &ch : countStr) { chars[idx++] = ch; } } start = i; } } return idx; } }; Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-25 18:31:45 "},"docs/leetcode/401-500/454.html":{"url":"docs/leetcode/401-500/454.html","title":"454.四数相加2","keywords":"","body":"四数相加2(中等)解法一四数相加2(中等) 给定四个包含整数的数组列表 A , B , C , D ,计算有多少个元组 (i, j, k, l) ，使得 A[i] + B[j] + C[k] + D[l] = 0。 为了使问题简单化，所有的 A, B, C, D 具有相同的长度 N，且 0 ≤ N ≤ 500 。所有整数的范围在 -2^28 到 2^28 - 1 之间，最终结果不会超过 2^31 - 1 。 例如: 输入: A = [ 1, 2] B = [-2,-1] C = [-1, 2] D = [ 0, 2] 输出: 2 解释: 两个元组如下: 1. (0, 0, 0, 1) -> A[0] + B[0] + C[0] + D[1] = 1 + (-2) + (-1) + 2 = 0 2. (1, 1, 0, 0) -> A[1] + B[1] + C[0] + D[0] = 2 + (-1) + (-1) + 0 = 0 解法一 使用一个表来记录两个数组元素排列组合的和，和每个和出现的次数。 然后再对另外两个数组元素排列组合进行求和，并在表中找其相反数，如果找到，说明存在四数相加等于0。 class Solution { public: int fourSumCount(vector& nums1, vector& nums2, vector& nums3, vector& nums4) { unordered_map tab1; for (auto &n1 : nums1) { for (auto &n2 : nums2) { tab1[n1 + n2]++; } } int ans = 0; for (auto &n3 : nums3) { for (auto &n4 : nums4) { if (tab1.find(0 - n3 - n4) != tab1.end()) { ans += tab1[0 - n3 - n4]; } } } return ans; } }; Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-25 18:31:45 "},"docs/leetcode/401-500/457.html":{"url":"docs/leetcode/401-500/457.html","title":"457.环形数组是否存在循环","keywords":"","body":"环形数组是否存在循环(中等)解法一解法二环形数组是否存在循环(中等) 存在一个不含 0 的 环形 数组 nums ，每个 nums[i] 都表示位于下标 i 的角色应该向前或向后移动的下标个数： 如果 nums[i] 是正数，向前（下标递增方向）移动 |nums[i]| 步 如果 nums[i] 是负数，向后（下标递减方向）移动 |nums[i]| 步因为数组是 环形 的，所以可以假设从最后一个元素向前移动一步会到达第一个元素，而第一个元素向后移动一步会到达最后一个元素。 数组中的 循环 由长度为 k 的下标序列 seq 标识： 遵循上述移动规则将导致一组重复下标序列 seq[0] -> seq[1] -> ... -> seq[k - 1] -> seq[0] -> ... 所有 nums[seq[j]] 应当不是 全正 就是 全负 k > 1 如果 nums 中存在循环，返回 true ；否则，返回 false 。 示例 1： 输入：nums = [2,-1,1,2,2] 输出：true 解释：存在循环，按下标 0 -> 2 -> 3 -> 0 。循环长度为 3 。 示例 2： 输入：nums = [-1,2] 输出：false 解释：按下标 1 -> 1 -> 1 ... 的运动无法构成循环，因为循环的长度为 1 。根据定义，循环的长度必须大于 1 。 示例 3: 输入：nums = [-2,1,-1,-2,-2] 输出：false 解释：按下标 1 -> 2 -> 1 -> ... 的运动无法构成循环，因为 nums[1] 是正数，而 nums[2] 是负数。 所有 nums[seq[j]] 应当不是全正就是全负。 提示： 1 -1000 nums[i] != 0 进阶： 你能设计一个时间复杂度为 O(n) 且额外空间复杂度为 O(1) 的算法吗？ 解法一 暴力法, 尝试以每个下标为起始点, 按步骤移动, 尝试寻找环, 用set记录过程中存在环, 防止陷入循环. class Solution { public: bool circularArrayLoop(vector& nums) { int step = 0; int n = nums.size(); int curr; int seqlen = 0; unordered_set tab; for (int i = 0; i 0 && curr 0) { break; } step = nums[step] + step; step = step > 0 ? step % n : (n + (step % n)) % n; ++seqlen; if (step == i) { if (seqlen > 1) { return true; } break; } if (tab.count(step) > 0) { break; } tab.insert(step); } } return false; } }; 解法二 双指针 题解 class Solution { public: bool circularArrayLoop(vector& nums) { int n = nums.size(); auto next = [&](int cur) { return ((cur + nums[cur]) % n + n) % n; }; for (int i = 0; i 0 && nums[slow] * nums[next(fast)] > 0) { if (slow == fast) { if (slow != next(slow)) { return true; } else { break; } } slow = next(slow); fast = next(next(fast)); } int add = i; while (nums[add] * nums[next(add)] > 0) { int tmp = add; add = next(add); nums[tmp] = 0; } } return false; } }; Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-25 18:31:45 "},"docs/leetcode/401-500/461.html":{"url":"docs/leetcode/401-500/461.html","title":"461.汉明距离","keywords":"","body":"汉明距离A(简单)解法一解法二解法三汉明距离A(简单) 两个整数之间的汉明距离指的是这两个数字对应二进制位不同的位置的数目。 给出两个整数 x 和 y，计算它们之间的汉明距离。 注意： 0 ≤ x, y . 示例: 输入: x = 1, y = 4 输出: 2 解释: 1 (0 0 0 1) 4 (0 1 0 0) ↑ ↑ 上面的箭头指出了对应二进制位不同的位置。 解法一 通过异或得到一个z, 通过计算 z 的二进制中 1 的个数, 就是汉明距离 class Solution { public: int hammingDistance(int x, int y) { int z = x ^ y; int count = 0; for (int i = 0; i >= 1; } return count; } }; 优化 当z=0 之后, 就不再继续循环, 减少一定的循环次数 class Solution { public: int hammingDistance(int x, int y) { int z = x ^ y; int count = 0; while (z) { count += z & 1; z >>= 1; } return count; } }; 解法二 因为只需要计算1的个数, 在解法一中会逐一计算到最高位的一个1, 中间可能会计算很多次0 z 与 z - 1 的按位且可以消除最低位的1, 这样循环下去, 循环的次数就是1的个数, 相对于方法一, 减少了中间0的个数的循环次数 01 0100 01 0100 - 1 = 01 0011 & 01 0000 01 0000 - 1 = 00 1111 & 00 0000 代码 class Solution { public: int hammingDistance(int x, int y) { int z = x ^ y; int count = 0; while (z) { z = z & (z - 1); ++count; } return count; } }; 解法三 O(1)的计算方法 class Solution { public: int hammingDistance(int x, int y) { int z = x ^ y; z = (z & 0x55555555) + ((z >> 1) & 0x55555555); z = (z & 0x33333333) + ((z >> 2) & 0x33333333); z = (z & 0x0f0f0f0f) + ((z >> 4) & 0x0f0f0f0f); z = (z & 0x00ff00ff) + ((z >> 8) & 0x00ff00ff); z = (z & 0x0000ffff) + ((z >> 16) & 0x0000ffff); return z; } }; Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-25 18:31:45 "},"docs/leetcode/401-500/474.html":{"url":"docs/leetcode/401-500/474.html","title":"474.一和零","keywords":"","body":"一和零(中等)解法一解法二一和零(中等) 给你一个二进制字符串数组 strs 和两个整数 m 和 n 。 请你找出并返回 strs 的最大子集的大小，该子集中 最多 有 m 个 0 和 n 个 1 。 如果 x 的所有元素也是 y 的元素，集合 x 是集合 y 的 子集 。 示例 1： 输入：strs = [\"10\", \"0001\", \"111001\", \"1\", \"0\"], m = 5, n = 3 输出：4 解释：最多有 5 个 0 和 3 个 1 的最大子集是 {\"10\",\"0001\",\"1\",\"0\"} ，因此答案是 4 。 其他满足题意但较小的子集包括 {\"0001\",\"1\"} 和 {\"10\",\"1\",\"0\"} 。{\"111001\"} 不满足题意，因为它含 4 个 1 ，大于 n 的值 3 。 示例 2： 输入：strs = [\"10\", \"0\", \"1\"], m = 1, n = 1 输出：2 解释：最大的子集是 {\"0\", \"1\"} ，所以答案是 2 。 提示： 1 1 strs[i] 仅由 '0' 和 '1' 组成 1 解法一 动态规划 使用三维数组存储字符串、0和1， 假设字符串长度为 i , 0的个数为 j , 1的个数为 k , 当字符串长度为0的时候，无论j和k是多少，其结果都是0 所以有 dp[0][j][k] = 0 在计算字符串的 0 和 1时, 当前已经可以存储的 0 和 1 的数量分别试试 j 和 k 当前字符串的 0 和 1 的数量分别是 zeros 和 ones 如果 j 的话, 说明不能把当前的字符串 0 和 1 给保存下来, 就需要跳过该字符串, 当前的结果长度就是: dp[i][j][k] = dp[i - 1][j][k] 否则的话, 可以跳过该字符串, 也可以选择该字符串 选择该字符串则有: dp[i][j][k] = dp[i - 1][j - 1][k - 1] + 1 结果长度为前一个的长度加1(因为增加了一个字符串) 未选择该字符串则有: dp[i][j][k] = dp[i - 1][j][k] 最终当i等于给定的字符串数组长度, j 和 k 分别为给定的 m 和 n 时, 就是最终的结果 class Solution { public: int findMaxForm(vector& strs, int m, int n) { vector > nums; for (int i = 0; i > > dp(strs.size() + 1, vector >(m + 1, vector(n + 1, 0))); dp[0][0][0] = 0; for (int i = 1; i 解法二 在解法一的基础上优化空间 当前的状态, 仅仅只依赖于前一个状态, 所以可以使用循环数组或者倒序计算 使用一个数组存储结果, 若正向计算的话, 会把后面计算需要使用的前一层的计算结果给覆盖掉(j - zeros 和 k - ones 使用的值会被覆盖), 而是用倒序计算的话, 不会影响. 初始化第0层的结果为0即可 这样就不用使用三维数组, 节省了大量的空间 class Solution { public: int findMaxForm(vector& strs, int m, int n) { vector > dp(m + 1, vector(n + 1, 0)); for (int i = 1; i = zeros; --j) { for (int k = n; k >= ones; --k) { dp[j][k] = max(dp[j][k], dp[j - zeros][k - ones] + 1); } } } return dp[m][n]; } private: pair getZeroAndOne(const string &str) { pair nums(0, 0); for (const auto &ch : str) { if (ch == '0') { ++nums.first; } else { ++nums.second; } } return nums; } }; Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-25 18:31:45 "},"docs/leetcode/401-500/477.html":{"url":"docs/leetcode/401-500/477.html","title":"477.汉明距离总和","keywords":"","body":"汉明距离总和(中等)解法一(失败)解法二解法三汉明距离总和(中等) 两个整数的 汉明距离 指的是这两个数字的二进制数对应位不同的数量。 给你一个整数数组 nums，请你计算并返回 nums 中任意两个数之间汉明距离的总和。 示例 1： 输入：nums = [4,14,2] 输出：6 解释：在二进制表示中，4 表示为 0100 ，14 表示为 1110 ，2表示为 0010 。（这样表示是为了体现后四位之间关系） 所以答案为： HammingDistance(4, 14) + HammingDistance(4, 2) + HammingDistance(14, 2) = 2 + 2 + 2 = 6 示例 2： 输入：nums = [4,14,4] 输出：4 提示： 1 0 解法一(失败) 暴力求解 class Solution { public: int totalHammingDistance(vector& nums) { // int count = 0; for (int i = 0; i 解法二 逐位求和 汉明距离是按位的差异来计算的, 同一个位的距离结果不会影响到其它位, 所以可以逐位计算, 这样的慢循环只需要循环32次就可以了(根据题目实际是可以填写成30) 同一个位里面统计 1 的个数 和 0 的个数, 他们排列组合就是该位的距离总和, 最后统合并所有的位结果, 就是最终结果 class Solution { public: int totalHammingDistance(vector& nums) { // int count = 0; int n = nums.size(); for (int i = 0; i > i) & 1; } // 1 的个数于 0的个数排列组合就是该位的不同的个数 count += c * (n - c); } return count; } }; 解法三 和解法二一样, 但先找出最大值, 通过最大值来确定最高位的 1 的位置, 来确定慢循环的次数, 这样可以减少循环次数 class Solution { public: int totalHammingDistance(vector& nums) { int bitcnt = 0; int count = 0; int n = nums.size(); int max = *max_element(nums.begin(), nums.end()); while (max) { ++bitcnt; max >>= 1; } for (int i = 0; i > i) & 1; } // 1 的个数于 0的个数排列组合就是该位的不同的个数 count += c * (n - c); } return count; } }; Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-25 18:31:45 "},"docs/leetcode/401-500/483.html":{"url":"docs/leetcode/401-500/483.html","title":"483.最小好进制","keywords":"","body":"最小好进制(困难)最小好进制(困难) 暂无 Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-25 18:31:45 "},"docs/leetcode/401-500/494.html":{"url":"docs/leetcode/401-500/494.html","title":"494.目标和","keywords":"","body":"目标和(中等)解法一解法二目标和(中等) 解法一 dfs 这道题很容易想到dfs，每个数字只添加正负号，寻找使其按照添加的正负号后的表达式计算结果等于目标值的组合个数 使用递归可以先把一种符号添加到最底，然后逐层退出更换符号，尝试每一种可能，所有的数计算的结果等于目标值时给计数结果加一 class Solution { public: int findTargetSumWays(vector& nums, int target) { int ans = 0; dfs(ans, nums, 0, target); return ans; } private: void dfs(int &ans, vector &nums, int idx, int target) { if (idx == nums.size()) { if (target == 0) { ++ans; } return ; } dfs(ans, nums, idx + 1, target + nums[idx]); dfs(ans, nums, idx + 1, target - nums[idx]); } }; 非递归 在提交的时候超时了 class Solution { public: int findTargetSumWays(vector& nums, int target) { int ans = 0; stack stk; stk.push({0, 0}); while (!stk.empty()) { Node node = stk.top(); stk.pop(); if (node.idx == nums.size()) { if (target == node.sum) { ++ans; } } else { stk.push({node.sum + nums[node.idx], node.idx + 1}); stk.push({node.sum - nums[node.idx], node.idx + 1}); } } return ans; } private: struct Node { int sum; int idx; }; }; 解法二 动态规划 假设所有添加负号的数的和为 neg，数组所有数的和为 sum，那么所有添加正号的数的和就是 sum - neg 因为所有的数都是非负整数，所以 neg >=0, sum - neg >= 0 目标值为 target 需要使 (sum - neg) - neg = target ==> sum - 2 * neg = target 既: neg = (sum - target) / 2 且 sum - target 要为非负偶数 所以只需要求出从 nums 中取出若干数字，使这些数值之和等于 neg的方案数 当这若干数字的个数为数组长度 n 时，那么这些数字之和就是最终需要的方案 假设元素之和等于j，选取 i 个元素 0 当 i 为 0 时，那么 j = 0 方案数就是你，否则其方案数都是 0 当 i > 0 时，如果 nums[i] > j 的话，就不能选取该值，其方案数于前一个相等 dp[i][j] = dp[i - 1][j] 当 i > 0 时，如果 nums[i] 的话，可以选择该值，也可以跳过该值，跳过该值的话就和前一个的方案数相等，否则的话，方案数就是 dp[i][j] = dp[i - 1][j - nums[i]] 了，既该总方案数 dp[i][j] = dp[i - 1][j] + dp[i - 1][j - nums[i]] 最终的 dp[n][neg] 便是最终的方案数 class Solution { public: int findTargetSumWays(vector& nums, int target) { int neg = 0; int n = nums.size(); for (int i = 0; i > dp(n + 1, vector(neg + 1, 0)); dp[0][0] = 1; for (int i = 1; i 优化 每一行的计算只和上一行的值有关，所以可以把二维数组变为以为，以倒序的方式计算。 class Solution { public: int findTargetSumWays(vector& nums, int target) { int neg = 0; int n = nums.size(); for (int i = 0; i dp(neg + 1, 0); dp[0] = 1; for (const auto &num : nums) { for (int j = neg; j >= 0; --j) { if (j Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-25 18:31:45 "},"docs/leetcode/501-600/":{"url":"docs/leetcode/501-600/","title":"501~600","keywords":"","body":"题目目录题目目录 Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-25 18:31:45 "},"docs/leetcode/501-600/523.html":{"url":"docs/leetcode/501-600/523.html","title":"523.连续的子数组和","keywords":"","body":"连续的子数组和(中等)解法一连续的子数组和(中等) 给你一个整数数组 nums 和一个整数 k ，编写一个函数来判断该数组是否含有同时满足下述条件的连续子数组： 子数组大小 至少为 2 ，且 子数组元素总和为 k 的倍数。 如果存在，返回 true ；否则，返回 false 。 如果存在一个整数 n ，令整数 x 符合 x = n * k ，则称 x 是 k 的一个倍数。 示例 1： 输入：nums = [23,2,4,6,7], k = 6 输出：true 解释：[2,4] 是一个大小为 2 的子数组，并且和为 6 。 示例 2： 输入：nums = [23,2,6,4,7], k = 6 输出：true 解释：[23, 2, 6, 4, 7] 是大小为 5 的子数组，并且和为 42 。 42 是 6 的倍数，因为 42 = 7 * 6 且 7 是一个整数。 示例 3： 输入：nums = [23,2,6,4,7], k = 13 输出：false 提示： 1 0 0 1 解法一 暂无 Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-25 18:31:45 "},"docs/leetcode/501-600/525.html":{"url":"docs/leetcode/501-600/525.html","title":"525.连续数组","keywords":"","body":"连续数组(中等)解法一解法二连续数组(中等) 给定一个二进制数组 nums , 找到含有相同数量的 0 和 1 的最长连续子数组，并返回该子数组的长度。 示例 1: 输入: nums = [0,1] 输出: 2 说明: [0, 1] 是具有相同数量0和1的最长连续子数组。 示例 2: 输入: nums = [0,1,0] 输出: 2 说明: [0, 1] (或 [1, 0]) 是具有相同数量0和1的最长连续子数组。 提示： 1 nums[i] 不是 0 就是 1 解法一 前缀和 + 哈希表 求 0 和 1 数量相等的子数组, 这里可以把 0 看做 -1, 这样求前缀和 只要子数组的 和 为 0, 就说明这个子数组的 0 和 1 数量一样 任何一个子数组的和, 都可以通过 sum[j] - sum[i] 计算出来 如果 sum[j] 和 sum[i] 的值相等, 那么它们相减就等于 0, 也就是说 j - i 这个数组段的子数组复合题意. 用一个map来保存 前缀和 和 该前缀和的最早出现的下标 需要注意的是, 如果从 0 ~ i 的和为 0, 那么这时 i + 1 就是一个符合题意的子数组, 所以这里把第一个 前缀和为 0 规定为 {0, -1} class Solution { public: int findMaxLength(vector& nums) { int sum = 0; int maxLen = 0; unordered_map sumMap {{0, -1}}; for (int i = 0; i second); } else { sumMap[sum] = i; } } return maxLen; } }; 解法二 前缀和 同样还是前缀和, 但不同的是这里使用数组来存放 前缀和 和 下标 假如 n 是给定数组的长度, 再申请一个长度为 2n + 的数组, 设置 idx 的初始值为 n 如果为 0 就让 --idx, 如果为 1 就 ++idx, idx的范围就是 0~2n, idx既是前缀和, 也是获取 nums 下标的下标 为了区别 数组中存放的是下标还是一个空值, 就把数组中的值初始化为 -2, 如果等于 -2, 就说明是第一次遇到该前缀和, 否则就是遇到过该前缀合, 可以用来计算 符合题意的子数组 class Solution { public: int findMaxLength(vector& nums) { int idx = nums.size(); int maxLen = 0; vector sumArr(nums.size() * 2 + 1, -2); sumArr[nums.size()] = -1; for (int i = 0; i Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-25 18:31:45 "},"docs/leetcode/501-600/526.html":{"url":"docs/leetcode/501-600/526.html","title":"526.优美的排列","keywords":"","body":"优美的排列(中等)解法一优美的排列(中等) 假设有从 1 到 N 的 N 个整数，如果从这 N 个数字中成功构造出一个数组，使得数组的第 i 位 (1 满足如下两个条件中的一个，我们就称这个数组为一个优美的排列。条件： 第 i 位的数字能被 i 整除 i 能被第 i 位上的数字整除 现在给定一个整数 N，请问可以构造多少个优美的排列？ 示例1: 输入: 2 输出: 2 解释: 第 1 个优美的排列是 [1, 2]: 第 1 个位置（i=1）上的数字是1，1能被 i（i=1）整除 第 2 个位置（i=2）上的数字是2，2能被 i（i=2）整除 第 2 个优美的排列是 [2, 1]: 第 1 个位置（i=1）上的数字是2，2能被 i（i=1）整除 第 2 个位置（i=2）上的数字是1，i（i=2）能被 1 整除 说明: N 是一个正整数，并且不会超过15。 解法一 先预处理找到 1~n 之间每个位置满足条件之一的数字并保存下来，然后使用回溯把这些保存下来的数字排列组合，排列组合的个数，就是优美排列的数组个数 排列过程中需要注意已经使用过的数字，这里用一个数组来记录已经使用过的数字。 qclass Solution { public: int countArrangement(int n) { int ans = 0; vector vis(n, false); vector > match(n + 1); function dfs = [&](int index) { if (index == n + 1) { ++ans; return ; } for (auto &i : match[index]) { if (!vis[i]) { vis[i] = true; dfs(index + 1); vis[i] = false; } } }; for (int i = 1; i Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-25 18:31:45 "},"docs/leetcode/501-600/541.html":{"url":"docs/leetcode/501-600/541.html","title":"541.翻转字符串2","keywords":"","body":"翻转字符串2(简单)解法一翻转字符串2(简单) 给定一个字符串 s 和一个整数 k，从字符串开头算起，每 2k 个字符反转前 k 个字符。 如果剩余字符少于 k 个，则将剩余字符全部反转。 如果剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符，其余字符保持原样。 示例 1： 输入：s = \"abcdefg\", k = 2 输出：\"bacdfeg\" 示例 2： 输入：s = \"abcd\", k = 2 输出：\"bacd\" 提示： 1 s 仅由小写英文组成 1 解法一 直接暴力解决, 按步模拟. class Solution { public: string reverseStr(string s, int k) { auto reverse = [](int start, int end, string &s) { while (start 优化代码 看了题解后, 知道了不用在循环外对末尾检查了. class Solution { public: string reverseStr(string s, int k) { auto reverse = [](int start, int end, string &s) { while (start Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-25 18:31:45 "},"docs/leetcode/501-600/551.html":{"url":"docs/leetcode/501-600/551.html","title":"551.学生出勤记录1","keywords":"","body":"学生出勤记录1(简单)解法一学生出勤记录1(简单) 给你一个字符串 s 表示一个学生的出勤记录，其中的每个字符用来标记当天的出勤情况（缺勤、迟到、到场）。记录中只含下面三种字符： 'A'：Absent，缺勤 'L'：Late，迟到 'P'：Present，到场 如果学生能够 同时 满足下面两个条件，则可以获得出勤奖励： 按 总出勤 计，学生缺勤（'A'）严格 少于两天。 学生 不会 存在 连续 3 天或 3 天以上的迟到（'L'）记录。 如果学生可以获得出勤奖励，返回 true ；否则，返回 false 。 示例 1： 输入：s = \"PPALLP\" 输出：true 解释：学生缺勤次数少于 2 次，且不存在 3 天或以上的连续迟到记录。 示例 2： 输入：s = \"PPALLL\" 输出：false 解释：学生最后三天连续迟到，所以不满足出勤奖励的条件。 提示： 1 s[i] 为 'A'、'L' 或 'P' 解法一 模拟 class Solution { public: bool checkRecord(string s) { int lcount = 0; int acount = 0; for (const auto &ch : s) { if (ch == 'A' && ++acount >= 2) { return false; } else if (ch == 'L') { if (++lcount >= 3) { return false; } } else { lcount = 0; } } return true; } }; Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-25 18:31:45 "},"docs/leetcode/501-600/552.html":{"url":"docs/leetcode/501-600/552.html","title":"552.学生出勤记录2","keywords":"","body":"学生出勤记录2(困难)解法一学生出勤记录2(困难) 给你一个字符串 s 表示一个学生的出勤记录，其中的每个字符用来标记当天的出勤情况（缺勤、迟到、到场）。记录中只含下面三种字符： 'A'：Absent，缺勤 'L'：Late，迟到 'P'：Present，到场 如果学生能够 同时 满足下面两个条件，则可以获得出勤奖励： 按 总出勤 计，学生缺勤（'A'）严格 少于两天。 学生 不会 存在 连续 3 天或 3 天以上的迟到（'L'）记录。 给你一个整数 n，表示出勤记录的长度（次数）。请你返回记录长度为 n 时，可能获得出勤奖励的记录情况 数量。答案可能很大，所以返回对 10^9 + 7 取余 的结果。 示例 1： 输入：n = 2 输出：8 解释： 有 8 种长度为 2 的记录将被视为可奖励： \"PP\" , \"AP\", \"PA\", \"LP\", \"PL\", \"AL\", \"LA\", \"LL\" 只有\"AA\"不会被视为可奖励，因为缺勤次数为 2 次（需要少于 2 次）。 示例 2： 输入：n = 1 输出：3 示例 3： 输入：n = 10101 输出：183236316 提示： 1 解法一 题解 class Solution { public: const int MOD = 1000000007; int checkRecord(int n) { vector > > dp(n + 1, vector >(2, vector(3))); dp[0][0][0] = 1; for (int i = 1; i 优化dp dp[i][][] 只和 dp[i - 1][][] 有关系，可以使用两个数组循环使用，节省大量内存。 class Solution { public: const int MOD = 1000000007; int checkRecord(int n) { int dp[2][3]; memset(dp, 0x00, sizeof(dp)); dp[0][0] = 1; for (int i = 1; i Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-25 18:31:45 "},"docs/leetcode/501-600/576.html":{"url":"docs/leetcode/501-600/576.html","title":"576.出界的路径数","keywords":"","body":"出界的路径数(中等)解法一解法二出界的路径数(中等) 给你一个大小为 m x n 的网格和一个球。球的起始坐标为 [startRow, startColumn] 。你可以将球移到在四个方向上相邻的单元格内（可以穿过网格边界到达网格之外）。你 最多 可以移动 maxMove 次球。 给你五个整数 m、n、maxMove、startRow 以及 startColumn ，找出并返回可以将球移出边界的路径数量。因为答案可能非常大，返回对 10^9 + 7 取余 后的结果。 示例 1： 输入：m = 2, n = 2, maxMove = 2, startRow = 0, startColumn = 0 输出：6 示例 2： 输入：m = 1, n = 3, maxMove = 3, startRow = 0, startColumn = 1 输出：12 提示： 1 0 0 0 解法一 dfs(超时) 足球可以向四个方向移动, 所以要考虑四个方向的深入遍历, 当移动的次数不足或越界时, 停止深入, 且越界时把路径结果加一. class Solution { public: const int MOD = 1000000007; int findPaths(int m, int n, int maxMove, int startRow, int startColumn) { _m = m; _n = n; int ans = 0; dfs(ans, maxMove, startRow, startColumn); return ans; } private: void dfs(int &ans, int step, int row, int col) { if (row >= step && col >= step && step + row 解法二 动态规划 + dfs 在解法一的基础上增加一个记忆化的数组, 该数组用于保存某个位置剩余步数的所有方法, 既 remember[row][col][step] 表示在 row 行, col 列, 还还剩余 step 步时, 有多少种路径可以出界. class Solution { public: const int MOD = 1000000007; int findPaths(int m, int n, int maxMove, int startRow, int startColumn) { vector > > remember(m + 2, vector >(n + 2, vector(maxMove, -1))); vector drow = {0, -1, 0, 1}; vector dcol = {-1, 0, 1, 0}; function dfs = [&](int step, int row, int col) { if (row > m || row == 0 || col > n || col == 0) { return 1; } else if (step == 0) { return 0; } int ans = 0; for (int i = 0; i Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-25 18:31:45 "},"docs/leetcode/501-600/581.html":{"url":"docs/leetcode/501-600/581.html","title":"581.最短无序连续子数组","keywords":"","body":"最短无序连续子数组(中等)解法一解法二最短无序连续子数组(中等) 给你一个整数数组 nums ，你需要找出一个 连续子数组 ，如果对这个子数组进行升序排序，那么整个数组都会变为升序排序。 请你找出符合题意的 最短 子数组，并输出它的长度。 示例 1： 输入：nums = [2,6,4,8,10,9,15] 输出：5 解释：你只需要对 [6, 4, 8, 10, 9] 进行升序排序，那么整个表都会变为升序排序。 示例 2： 输入：nums = [1,2,3,4] 输出：0 示例 3： 输入：nums = [1] 输出：0 提示： 1 -10^5 进阶：你可以设计一个时间复杂度为 O(n) 的解决方案吗？ 解法一 使用一个集合来存储nums的所有值, 利用集合的有序功能, 遍历集合和原始数组, 来找到不相等数字的第一个下标和最后一个下标, 这俩下标差就是最短的无序连续子数组的长度. class Solution { public: int findUnsortedSubarray(vector& nums) { multiset orderTab(nums.begin(), nums.end()); int left = 0, right = 0; int idx = 0; for (const auto val : orderTab) { if (val == nums[idx++]) { if (!right) { ++left; } } else { right = idx; } } return right == 0 ? right : right - left; } }; 优化 直接用另个一数组进行排序, 和原数组比较效果更好, 但原理和上面的一样 这个速度要快一点, 因为只做一次排序 class Solution { public: int findUnsortedSubarray(vector& nums) { vector nums2 = nums; sort(nums2.begin(), nums2.end()); int left = 0, right = 0; for (int idx = 0; idx 题解优化 看到题解后, 发现我的思路还是太窄了, 直接从前遍历取 left, 从后向前遍历取 right, 这样更好一点. class Solution { public: int findUnsortedSubarray(vector& nums) { if (is_sorted(nums.begin(), nums.end())) { return 0; } vector nums2 = nums; sort(nums2.begin(), nums2.end()); int left = 0, right = nums.size() - 1; while (nums2[left] == nums[left]) { ++left; } while (nums2[right] == nums[right]) { --right; } return right - left + 1; } }; 解法二 O(n)解法 题解 class Solution { public: int findUnsortedSubarray(vector& nums) { int n = nums.size(); int maxn = INT_MIN, right = -1; int minn = INT_MAX, left = -1; for (int i = 0; i nums[i]) { right = i; } else { maxn = nums[i]; } if (minn Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-25 18:31:45 "},"docs/leetcode/601-700/":{"url":"docs/leetcode/601-700/","title":"601~700","keywords":"","body":"题目目录题目目录 Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-25 18:31:45 "},"docs/leetcode/601-700/611.html":{"url":"docs/leetcode/601-700/611.html","title":"611.有效三角形的个数","keywords":"","body":"有效三角形的个数(中等)解法一解法二有效三角形的个数(中等) 给定一个包含非负整数的数组，你的任务是统计其中可以组成三角形三条边的三元组个数。 示例 1: 输入: [2,2,3,4] 输出: 3 解释: 有效的组合是: 2,3,4 (使用第一个 2) 2,3,4 (使用第二个 2) 2,2,3 注意: 数组长度不超过1000。 数组里整数的范围为 [0, 1000]。 解法一 暴力法(超时) class Solution { public: int triangleNumber(vector& nums) { int ans = 0; int n = nums.size(); sort(nums.begin(), nums.end()); for (int i = 0; i c && a + c > b && b + c > a; } }; 解法二 题解 class Solution { public: int triangleNumber(vector& nums) { int ans = 0; int n = nums.size(); sort(nums.begin(), nums.end()); for (int i = 0; i Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-25 18:31:45 "},"docs/leetcode/601-700/671.html":{"url":"docs/leetcode/601-700/671.html","title":"671.二叉树中第二小的节点","keywords":"","body":"二叉树中第二小的节点(简单)解法一二叉树中第二小的节点(简单) 给定一个非空特殊的二叉树，每个节点都是正数，并且每个节点的子节点数量只能为 2 或 0。如果一个节点有两个子节点的话，那么该节点的值等于两个子节点中较小的一个。 更正式地说，root.val = min(root.left.val, root.right.val) 总成立。 给出这样的一个二叉树，你需要输出所有节点中的第二小的值。如果第二小的值不存在的话，输出 -1 。 示例 1： 输入：root = [2,2,5,null,null,5,7] 输出：5 解释：最小的值是 2 ，第二小的值是 5 。 示例 2： 输入：root = [2,2,2] 输出：-1 解释：最小的值是 2, 但是不存在第二小的值。 提示： 树中节点数目在范围 [1, 25] 内 1 对于树中每个节点 root.val == min(root.left.val, root.right.val) 解法一 深度优先遍历 用ans记录结果(初始化-1), minVal记录根节点值, 如果节点的值大于根节点的值, 说明是存在第二小的值的, 第一次找到的值不一定是第二小的, 这个是先遍历左边, 第一次可能是在遇到了左边的第二小值, 最终是要取左右两个第二小的值的较小者. 判断 node->val >= ans 是为了剪枝, 再往下继续遍历也不会出现比 node->val 更小的值了, 所以结束该分支 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: int findSecondMinimumValue(TreeNode* root) { int ans = -1; int minVal = root->val; function dfs = [&](TreeNode *node) { if (!node) { return ; } if (ans != -1 && node->val >= ans) { return ; } if (minVal val) { ans = node->val; } dfs(node->left); dfs(node->right); }; dfs(root); return ans; } }; Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-25 18:31:45 "},"docs/leetcode/601-700/676.html":{"url":"docs/leetcode/601-700/676.html","title":"676.实现一个魔法字典","keywords":"","body":"实现一个魔法字典(中等)解法一解法二实现一个魔法字典(中等) 设计一个使用单词列表进行初始化的数据结构，单词列表中的单词 互不相同 。 如果给出一个单词，请判定能否只将这个单词中一个字母换成另一个字母，使得所形成的新单词存在于你构建的字典中。 实现 MagicDictionary 类： MagicDictionary() 初始化对象 void buildDict(String[] dictionary) 使用字符串数组 dictionary 设定该数据结构，dictionary 中的字符串互不相同 bool search(String searchWord) 给定一个字符串 searchWord ，判定能否只将字符串中 一个 字母换成另一个字母，使得所形成的新字符串能够与字典中的任一字符串匹配。如果可以，返回 true ；否则，返回 false 。 示例： 输入 [\"MagicDictionary\", \"buildDict\", \"search\", \"search\", \"search\", \"search\"] [[], [[\"hello\", \"leetcode\"]], [\"hello\"], [\"hhllo\"], [\"hell\"], [\"leetcoded\"]] 输出 [null, null, false, true, false, false] 解释 MagicDictionary magicDictionary = new MagicDictionary(); magicDictionary.buildDict([\"hello\", \"leetcode\"]); magicDictionary.search(\"hello\"); // 返回 False magicDictionary.search(\"hhllo\"); // 将第二个 'h' 替换为 'e' 可以匹配 \"hello\" ，所以返回 True magicDictionary.search(\"hell\"); // 返回 False magicDictionary.search(\"leetcoded\"); // 返回 False 提示： 1 1 dictionary[i] 仅由小写英文字母组成 dictionary 中的所有字符串 互不相同 1 searchWord 仅由小写英文字母组成 buildDict 仅在 search 之前调用一次 最多调用 100 次 search 解法一 中规中矩的解题方式, 每次都遍历整个字典, 并逐个比较每个单词的字符, 有且仅有一个字符不同, 才是符合要求的. class MagicDictionary { public: /** Initialize your data structure here. */ MagicDictionary() { } void buildDict(vector dictionary) { dict_ = std::move(dictionary); } bool search(string searchWord) { for (const auto &word : dict_) { if (word.size() != searchWord.size()) { continue; } int diffCount = 0; for (size_t i = 0; i 1) { break; } } if (diffCount == 1) { return true; } } return false; } private: vector dict_; }; /** * Your MagicDictionary object will be instantiated and called as such: * MagicDictionary* obj = new MagicDictionary(); * obj->buildDict(dictionary); * bool param_2 = obj->search(searchWord); */ 解法二 广义邻居 \"hello\" 和 \"-ello\"、\"h-llo\"、\"he-lo\"、\"hel-o\"、\"hell-\" 为邻居, 他们只需要修改一个字符, 就可以和 hello 相等 使用hashmap存储字典每个单词的每个邻居 每次搜索的时候, 尝试变化searchword的每个邻居与字典中搜索, 能够搜索到说明可以的, 但要注意是否与原单词相等的例外. class MagicDictionary { public: /** Initialize your data structure here. */ MagicDictionary() { } void buildDict(vector dictionary) { for (auto &word : dictionary) { for (int i = 0; i second > 1 || it->second == 1 && !haveWord)) { return true; } searchWord[i] = ch; } return false; } private: unordered_map wordMap_; unordered_set rawWord_; }; /** * Your MagicDictionary object will be instantiated and called as such: * MagicDictionary* obj = new MagicDictionary(); * obj->buildDict(dictionary); * bool param_2 = obj->search(searchWord); */ Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-25 18:31:45 "},"docs/leetcode/701-800/":{"url":"docs/leetcode/701-800/","title":"701~800","keywords":"","body":"题目目录题目目录 Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-25 18:31:45 "},"docs/leetcode/701-800/704.html":{"url":"docs/leetcode/701-800/704.html","title":"704.二分查找","keywords":"","body":"二分查找(简单)解法一解法二二分查找(简单) 给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。 示例 1: 输入: nums = [-1,0,3,5,9,12], target = 9 输出: 4 解释: 9 出现在 nums 中并且下标为 4 示例 2: 输入: nums = [-1,0,3,5,9,12], target = 2 输出: -1 解释: 2 不存在 nums 中因此返回 -1 提示： 你可以假设 nums 中的所有元素是不重复的。 n 将在 [1, 10000] 之间。 nums 的每个元素都将在 [-9999, 9999] 之间。 解法一 题目是要求二分查找, 当然用暴力法也可以解决问题 class Solution { public: int search(vector& nums, int target) { for (size_t i = 0; i 解法二 二分查找 每次都选择相对两端的中点值与目标值比较, 快速找到目标值 class Solution { public: int search(vector& nums, int target) { int left = 0, right = nums.size() - 1; int idx; while (left target) { right = idx - 1; } else if (nums[idx] Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-25 18:31:45 "},"docs/leetcode/701-800/787.html":{"url":"docs/leetcode/701-800/787.html","title":"787.K站中转内最便宜的航班","keywords":"","body":"K站中转内最便宜的航班(中等)解法一K站中转内最便宜的航班(中等) 有 n 个城市通过一些航班连接。给你一个数组 flights ，其中 flights[i] = [fromi, toi, pricei] ，表示该航班都从城市 fromi 开始，以价格 pricei 抵达 toi。 现在给定所有的城市和航班，以及出发城市 src 和目的地 dst，你的任务是找到出一条最多经过 k站中转的路线，使得从 src 到 dst 的 价格最便宜 ，并返回该价格。 如果不存在这样的路线，则输出 -1。 示例 1： 输入: n = 3, edges = [[0,1,100],[1,2,100],[0,2,500]] src = 0, dst = 2, k = 1 输出: 200 解释: 城市航班图如下 从城市 0 到城市 2 在 1 站中转以内的最便宜价格是 200，如图中红色所示。 示例 2： 输入: n = 3, edges = [[0,1,100],[1,2,100],[0,2,500]] src = 0, dst = 2, k = 0 输出: 500 解释: 城市航班图如下 从城市 0 到城市 2 在 0 站中转以内的最便宜价格是 500，如图中蓝色所示。 提示： 1 0 flights[i].length == 3 0 fromi != toi 1 航班没有重复，且不存在自环 0 src != dst 解法一 动态规划 参考题解思路，dp[t][i] 表示中转 t 次航班，从出发城市 src 到达城市 i 需要花费的最小费用。 通过遍历所有航班，从中找到从城市 j 出发到达城市 i 的航班，那么前 t - 1 次航班的最小花费就是 dp[t - 1][j] 加上最后一次航班的费用。 因为最多中转 k 次，所以就是做多搭乘 k + 1 次航班，最终答案为： dp[1][dst], dp[2][dst], ... ... dp[k + 1][dst] 中的最小值。 当 t = 0 时，dp[t][i] 表示不搭乘航班到达城市的最小花费，此时，当 i == src 时，正好不用搭乘就到达了目的地，即 dp[0][src] = 0 ，否则就无法到达目的城市。这个时候定义该状态为一个极大值，表示无法到达目的地。 因为航班花费最多 10^4 且最多搭乘 k + 1 次，所以极大值可以定义为 10^4 * 101 + 1 class Solution { public: const int INF = 101 * 10000 + 1; int findCheapestPrice(int n, vector>& flights, int src, int dst, int k) { vector > dp(k + 2, vector(n, INF)); dp[0][src] = 0; for (int t = 1; t 优化 使用两个一维数组，减少内存空间占用。 class Solution { public: const int INF = 101 * 10000 + 1; int findCheapestPrice(int n, vector>& flights, int src, int dst, int k) { vector dp(n, INF); dp[src] = 0; for (int t = 1; t newDp(dp); for (auto &flight : flights) { int j = flight[0]; int i = flight[1]; int cost = flight[2]; dp[i] = min(dp[i], newDp[j] + cost); } } int ans = INF; for (int t = 1; t Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-25 18:31:45 "},"docs/leetcode/701-800/789.html":{"url":"docs/leetcode/701-800/789.html","title":"789.逃脱阻碍者","keywords":"","body":"逃脱阻碍者(中等)解法一逃脱阻碍者(中等) 你在进行一个简化版的吃豆人游戏。你从 [0, 0] 点开始出发，你的目的地是 target = [xtarget, ytarget] 。地图上有一些阻碍者，以数组 ghosts 给出，第 i 个阻碍者从 ghosts[i] = [xi, yi] 出发。所有输入均为 整数坐标 。 每一回合，你和阻碍者们可以同时向东，西，南，北四个方向移动，每次可以移动到距离原位置 1 个单位 的新位置。当然，也可以选择 不动 。所有动作 同时 发生。 如果你可以在任何阻碍者抓住你 之前 到达目的地（阻碍者可以采取任意行动方式），则被视为逃脱成功。如果你和阻碍者同时到达了一个位置（包括目的地）都不算是逃脱成功。 只有在你有可能成功逃脱时，输出 true ；否则，输出 false 。 示例 1： 输入：ghosts = [[1,0],[0,3]], target = [0,1] 输出：true 解释：你可以直接一步到达目的地 (0,1) ，在 (1, 0) 或者 (0, 3) 位置的阻碍者都不可能抓住你。 示例 2： 输入：ghosts = [[1,0]], target = [2,0] 输出：false 解释：你需要走到位于 (2, 0) 的目的地，但是在 (1, 0) 的阻碍者位于你和目的地之间。 示例 3： 输入：ghosts = [[2,0]], target = [1,0] 输出：false 解释：阻碍者可以和你同时达到目的地。 示例 4： 输入：ghosts = [[5,0],[-10,-2],[0,-5],[-2,-2],[-7,1]], target = [7,7] 输出：false 示例 5： 输入：ghosts = [[-1,0],[0,1],[-1,0],[0,1],[-1,0]], target = [0,0] 输出：true 提示： 1 ghosts[i].length == 2 -10^4 同一位置可能有 多个阻碍者 。 target.length == 2 -10^4 解法一 曼哈顿距离 如果阻碍者和目的地的曼哈顿距离小于等于玩家和目的地的曼哈顿距离，那么阻碍者可以在目的地相遇，玩家就会被抓。 如果所有阻碍者和目的地的曼哈顿距离都大于玩家和目的地的曼哈顿距离，那么玩家可以在阻碍者之前到达目的地。 第二种情况证明参考题解 题解 class Solution { public: bool escapeGhosts(vector>& ghosts, vector& target) { int targetDist = abs(target[0]) + abs(target[1]); for (const auto &ghost : ghosts) { int dist = abs(target[0] - ghost[0]) + abs(target[1] - ghost[1]); if (dist Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-25 18:31:45 "},"docs/leetcode/701-800/797.html":{"url":"docs/leetcode/701-800/797.html","title":"797.所有可能的路径","keywords":"","body":"所有可能的路径(中等)解法一所有可能的路径(中等) 给你一个有 n 个节点的 有向无环图（DAG），请你找出所有从节点 0 到节点 n-1 的路径并输出（不要求按特定顺序） 二维数组的第 i 个数组中的单元都表示有向图中 i 号节点所能到达的下一些节点，空就是没有下一个结点了。 译者注：有向图是有方向的，即规定了 a→b你就不能从 b→a。 示例 1： 输入：graph = [[1,2],[3],[3],[]] 输出：[[0,1,3],[0,2,3]] 解释：有两条路径 0 -> 1 -> 3 和 0 -> 2 -> 3 示例 2： 输入：graph = [[4,3,1],[3,2,4],[3],[4],[]] 输出：[[0,4],[0,3,4],[0,1,3,4],[0,1,2,3,4],[0,1,4]] 示例 3： 输入：graph = [[1],[]] 输出：[[0,1]] 示例 4： 输入：graph = [[1,2,3],[2],[3],[]] 输出：[[0,1,2,3],[0,2,3],[0,3]] 示例 5： 输入：graph = [[1,3],[2],[3],[]] 输出：[[0,1,2,3],[0,3]] 提示： n == graph.length 2 0 graph[i][j] != i（即，不存在自环） graph[i] 中的所有元素 互不相同 保证输入为 有向无环图（DAG） 解法一 dfs 深度遍历回溯记录所有可能路径 临界点是到达 n - 1 为止。 class Solution { public: vector> allPathsSourceTarget(vector>& graph) { vector > ans; int n = graph.size(); vector stk(1, 0); function dfs = [&](int idx) { if (idx == n - 1) { ans.push_back(stk); return ; } for (auto &to : graph[idx]) { stk.push_back(to); dfs(to); stk.pop_back(); } }; dfs(0); return ans; } }; Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-25 18:31:45 "},"docs/leetcode/801-900/":{"url":"docs/leetcode/801-900/","title":"801~900","keywords":"","body":"题目目录题目目录 Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-25 18:31:45 "},"docs/leetcode/801-900/802.html":{"url":"docs/leetcode/801-900/802.html","title":"802.找到最终的安全状态","keywords":"","body":"找到最终的安全状态(中等)解法一找到最终的安全状态(中等) 在有向图中，以某个节点为起始节点，从该点出发，每一步沿着图中的一条有向边行走。如果到达的节点是终点（即它没有连出的有向边），则停止。 对于一个起始节点，如果从该节点出发，无论每一步选择沿哪条有向边行走，最后必然在有限步内到达终点，则将该起始节点称作是 安全 的。 返回一个由图中所有安全的起始节点组成的数组作为答案。答案数组中的元素应当按 升序 排列。 该有向图有 n 个节点，按 0 到 n - 1 编号，其中 n 是 graph 的节点数。图以下述形式给出：graph[i] 是编号 j 节点的一个列表，满足 (i, j) 是图的一条有向边。 示例 1： ```none 输入：graph = [[1,2],[2,3],[5],[0],[5],[],[]] 输出：[2,4,5,6] 解释：示意图如上。 ``` **示例 2：** ```none 输入：graph = [[1,2,3,4],[1,2],[3,4],[0,4],[]] 输出：[4] ``` **提示：** - `n == graph.length` - `1 解法一 dfs 加 三色标记, 参考题解的思路 默认色为无色, 灰色表示环或者处于递归中, 黑色表示安全状态点 当遇到节点的数字为空时, 肯定是安全状态点. ```cpp class Solution { public: // 1 无色 // 2 灰色 // 3 黑色 vector eventualSafeNodes(vector>& graph) { int n = graph.size(); vector color(n, 0); vector ans; for (int i = 0; i &color, vector > &gh, int node) { if (gh[node].empty() || color[node] == 3) { color[node] = 3; return true; } color[node] = 2; for (int i = 0; i **优化代码结构** 参考题解优化一下代码 ```cpp class Solution { public: // 1 无色 // 2 灰色 // 3 黑色 vector eventualSafeNodes(vector>& graph) { int n = graph.size(); vector color(n, 0); vector ans; for (int i = 0; i &color, vector > &gh, int node) { if (color[node] > 1) { return color[node] == 3; } color[node] = 2; for (const auto val : gh[node]) { if (!dfs(color, gh, val)) { return false; } } color[node] = 3; return true; } }; Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-25 18:31:45 "},"docs/leetcode/801-900/829.html":{"url":"docs/leetcode/801-900/829.html","title":"829.连续整数求和","keywords":"","body":"连续整数求和(困难)解法一(超时)解法二连续整数求和(困难) 给定一个正整数 N，试求有多少组连续正整数满足所有数字之和为 N? 示例 1: 输入: 5 输出: 2 解释: 5 = 5 = 2 + 3，共有两组连续整数([5],[2,3])求和后为 5。 示例 2: 输入: 9 输出: 3 解释: 9 = 9 = 4 + 5 = 2 + 3 + 4 示例 3: 输入: 15 输出: 4 解释: 15 = 15 = 8 + 7 = 4 + 5 + 6 = 1 + 2 + 3 + 4 + 5 说明: 1 解法一(超时) 暴力法, 以每个数为开始, 找连续数之和等于target, 知道找到所有结果 class Solution { public: int consecutiveNumbersSum(int n) { int ans = 1; int N = n / 2; int target, x; for (int i = 1; i 0) { target -= x++; } if (!target) { ++ans; } } return ans; } }; 解法二 1个数时，必然有一个数可构成N 2个数若要构成N，第2个数与第1个数差为1，N减掉这个1能整除2则能由商与商+1构成N 3个数若要构成N，第2个数与第1个数差为1，第3个数与第1个数的差为2，N减掉1再减掉2能整除3则能由商、商+1与商+2构成N 依次内推，当商即第1个数小于等于0时结束 class Solution { public: int consecutiveNumbersSum(int N) { int res = 0; for (int i = 1; N > 0; N -= i++) { res += (N % i == 0); } return res; } }; Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-25 18:31:45 "},"docs/leetcode/801-900/863.html":{"url":"docs/leetcode/801-900/863.html","title":"863.二叉树中所有距离为K的结点","keywords":"","body":"二叉树中所有距离为K的结点(中等)解法一解法二二叉树中所有距离为K的结点(中等) 给定一个二叉树（具有根结点 root）， 一个目标结点 target ，和一个整数值 K 。 返回到目标结点 target 距离为 K 的所有结点的值的列表。 答案可以以任何顺序返回。 示例 1： 输入：root = [3,5,1,6,2,0,8,null,null,7,4], target = 5, K = 2 输出：[7,4,1] 解释： 所求结点为与目标结点（值为 5）距离为 2 的结点， 值分别为 7，4，以及 1 注意，输入的 \"root\" 和 \"target\" 实际上是树上的结点。上面的输入仅仅是对这些对象进行了序列化描述。 提示： 给定的树是非空的。 树上的每个结点都具有唯一的值 0 。 目标结点 target 是树上的结点。 0 解法一 深度优先遍历 先从target节点向下遍历找到距离所有为k的结点，然后再通过树遍历找到target，并把路径保存下来，记录targer在每个路径结点的左边还是右边，最后再反方向查找距离为k的结点。 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public: vector distanceK(TreeNode* root, TreeNode* target, int k) { vector ans; function dfs = [&](TreeNode *node, int currk) { if (!node) { return ; } if (currk == k) { ans.push_back(node->val); return ; } dfs(node->left, currk +1); dfs(node->right, currk + 1); }; dfs(target, 0); TreeNode *node = target; findTarget(root, target, 0); for (int i = 0; i val); continue; } if (_tk[i + 1].second == 1) { dfs(_tk[i].first->right, currk + 1); } else { dfs(_tk[i].first->left, currk + 1); } } return ans; } private: void findTarget(TreeNode *node, const TreeNode *target, int direction) { if (!node || _stop) { return ; } _tk.push_back({node, direction}); if (target == node) { _stop = true; return ; } findTarget(node->left, target, 1); findTarget(node->right, target, 2); if (!_stop) { _tk.pop_back(); } } private: vector > _tk; bool _stop = { false }; }; 解法二 参考的题解 使用一个表存储每个结点的父节点, 然后以target为起始节点开始深度遍历, 这样以target为起点, 可以很容易找到距离为K的所有结点. 为了防止重复遍历, 使用一个from结点溯源. /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public: vector distanceK(TreeNode* root, TreeNode* target, int k) { findParents(root); findAns(target, target, 0, k); return _ans; } private: void findParents(TreeNode *node) { if (!node) { return ; } if (node->left) { _parents[node->left->val] = node; findParents(node->left); } if (node->right) { _parents[node->right->val] = node; findParents(node->right); } } void findAns(TreeNode *node, TreeNode *from, int currk, int k) { if (!node) { return ; } if (currk == k) { _ans.push_back(node->val); return ; } if (node->left != from) { findAns(node->left, node, currk + 1, k); } if (node->right != from) { findAns(node->right, node, currk + 1, k); } if (_parents[node->val] != from) { findAns(_parents[node->val], node, currk + 1, k); } } private: unordered_map _parents; vector _ans; }; Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-25 18:31:45 "},"docs/leetcode/901-1000/":{"url":"docs/leetcode/901-1000/","title":"901~1000","keywords":"","body":"题目目录题目目录 Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-25 18:31:45 "},"docs/leetcode/901-1000/909.html":{"url":"docs/leetcode/901-1000/909.html","title":"909.蛇梯棋","keywords":"","body":"蛇梯棋(中等)解法一蛇梯棋(中等) N x N 的棋盘 board 上，按从 1 到 N*N 的数字给方格编号，编号 从左下角开始，每一行交替方向。 例如，一块 6 x 6 大小的棋盘，编号如下： r 行 c 列的棋盘，按前述方法编号，棋盘格中可能存在 “蛇” 或 “梯子”；如果 board[r][c] != -1，那个蛇或梯子的目的地将会是 board[r][c]。 玩家从棋盘上的方格 1 （总是在最后一行、第一列）开始出发。 每一回合，玩家需要从当前方格 x 开始出发，按下述要求前进： 选定目标方格：从编号为 x+1，x+2，x+3，x+4，x+5，或者 x+6 的方格中选出一个作为目标方格 s ，目标方格的编号 。 该选择模拟了掷骰子的情景，无论棋盘大小如何，你的目的地范围也只能处于区间 [x+1, x+6] 之间。 传送玩家：如果目标方格 S 处存在蛇或梯子，那么玩家会传送到蛇或梯子的目的地。否则，玩家传送到目标方格 S 。 注意，玩家在每回合的前进过程中最多只能爬过蛇或梯子一次：就算目的地是另一条蛇或梯子的起点，你也不会继续移动。 返回达到方格 N*N 所需的最少移动次数，如果不可能，则返回 -1。 示例： 输入：[ [-1,-1,-1,-1,-1,-1], [-1,-1,-1,-1,-1,-1], [-1,-1,-1,-1,-1,-1], [-1,35,-1,-1,13,-1], [-1,-1,-1,-1,-1,-1], [-1,15,-1,-1,-1,-1]] 输出：4 解释： 首先，从方格 1 [第 5 行，第 0 列] 开始。 你决定移动到方格 2，并必须爬过梯子移动到到方格 15。 然后你决定移动到方格 17 [第 3 行，第 4 列]，必须爬过蛇到方格 13。 然后你决定移动到方格 14，且必须通过梯子移动到方格 35。 然后你决定移动到方格 36, 游戏结束。 可以证明你需要至少 4 次移动才能到达第 N*N 个方格，所以答案是 4。 提示： 2 board[i][j] 介于 1 和 N*N 之间或者等于 -1。 编号为 1 的方格上没有蛇或梯子。 编号为 N*N 的方格上没有蛇或梯子。 解法一 参考的题解 模拟 根据规则，模拟所有可能行走的情况，使用bfs来找到最先到达终点的方法，既最少步骤。 需要注意的是棋盘为s形，起点为左下角，终点可能是左上角也可能是右上角。 class Solution { public: int snakesAndLadders(vector>& board) { int n = board.size(); queue > q; vector used(n * n + 1, false); q.push({1, 0}); while (!q.empty()) { auto val = q.front(); q.pop(); for (int i = 1; i n * n) { break; } auto rc = id2rc(next, n); if (board[rc.first][rc.second] != -1) { next = board[rc.first][rc.second]; } if (next == n * n) { return val.second + 1; } if (!used[next]) { used[next] = true; q.push({next, val.second + 1}); } } } return -1; } private: pair id2rc(int id, int n) { int r = (id - 1) / n, c = (id - 1) % n; if (r % 2 == 1) { c = n - 1 - c; } return {n - 1 - r, c}; } }; Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-25 18:31:45 "},"docs/leetcode/901-1000/946.html":{"url":"docs/leetcode/901-1000/946.html","title":"946.验证栈序列","keywords":"","body":"验证栈序列(中等)解法一验证栈序列(中等) 给定 pushed 和 popped 两个序列，每个序列中的 值都不重复，只有当它们可能是在最初空栈上进行的推入 push 和弹出 pop 操作序列的结果时，返回 true；否则，返回 false 。 示例 1： 输入：pushed = [1,2,3,4,5], popped = [4,5,3,2,1] 输出：true 解释：我们可以按以下顺序执行： push(1), push(2), push(3), push(4), pop() -> 4, push(5), pop() -> 5, pop() -> 3, pop() -> 2, pop() -> 1 示例 2： 输入：pushed = [1,2,3,4,5], popped = [4,3,5,1,2] 输出：false 解释：1 不能在 2 之前弹出。 提示： 0 0 pushed 是 popped 的排列。 解法一 因为没有相同的数字, 所以进栈和出栈的方式只有一种可能, 所以只要按照顺序满足条件入栈出栈, 最后检查入栈和出栈队列的情况 class Solution { public: bool validateStackSequences(vector& pushed, vector& popped) { vector pu; const vector &po = popped; int poIdx = 0; for (int i = 0; i 优化代码 class Solution { public: bool validateStackSequences(vector& pushed, vector& popped) { vector pu; pu.reserve(pushed.size()); const vector &po = popped; int poIdx = 0; for (int i = 0; i Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-25 18:31:45 "},"docs/leetcode/901-1000/970.html":{"url":"docs/leetcode/901-1000/970.html","title":"970.强整数","keywords":"","body":"强整数(中等)解法一强整数(中等) 给定两个正整数 x 和 y，如果某一整数等于 x^i + y^j，其中整数 i >= 0 且 j >= 0，那么我们认为该整数是一个强整数。 返回值小于或等于 bound 的所有强整数组成的列表。 你可以按任何顺序返回答案。在你的回答中，每个值最多出现一次。 示例 1： 输入：x = 2, y = 3, bound = 10 输出：[2,3,4,5,7,9,10] 解释： 2 = 2^0 + 3^0 3 = 2^1 + 3^0 4 = 2^0 + 3^1 5 = 2^1 + 3^1 7 = 2^2 + 3^1 9 = 2^3 + 3^0 10 = 2^0 + 3^2 示例 2： 输入：x = 3, y = 5, bound = 15 输出：[2,4,6,8,10,14] 提示： 1 1 0 解法一 暴力求解, 一个一个的尝试, 当 x^i > bound 时 或 y^j > bound 时不符合需要 只有 x^i + y^j 的值满足需要, 为了去重, 使用 set class Solution { public: vector powerfulIntegers(int x, int y, int bound) { set resSet; for (int i = 0; ; ++i) { int xf = pow(x, i); if (xf > bound) { break; } for (int j = 0; ; ++j) { int yf = pow(y, j); if (xf + yf > bound) { break; } resSet.insert(xf + yf); if (y == 1) { break; } } if (x == 1) { break; } } return vector(resSet.begin(), resSet.end()); } }; Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-25 18:31:45 "},"docs/leetcode/901-1000/979.html":{"url":"docs/leetcode/901-1000/979.html","title":"979.在二叉树中分配硬币","keywords":"","body":"在二叉树中分配硬币(中等)解法一在二叉树中分配硬币(中等) 给定一个有 N 个结点的二叉树的根结点 root，树中的每个结点上都对应有 node.val 枚硬币，并且总共有 N 枚硬币。 在一次移动中，我们可以选择两个相邻的结点，然后将一枚硬币从其中一个结点移动到另一个结点。(移动可以是从父结点到子结点，或者从子结点移动到父结点。)。 返回使每个结点上只有一枚硬币所需的移动次数。 示例 1： 输入：[3,0,0] 输出：2 解释：从树的根结点开始，我们将一枚硬币移到它的左子结点上，一枚硬币移到它的右子结点上。 示例 2： 输入：[0,3,0] 输出：3 解释：从根结点的左子结点开始，我们将两枚硬币移到根结点上 [移动两次]。然后，我们把一枚硬币从根结点移到右子结点上。 示例 3： 输入：[1,0,2] 输出：2 示例 4： 输入：[1,0,0,null,3] 输出：4 提示： 1 0 解法一 dfs 思路参考题解 过载量 = abs(num_coins - 1) 叶子节点包含0个金币，过载量就是 -1，那么就需要从他的父节点移动一枚金币到该叶子节点；如果叶子节点包含多个金币，那么就需要将多余的金币移动到别的地方。 对于一个叶子节点，需要移动到他或从他移动到他的父节点一些金币，之后，就不需要再考虑这个已经计算过的叶子节点来。 使用 dfs(node) 表示该节点所在子树中金币的过载量，也就是这个子树中金币的数量减去这个子树中节点的数量。 可以计算出这个节点与他的子节点之间需要移动金币的数量为 abs(dfs(node->left)) + abs(dfs(node->right))，过载量为 node->val + dfs(node->left) + dfs(node->right) - 1 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: int distributeCoins(TreeNode* root) { int ans = 0; function dfs = [&](TreeNode *node) { if (!node) { return 0; } int l = dfs(node->left); int r = dfs(node->right); ans += abs(l) + abs(r); return node->val + l + r - 1; }; dfs(root); return ans; } }; Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-25 18:31:45 "},"docs/leetcode/901-1000/981.html":{"url":"docs/leetcode/901-1000/981.html","title":"981.基于时间的键值存储","keywords":"","body":"基于时间的键值存储(中等)解法一基于时间的键值存储(中等) 创建一个基于时间的键值存储类 TimeMap，它支持下面两个操作： set(string key, string value, int timestamp) 存储键 key、值 value，以及给定的时间戳 timestamp。 get(string key, int timestamp) 返回先前调用 set(key, value, timestamp_prev) 所存储的值，其中 timestamp_prev 。 如果有多个这样的值，则返回对应最大的 timestamp_prev 的那个值。 如果没有值，则返回空字符串（\"\"）。 示例 1： 输入：inputs = [\"TimeMap\",\"set\",\"get\",\"get\",\"set\",\"get\",\"get\"], inputs = [[],[\"foo\",\"bar\",1],[\"foo\",1],[\"foo\",3],[\"foo\",\"bar2\",4],[\"foo\",4],[\"foo\",5]] 输出：[null,null,\"bar\",\"bar\",null,\"bar2\",\"bar2\"] 解释： TimeMap kv; kv.set(\"foo\", \"bar\", 1); // 存储键 \"foo\" 和值 \"bar\" 以及时间戳 timestamp = 1 kv.get(\"foo\", 1); // 输出 \"bar\" kv.get(\"foo\", 3); // 输出 \"bar\" 因为在时间戳 3 和时间戳 2 处没有对应 \"foo\" 的值，所以唯一的值位于时间戳 1 处（即 \"bar\"） kv.set(\"foo\", \"bar2\", 4); kv.get(\"foo\", 4); // 输出 \"bar2\" kv.get(\"foo\", 5); // 输出 \"bar2\" 示例 2： 输入：inputs = [\"TimeMap\",\"set\",\"set\",\"get\",\"get\",\"get\",\"get\",\"get\"], inputs = [[],[\"love\",\"high\",10],[\"love\",\"low\",20],[\"love\",5],[\"love\",10],[\"love\",15],[\"love\",20],[\"love\",25]] 输出：[null,null,null,\"\",\"high\",\"high\",\"low\",\"low\"] 提示： 所有的键/值字符串都是小写的。 所有的键/值字符串长度都在 [1, 100] 范围内。 所有 TimeMap.set 操作中的时间戳 timestamps 都是严格递增的。 1 TimeMap.set 和 TimeMap.get 函数在每个测试用例中将（组合）调用总计 120000 次。 解法一 使用嵌套表, 外表存储key, 内表存储时间和value, 且让内表以时间排序, 可以方便使用lower_bound找到timestamp_prev. class TimeMap { public: TimeMap() { } void set(string key, string value, int timestamp) { if (_setMap.find(key) == _setMap.end()) { _setMap[key] = { { timestamp, value } }; } else { _setMap[key].insert(make_pair(timestamp, value)); } } string get(string key, int timestamp) { const auto it = _setMap.find(key); if (it != _setMap.end()) { const auto its = it->second.lower_bound(timestamp); return its == it->second.end() ? \"\" : its->second; } return \"\"; } private: map > > _setMap; }; /** * Your TimeMap object will be instantiated and called as such: * TimeMap* obj = new TimeMap(); * obj->set(key,value,timestamp); * string param_2 = obj->get(key,timestamp); */ 优化 因为知道时间插入肯定是递增的, 所以用一个vector就可以了, get的时候可以使用 upper_bound 的二分查找来快速找到value class TimeMap { public: TimeMap() { } void set(string key, string value, int timestamp) { _setMap[key].emplace_back(timestamp, value); } string get(string key, int timestamp) { const auto &it = _setMap.find(key); pair p = { timestamp, string({127}) }; auto i = upper_bound(it->second.begin(), it->second.end(), p); return i != it->second.begin() ? (i - 1)->second : \"\"; } private: map > > _setMap; }; Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-25 18:31:45 "},"docs/leetcode/1001-1100/":{"url":"docs/leetcode/1001-1100/","title":"1001~1100","keywords":"","body":"题目目录题目目录 Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-25 18:31:45 "},"docs/leetcode/1001-1100/1035.html":{"url":"docs/leetcode/1001-1100/1035.html","title":"1035.不相交的线","keywords":"","body":"不相交的线(中等)解法一不相交的线(中等) 在两条独立的水平线上按给定的顺序写下 nums1 和 nums2 中的整数。 现在，可以绘制一些连接两个数字 nums1[i] 和 nums2[j] 的直线，这些直线需要同时满足满足： nums1[i] == nums2[j] 且绘制的直线不与任何其他连线（非水平线）相交。 请注意，连线即使在端点也不能相交：每个数字只能属于一条连线。 以这种方法绘制线条，并返回可以绘制的最大连线数。 示例 1： 输入：nums1 = [1,4,2], nums2 = [1,2,4] 输出：2 解释：可以画出两条不交叉的线，如上图所示。 但无法画出第三条不相交的直线，因为从 nums1[1]=4 到 nums2[2]=4 的直线将与从 nums1[2]=2 到 nums2[1]=2 的直线相交。 示例 2： 输入：nums1 = [2,5,1,2,5], nums2 = [10,5,2,1,5,2] 输出：3 示例 3： 输入：nums1 = [1,3,7,1,7,5], nums2 = [1,9,2,5,1] 输出：2 提示： 1 1 1 解法一 动态规划 和求最长公共子序列的方法一样 dp数组解释：dp[i][j]：表示 nums1 中前 i 个数字 和 nums2 中前 j 个数字最多可以组成的直线数 转移方程： 若 nums1 中第 i 个数字和 nums2 中第 j 个数字相同，则让它们匹配可以得到最大的方案数，它们之前的最大方案数为 dp[i-1][j-1]。因此此时，dp[i][j] = dp[i-1][j-1]+1。 若为其它情况，那么 nums1 中第 i 个数字或者 nums2 中第 j 个数字，至少有一个数字不能对方案数做出贡献（也可能两个都不能），因此此时我们需要删除掉其中的一个。若删除nums1 中第 i 个数字，则此时方案数为 dp[i-1][j]；若删除 nums2 中第 j 个数字，则此时方案数为 dp[i][j-1]。显然，我们应该取这两者中的较大值。 nums1[i-1] == nums2[j-1] 时dp[i][j] = dp[i-1][j-1] + 1否则dp[i][j] = max(dp[i-1][j], dp[i][j-1]) class Solution { public: int maxUncrossedLines(vector& nums1, vector& nums2) { vector > dp(nums1.size() + 1, vector(nums2.size() + 1)); for (int i = 0; i Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-25 18:31:45 "},"docs/leetcode/1001-1100/1049.html":{"url":"docs/leetcode/1001-1100/1049.html","title":"1049.最后一块石头的重量2","keywords":"","body":"最后一块石头的重量(中等)最后一块石头的重量(中等) 无 Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-25 18:31:45 "},"docs/leetcode/1101-1200/":{"url":"docs/leetcode/1101-1200/","title":"1101~1200","keywords":"","body":"题目目录题目目录 Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-25 18:31:45 "},"docs/leetcode/1101-1200/1104.html":{"url":"docs/leetcode/1101-1200/1104.html","title":"1104.二叉树寻路","keywords":"","body":"二叉树寻路(中等)解法一解法二二叉树寻路(中等) 在一棵无限的二叉树上，每个节点都有两个子节点，树中的节点 逐行 依次按 “之” 字形进行标记。 如下图所示，在奇数行（即，第一行、第三行、第五行……）中，按从左到右的顺序进行标记； 而偶数行（即，第二行、第四行、第六行……）中，按从右到左的顺序进行标记。 给你树上某一个节点的标号 label，请你返回从根节点到该标号为 label 节点的路径，该路径是由途经的节点标号所组成的。 示例 1： 输入：label = 14 输出：[1,3,4,14] 示例 2： 输入：label = 26 输出：[1,2,6,10,26] 提示： 1 解法一 模拟 模拟一个二叉树，二叉树符合题目的“之”形标记顺序，并按照广度优先遍历顺序存放到数组中去(0号下标占位)，只存放到label。 任何一个节点的父节点都是该节点的下标除以2，可以知道label的父节点就是 label的下标除以2，这样可以很容易找到从根节点到label的路径。 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public: vector distanceK(TreeNode* root, TreeNode* target, int k) { vector ans; function dfs = [&](TreeNode *node, int currk) { if (!node) { return ; } if (currk == k) { ans.push_back(node->val); return ; } dfs(node->left, currk +1); dfs(node->right, currk + 1); }; dfs(target, 0); TreeNode *node = target; findTarget(root, target, 0); for (int i = 0; i val); continue; } if (_tk[i + 1].second == 1) { dfs(_tk[i].first->right, currk + 1); } else { dfs(_tk[i].first->left, currk + 1); } } return ans; } private: void findTarget(TreeNode *node, const TreeNode *target, int direction) { if (!node || _stop) { return ; } _tk.push_back({node, direction}); if (target == node) { _stop = true; return ; } findTarget(node->left, target, 1); findTarget(node->right, target, 2); if (!_stop) { _tk.pop_back(); } } private: vector > _tk; bool _stop = { false }; }; 解法二 数学 二叉树的偶数行都是正序序号的反转，可以通过数学计算来确定该反转节点的正序序号，而正序序号除以2就是该节点的父节点序号，而奇数节点要得到父节点，也只需要反转得到倒序序号的对应位置，除以2之后就是其父节点序号。 class Solution { public: vector pathInZigZagTree(int label) { int n = 1; while(n ans = { label }; while (n > 2) { label = (n - label + n / 2 - 1) / 2; ans.push_back(label); n >>= 1; } reverse(ans.begin(), ans.end()); return ans; } }; Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-25 18:31:45 "},"docs/leetcode/1101-1200/1190.html":{"url":"docs/leetcode/1101-1200/1190.html","title":"1190.反转每对括号间的子串","keywords":"","body":"反转每对括号间的子串(中等)解法一解法二解法三解法四反转每对括号间的子串(中等) 给出一个字符串 s（仅含有小写英文字母和括号）。 请你按照从括号内到外的顺序，逐层反转每对匹配括号中的字符串，并返回最终的结果。 注意，您的结果中 不应 包含任何括号。 示例 1： 输入：s = \"(abcd)\" 输出：\"dcba\" 示例 2： 输入：s = \"(u(love)i)\" 输出：\"iloveu\" 示例 3： 输入：s = \"(ed(et(oc))el)\" 输出：\"leetcode\" 示例 4： 输入：s = \"a(bcdefghijkl(mno)p)q\" 输出：\"apmnolkjihgfedcbq\" 提示： 0 s 中只有小写英文字母和括号 我们确保所有括号都是成对出现的 解法一 从内层括号开始向外一层一层的翻转, 我首先想到了用栈来保存左括号和下标, 然后根据碰到右括号来一层一层翻转, 这样会重复翻转多次, 复杂度较高 class Solution { public: string reverseParentheses(string s) { stack idxStk; for (int i = 0; i 解法二 用一个额外的字符串保存括号以外的字符 这样就不用再全部翻转后再次遍历字符串了 class Solution { public: string reverseParentheses(string s) { stack idxStk; string str; for (int i = 0; i 解法三 用栈来存储除括号以外的字符, 这样不用记录括号下标, 遇到括号就把字符和字符翻转处理好. class Solution { public: string reverseParentheses(string s) { stack stk; string str; for (auto &ch : s) { if (ch == '(') { stk.push(str); str = \"\"; } else if (ch == ')') { reverse(str.begin(), str.end()); str = stk.top() + str; stk.pop(); } else { str.push_back(ch); } } return str; } }; 解法四 预处理括号, 这样就不用翻转多次字符串, 仅仅只需要遍历一次字符串就可以全部处理翻转, 效率很高 第一步我们向右移动到左括号，此时我们跳跃到该左括号对应的右括号（进入了更深一层）； 第二到第三步我们在括号内部向左移动（完成了更深层的遍历）； 第四步我们向左移动到左括号，此时我们跳跃到该左括号对应的右括号（返回到上一层）； 第五步我们在括号外向右移动（继续遍历）。 读者们可以自行尝试模拟两层乃至多层括号嵌套的移动方案，规律可以从当前的单层括号中总结出来。 假设我们沿着某个方向移动，此时遇到了括号，那么我们只需要首先跳跃到该括号对应的另一个括号所在处，然后改变我们的移动方向即可。这个方案同时适用于遍历时进入更深一层，以及完成当前层的遍历后返回到上一层的方案。 在实际代码中，我们需要预处理出每一个括号对应的另一个括号所在的位置，这一部分我们可以使用栈解决。当我们预处理完成后，即可在线性时间内完成遍历，遍历的字符串顺序即为反转后的字符串。 class Solution { public: string reverseParentheses(string s) { int n = s.length(); vector pair(n); stack stk; for (int i = 0; i Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-25 18:31:45 "},"docs/leetcode/1201-1300/":{"url":"docs/leetcode/1201-1300/","title":"1201~1300","keywords":"","body":"题目目录题目目录 Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-25 18:31:45 "},"docs/leetcode/1201-1300/1269.html":{"url":"docs/leetcode/1201-1300/1269.html","title":"1269. 停在原地的方案数","keywords":"","body":"停在原地的方案数(困难)解法一停在原地的方案数(困难) 有一个长度为 arrLen 的数组，开始有一个指针在索引 0 处。 每一步操作中，你可以将指针向左或向右移动 1 步，或者停在原地（指针不能被移动到数组范围外）。 给你两个整数 steps 和 arrLen ，请你计算并返回：在恰好执行 steps 次操作以后，指针仍然指向索引 0 处的方案数。 由于答案可能会很大，请返回方案数 模 10^9 + 7 后的结果。 示例 1： 输入：steps = 3, arrLen = 2 输出：4 解释：3 步后，总共有 4 种不同的方法可以停在索引 0 处。 向右，向左，不动 不动，向右，向左 向右，不动，向左 不动，不动，不动 示例 2： 输入：steps = 2, arrLen = 4 输出：2 解释：2 步后，总共有 2 种不同的方法可以停在索引 0 处。 向右，向左 不动，不动 示例 3： 输入：steps = 4, arrLen = 2 输出：8 提示： 1 1 解法一 动态规划 假设在行走 i 步时在下标为 j 位置有的方法数为 k[i][j] k[i][j] 可以由以下三种方法消耗一步得到 待在不动: k[i - 1][j] 从j的前一个位置过来: k[i - 1][j - 1] 从j的后一个位置过来: k[i - 1][j + 1] 但在过程中需要注意临界值 只有 j > 0 时才能由 j 前边一个位置移动过来 只有 j 时, 才能由 j 后面一个位置移动过来 最大步数和数组最大长度, 取它们的较小者 class Solution { public: int numWays(int steps, int arrLen) { const int MODULO = 1000000007; int s = min(steps, arrLen - 1); vector > k(steps + 1, vector(s + 1)); k[0][0] = 1; for (int i = 1; i 0) { k[i][j] = (k[i][j] + k[i - 1][j - 1]) % MODULO; } if (j Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-25 18:31:45 "},"docs/leetcode/1301-1400/1337.html":{"url":"docs/leetcode/1301-1400/1337.html","title":"1337.矩阵中战斗力最弱的K行","keywords":"","body":"矩阵中战斗力最弱的 K 行(简单)解法一解法二解法三矩阵中战斗力最弱的 K 行(简单) 给你一个大小为 m * n 的矩阵 mat，矩阵由若干军人和平民组成，分别用 1 和 0 表示。 请你返回矩阵中战斗力最弱的 k 行的索引，按从最弱到最强排序。 如果第 i 行的军人数量少于第 j 行，或者两行军人数量相同但 i 小于 j，那么我们认为第 i 行的战斗力比第 j 行弱。 军人 总是 排在一行中的靠前位置，也就是说 1 总是出现在 0 之前。 示例 1： 输入：mat = [[1,1,0,0,0], [1,1,1,1,0], [1,0,0,0,0], [1,1,0,0,0], [1,1,1,1,1]], k = 3 输出：[2,0,3] 解释： 每行中的军人数目： 行 0 -> 2 行 1 -> 4 行 2 -> 1 行 3 -> 2 行 4 -> 5 从最弱到最强对这些行排序后得到 [2,0,3,1,4] 示例 2： 输入：mat = [[1,0,0,0], [1,1,1,1], [1,0,0,0], [1,0,0,0]], k = 2 输出：[0,2] 解释： 每行中的军人数目： 行 0 -> 1 行 1 -> 4 行 2 -> 1 行 3 -> 1 从最弱到最强对这些行排序后得到 [0,2,3,1] 提示： m == mat.length n == mat[i].length 2 1 matrix[i][j] 不是 0 就是 1 解法一 对每一行的总战斗力进行计算, 因为军人都排在前面, 所以遇到0就可以跳出. 结果要求返回下标, 所有对战斗力总和存储时, 并把下标也保存下来, 最后在对战斗力排序, 取出前k弱的战斗力行返回. 军人都排在前面, class Solution { public: vector kWeakestRows(vector>& mat, int k) { vector ans(k); vector > result; for (int i = 0; i 解法二 使用map的有序特性, 在计算好每一行战斗力后, 直接插入map, 并把相通的战斗力保存在一个列表中. 在取出时只需要按顺序取出前k个战斗力最弱的 class Solution { public: vector kWeakestRows(vector>& mat, int k) { vector ans(k); map > result; for (int i = 0; i 解法三 题解 因为军人都在前面排列, 所以可以用二分法查找军人和平民的分界点, 后面步骤和解法一类似 class Solution { public: vector kWeakestRows(vector>& mat, int k) { int m = mat.size(), n = mat[0].size(); vector> power; for (int i = 0; i >(), move(power)); vector ans; for (int i = 0; i Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-25 18:31:45 "},"docs/leetcode/1401-1500/":{"url":"docs/leetcode/1401-1500/","title":"1401~1500","keywords":"","body":"题目目录题目目录 Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-25 18:31:45 "},"docs/leetcode/1401-1500/1418.html":{"url":"docs/leetcode/1401-1500/1418.html","title":"1418.点菜展示表","keywords":"","body":"点菜展示表(中等)解法一点菜展示表(中等) 给你一个数组 orders，表示客户在餐厅中完成的订单，确切地说， orders[i]=[customerNamei,tableNumberi,foodItemi] ，其中 customerNamei 是客户的姓名，tableNumberi 是客户所在餐桌的桌号，而 foodItemi 是客户点的餐品名称。 请你返回该餐厅的 点菜展示表 。在这张表中，表中第一行为标题，其第一列为餐桌桌号 “Table” ，后面每一列都是按字母顺序排列的餐品名称。接下来每一行中的项则表示每张餐桌订购的相应餐品数量，第一列应当填对应的桌号，后面依次填写下单的餐品数量。 注意：客户姓名不是点菜展示表的一部分。此外，表中的数据行应该按餐桌桌号升序排列。 示例 1： 输入：orders = [[\"David\",\"3\",\"Ceviche\"],[\"Corina\",\"10\",\"Beef Burrito\"],[\"David\",\"3\",\"Fried Chicken\"],[\"Carla\",\"5\",\"Water\"],[\"Carla\",\"5\",\"Ceviche\"],[\"Rous\",\"3\",\"Ceviche\"]] 输出：[[\"Table\",\"Beef Burrito\",\"Ceviche\",\"Fried Chicken\",\"Water\"],[\"3\",\"0\",\"2\",\"1\",\"0\"],[\"5\",\"0\",\"1\",\"0\",\"1\"],[\"10\",\"1\",\"0\",\"0\",\"0\"]] 解释： 点菜展示表如下所示： Table,Beef Burrito,Ceviche,Fried Chicken,Water 3 ,0 ,2 ,1 ,0 5 ,0 ,1 ,0 ,1 10 ,1 ,0 ,0 ,0 对于餐桌 3：David 点了 \"Ceviche\" 和 \"Fried Chicken\"，而 Rous 点了 \"Ceviche\" 而餐桌 5：Carla 点了 \"Water\" 和 \"Ceviche\" 餐桌 10：Corina 点了 \"Beef Burrito\" 示例 2： 输入：orders = [[\"James\",\"12\",\"Fried Chicken\"],[\"Ratesh\",\"12\",\"Fried Chicken\"],[\"Amadeus\",\"12\",\"Fried Chicken\"],[\"Adam\",\"1\",\"Canadian Waffles\"],[\"Brianna\",\"1\",\"Canadian Waffles\"]] 输出：[[\"Table\",\"Canadian Waffles\",\"Fried Chicken\"],[\"1\",\"2\",\"0\"],[\"12\",\"0\",\"3\"]] 解释： 对于餐桌 1：Adam 和 Brianna 都点了 \"Canadian Waffles\" 而餐桌 12：James, Ratesh 和 Amadeus 都点了 \"Fried Chicken\" 示例 3： 输入：orders = [[\"Laura\",\"2\",\"Bean Burrito\"],[\"Jhon\",\"2\",\"Beef Burrito\"],[\"Melissa\",\"2\",\"Soda\"]] 输出：[[\"Table\",\"Bean Burrito\",\"Beef Burrito\",\"Soda\"],[\"2\",\"1\",\"1\",\"1\"]] 提示： 1 orders[i].length == 3 1 customerNamei 和 foodItemi 由大小写英文字母及空格字符 ' ' 组成。 tableNumberi 是 1 到 500 范围内的整数。 解法一 用一个集合存储所有的食物名称, 用一个map存储桌号和桌号上点的食物及每个食物的数量 注意按照顺序填充就可以达到点菜展示效果 class Solution { public: vector> displayTable(vector>& orders) { map > tab; set foodItems; for (const auto &order : orders) { int table = stoi(order[1]); string food = order[2]; if (tab.find(table) == tab.end()) { map tmp { { food, 1} }; tab[table] = tmp; } else { ++tab[table][food]; } foodItems.insert(food); } vector > ans { { \"Table\" } }; vector foods; for (const auto &it : foodItems) { foods.push_back(it); } ans[0].insert(ans[0].end(), foods.begin(), foods.end()); for (const auto &t : tab) { vector items { to_string(t.first) }; auto tbFoodIt = t.second.begin(); for (const auto &food : foods) { if (tbFoodIt != t.second.end() && tbFoodIt->first == food) { items.push_back(to_string(tbFoodIt->second)); ++tbFoodIt; } else { items.push_back(\"0\"); } } ans.push_back(items); } return ans; } }; Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-25 18:31:45 "},"docs/leetcode/1401-1500/1436.html":{"url":"docs/leetcode/1401-1500/1436.html","title":"1436.旅行终点站","keywords":"","body":"旅行终点站(简单)解法一旅行终点站(简单) 给你一份旅游线路图，该线路图中的旅行线路用数组 paths 表示，其中 paths[i] = [cityAi, cityBi] 表示该线路将会从 cityAi 直接前往 cityBi 。请你找出这次旅行的终点站，即没有任何可以通往其他城市的线路的城市。 题目数据保证线路图会形成一条不存在循环的线路，因此只会有一个旅行终点站。 示例 1： 输入：paths = [[\"London\",\"New York\"],[\"New York\",\"Lima\"],[\"Lima\",\"Sao Paulo\"]] 输出：\"Sao Paulo\" 解释：从 \"London\" 出发，最后抵达终点站 \"Sao Paulo\" 。本次旅行的路线是 \"London\" -> \"New York\" -> \"Lima\" -> \"Sao Paulo\" 。 示例 2： 输入：paths = [[\"B\",\"C\"],[\"D\",\"B\"],[\"C\",\"A\"]] 输出：\"A\" 解释：所有可能的线路是： \"D\" -> \"B\" -> \"C\" -> \"A\". \"B\" -> \"C\" -> \"A\". \"C\" -> \"A\". \"A\". 显然，旅行终点站是 \"A\" 。 示例 3： 输入：paths = [[\"A\",\"Z\"]] 输出：\"Z\" 提示： 1 paths[i].length == 2 1 cityAi != cityBi 所有字符串均由大小写英文字母和空格字符组成。 解法一 把所有起始地点城市都存放到hash表里面, 然后再遍历目标城市, 在hash表中如果找不到目标城市, 说明是目的地终点. class Solution { public: string destCity(vector>& paths) { unordered_set tab; for (int i = 0; i Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-25 18:31:45 "},"docs/leetcode/1401-1500/1480.html":{"url":"docs/leetcode/1401-1500/1480.html","title":"1480.一维数组的动态和","keywords":"","body":"一维数组的动态和(简单)解法一一维数组的动态和(简单) 给你一个数组 nums 。数组「动态和」的计算公式为：runningSum[i] = sum(nums[0]…nums[i]) 。 请返回 nums 的动态和。 示例 1： 输入：nums = [1,2,3,4] 输出：[1,3,6,10] 解释：动态和计算过程为 [1, 1+2, 1+2+3, 1+2+3+4] 。 示例 2： 输入：nums = [1,1,1,1,1] 输出：[1,2,3,4,5] 解释：动态和计算过程为 [1, 1+1, 1+1+1, 1+1+1+1, 1+1+1+1+1] 。 示例 3： 输入：nums = [3,1,2,10,1] 输出：[3,4,6,16,17] 提示： 1 -10^6 解法一 前缀和 题目的动态和就是前缀和，直接求前缀和放入ans中就是最终结果。 class Solution { public: vector runningSum(vector& nums) { vector ans(nums.size()); ans[0] = nums[0]; for (int i = 1; i 优化 看了题解，发现可以使用传入的数组原地修改，这样可以把空间复杂度降到 O(1)。 class Solution { public: vector runningSum(vector& nums) { for (int i = 1; i Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-28 10:03:31 "},"docs/leetcode/1501-1600/":{"url":"docs/leetcode/1501-1600/","title":"1501~1600","keywords":"","body":"题目目录题目目录 Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-25 18:31:45 "},"docs/leetcode/1501-1600/1513.html":{"url":"docs/leetcode/1501-1600/1513.html","title":"1513.仅含1的子串数","keywords":"","body":"仅含1的子串数(中等)解法一解法二仅含1的子串数(中等) 给你一个二进制字符串 s（仅由 '0' 和 '1' 组成的字符串）。 返回所有字符都为 1 的子字符串的数目。 由于答案可能很大，请你将它对 10^9 + 7 取模后返回。 示例 1： 输入：s = \"0110111\" 输出：9 解释：共有 9 个子字符串仅由 '1' 组成 \"1\" -> 5 次 \"11\" -> 3 次 \"111\" -> 1 次 示例 2： 输入：s = \"101\" 输出：2 解释：子字符串 \"1\" 在 s 中共出现 2 次 示例 3： 输入：s = \"111111\" 输出：21 解释：每个子字符串都仅由 '1' 组成 示例 4： 输入：s = \"000\" 输出：0 提示： s[i] == '0' 或 s[i] == '1' 1 解法一 dfs, 超出时间限制 寻找所有的子串, 检查子串是否符合条件 对于已经符合条件的子串, 那么再dfs一层, 只需要检查最后一个push进去的字符是否为1即可 class Solution { public: const int MOD = 1000000000 + 7; public: int numSub(string s) { int ans = 0; for (int i = 0; i 解法二 通过题解理解 条件是子串中必须都是1, 只要子串中有个一个 0, 那就不符合题意 对于一个长度为 n 的符合条件的子串, 那么就有该子串的子串有 包含一个 1 的子串有 n 个 包含2个 1 的子串有 n - 1 个 包含3个 1 的子串有 n - 2 个 ... ... 包含 n 个 1 的子串有 1 个 对于该长度为 n 的全为1的子串, 一共有 1 + 2 + ... ... + n - 1 + n 个符合条件的子串. 既 (n + 1) * n / 2 个符合条件的子串 class Solution { public: const int MOD = 1000000000 + 7; public: int numSub(string s) { long long int ans = 0; int p = 0; long long int cnt = 0; while (p 或另一个简洁版代码版本 class Solution { public: const int MOD = 1000000000 + 7; public: int numSub(string s) { int ans = 0; int cnt = 0; for (const auto &ch : s) { if (ch == '1') { ++cnt; ans = (ans + cnt) % MOD; } else { cnt = 0; } } return ans; } }; Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-25 18:31:45 "},"docs/leetcode/1501-1600/1518.html":{"url":"docs/leetcode/1501-1600/1518.html","title":"1518.换酒问题","keywords":"","body":"换酒问题(简单)解法一解法二换酒问题(简单) 小区便利店正在促销，用 numExchange 个空酒瓶可以兑换一瓶新酒。你购入了 numBottles 瓶酒。 如果喝掉了酒瓶中的酒，那么酒瓶就会变成空的。 请你计算 最多 能喝到多少瓶酒。 示例 1： 输入：numBottles = 9, numExchange = 3 输出：13 解释：你可以用 3 个空酒瓶兑换 1 瓶酒。 所以最多能喝到 9 + 3 + 1 = 13 瓶酒。 示例 2： 输入：numBottles = 15, numExchange = 4 输出：19 解释：你可以用 4 个空酒瓶兑换 1 瓶酒。 所以最多能喝到 15 + 3 + 1 = 19 瓶酒。 示例 3： 输入：numBottles = 5, numExchange = 5 输出：6 示例 4： 输入：numBottles = 2, numExchange = 3 输出：2 提示： 1 2 解法一 模拟换酒的过程 记录当前的酒和总的喝过的酒瓶子 当前的酒就是买的酒的数量 空瓶子数量就是当前酒数量和没有换掉的空瓶子数量和 class Solution { public: int numWaterBottles(int numBottles, int numExchange) { int emptyBottles = numBottles; int sumDrink = 0; int currBottles = numBottles; while (currBottles) { sumDrink += currBottles; currBottles = emptyBottles / numExchange; emptyBottles = emptyBottles % numExchange + currBottles; } return sumDrink; } }; 解法二 数学方法 一瓶酒 = 一瓶液体 + 一个空瓶 而 numExchange 个空瓶可以换一瓶酒, 所以一瓶液体的价值就是 numExchange - 1 个空瓶 那么 numBottles 酒的总价值: numBottles * numExchange 喝多少瓶酒其实就是喝了多少瓶液体, 拿总价值除以一瓶液体的价值, 就是喝了多少瓶液体 但考虑到价值不注意换取一瓶酒时, 是不能列入计算里面的. class Solution { public: int numWaterBottles(int numBottles, int numExchange) { return numBottles * numExchange - 1 / (numExchange - 1); } }; Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-25 18:31:45 "},"docs/leetcode/1501-1600/1551.html":{"url":"docs/leetcode/1501-1600/1551.html","title":"1551.使数组中所有元素相等的最小操作数","keywords":"","body":"使数组中所有元素相等的最小操作数(中等)解法一使数组中所有元素相等的最小操作数(中等) 存在一个长度为 n 的数组 arr ，其中 arr[i] = (2 * i) + 1 ( 0 。 一次操作中，你可以选出两个下标，记作 x 和 y ( 0 并使 arr[x] 减去 1 、arr[y] 加上 1 （即 arr[x] -=1 且 arr[y] += 1 ）。最终的目标是使数组中的所有元素都 相等 。题目测试用例将会 保证 ：在执行若干步操作后，数组中的所有元素最终可以全部相等。 给你一个整数 n，即数组的长度。请你返回使数组 arr 中所有元素相等所需的 最小操作数 。 示例 1： 输入：n = 3 输出：2 解释：arr = [1, 3, 5] 第一次操作选出 x = 2 和 y = 0，使数组变为 [2, 3, 4] 第二次操作继续选出 x = 2 和 y = 0，数组将会变成 [3, 3, 3] 示例 2： 输入：n = 6 输出：9 提示： 1 解法一 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16 0, 1, 2, 4, 6, 9, 12, 16, 20, 25, 30, 36, 42, 49, 56, 64 [1, 3, 5, 7, 9, 11, 13, 15, 17] 当我写出来一串数字后, 发现这很有规律的, 当n为偶数时, 最小操作数就是 (n / 2) ^ 2, 当n为奇数时, 最小操作数是: ((n + 1) / 2) ^ 2 - (n + 1) / 2 化简后就是 偶数: (n / 2) ^ 2奇数: (n ^ 2 - 1) / 4 class Solution { public: int minOperations(int n) { if (n == 0 || n == 1) { return 0; } if (n % 2) { return (pow(n, 2) - 1) / 4; } else { return pow(n / 2, 2); } } }; 优化 上面的两个式子可以再化简 偶数: (n ^ 2) / 4奇数: (n ^ 2) / 4 - 1 / 4 在cpp中 1 / 4 就是 0, 所以最后是奇数和偶数是一样的 class Solution { public: int minOperations(int n) { return (n * n) >> 2; } }; Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-25 18:31:45 "},"docs/leetcode/1501-1600/1567.html":{"url":"docs/leetcode/1501-1600/1567.html","title":"1567.乘积为正数的最长子数组长度","keywords":"","body":"乘积为正数的最长子数组长度(中等)解法一乘积为正数的最长子数组长度(中等) 给你一个整数数组 nums ，请你求出乘积为正数的最长子数组的长度。 一个数组的子数组是由原数组中零个或者更多个连续数字组成的数组。 请你返回乘积为正数的最长子数组长度。 示例 1： 输入：nums = [1,-2,-3,4] 输出：4 解释：数组本身乘积就是正数，值为 24 。 示例 2： 输入：nums = [0,1,-2,-3,-4] 输出：3 解释：最长乘积为正数的子数组为 [1,-2,-3] ，乘积为 6 。 注意，我们不能把 0 也包括到子数组中，因为这样乘积为 0 ，不是正数。 示例 3： 输入：nums = [-1,-2,-3,0,1] 输出：2 解释：乘积为正数的最长子数组是 [-1,-2] 或者 [-2,-3] 。 示例 4： 输入：nums = [-1,2] 输出：1 示例 5： 输入：nums = [1,2,3,5,-6,4,0,10] 输出：4 提示： 1 -10^9 解法一 这种题一般都会让我想到动态规划 乘一个负数会牵扯到正负值 这里用两个数组来存储, 一个(positive)用来存储正数的最长子数组的长度, 另一个(negative)用来存储负数的最长子数组的长度 如果 nums[i] 为正数, 那么: positive[i] = positive[i - 1] + 1negative[i] = negative[i - 1] + 1 但要考虑到 负数本来是空的, 没有一个负数的情况下, 拥有正数的情况下依然不是负的, 所以: negative[i] = negative[i - 1] > 0 ? negative[i - 1] + 1 : 0 如果 nums[i] 为负数, 那么: 正数里面需要从正数和负数中取最大值 positive[i] = negative[i - 1] > 0 ? negative[i - 1] + 1 : 0;negative[i] = positive[i - 1] + 1; 遇到0的情况下, 那么两个都要设置为0 class Solution { public: int getMaxLen(vector& nums) { vector positive(nums.size()); vector negative(nums.size()); positive[0] = nums[0] > 0 ? 1 : 0; negative[0] = nums[0] 0) { positive[i] = positive[i - 1] + 1; negative[i] = negative[i - 1] > 0 ? negative[i - 1] + 1 : 0; } else if (nums[i] 0 ? negative[i - 1] + 1 : 0; negative[i] = positive[i - 1] + 1; } else { positive[i] = 0; negative[i] = 0; } maxlen = maxlen > positive[i] ? maxlen : positive[i]; } return maxlen; } }; Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-25 18:31:45 "},"docs/leetcode/1501-1600/1583.html":{"url":"docs/leetcode/1501-1600/1583.html","title":"1583.统计不开心的朋友","keywords":"","body":"统计不开心的朋友(中等)解法一统计不开心的朋友(中等) 给你一份 n 位朋友的亲近程度列表，其中 n 总是 偶数 。 对每位朋友 i，preferences[i] 包含一份 按亲近程度从高到低排列 的朋友列表。换句话说，排在列表前面的朋友与 i 的亲近程度比排在列表后面的朋友更高。每个列表中的朋友均以 0 到 n-1 之间的整数表示。 所有的朋友被分成几对，配对情况以列表 pairs 给出，其中 pairs[i] = [xi, yi] 表示 xi 与 yi 配对，且 yi 与 xi 配对。 但是，这样的配对情况可能会是其中部分朋友感到不开心。在 x 与 y 配对且 u 与 v 配对的情况下，如果同时满足下述两个条件，x 就会不开心： x 与 u 的亲近程度胜过 x 与 y，且 u 与 x 的亲近程度胜过 u 与 v 返回 不开心的朋友的数目 。 示例 1： 输入：n = 4, preferences = [[1, 2, 3], [3, 2, 0], [3, 1, 0], [1, 2, 0]], pairs = [[0, 1], [2, 3]] 输出：2 解释： 朋友 1 不开心，因为： - 1 与 0 配对，但 1 与 3 的亲近程度比 1 与 0 高，且 - 3 与 1 的亲近程度比 3 与 2 高。 朋友 3 不开心，因为： - 3 与 2 配对，但 3 与 1 的亲近程度比 3 与 2 高，且 - 1 与 3 的亲近程度比 1 与 0 高。 朋友 0 和 2 都是开心的。 示例 2： 输入：n = 2, preferences = [[1], [0]], pairs = [[1, 0]] 输出：0 解释：朋友 0 和 1 都开心。 示例 3： 输入：n = 4, preferences = [[1, 3, 2], [2, 3, 0], [1, 3, 0], [0, 2, 1]], pairs = [[1, 3], [0, 2]] 输出：4 提示： 2 n 是偶数 preferences.length == n preferences[i].length == n - 1 0 preferences[i] 不包含 i preferences[i] 中的所有值都是独一无二的 pairs.length == n/2 pairs[i].length == 2 xi != yi 0 每位朋友都 恰好 被包含在一对中 解法一 模拟 题解 class Solution { public: int unhappyFriends(int n, vector>& preferences, vector>& pairs) { vector > score(n, vector(n)); for (int i = 0; i match(n); for (auto &pr : pairs) { match[pr[0]] = pr[1]; match[pr[1]] = pr[0]; } int ans = 0; for (int x = 0; x Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-25 18:31:45 "},"docs/leetcode/1501-1600/1588.html":{"url":"docs/leetcode/1501-1600/1588.html","title":"1588.所有奇数长度子数组的和","keywords":"","body":"所有奇数长度子数组的和(简单)解法一解法二所有奇数长度子数组的和(简单) 给你一个正整数数组 arr ，请你计算所有可能的奇数长度子数组的和。 子数组 定义为原数组中的一个连续子序列。 请你返回 arr 中 有奇数长度子数组的和 。 示例 1： 输入：arr = [1,4,2,5,3] 输出：58 解释：所有奇数长度子数组和它们的和为： [1] = 1 [4] = 4 [2] = 2 [5] = 5 [3] = 3 [1,4,2] = 7 [4,2,5] = 11 [2,5,3] = 10 [1,4,2,5,3] = 15 我们将所有值求和得到 1 + 4 + 2 + 5 + 3 + 7 + 11 + 10 + 15 = 58 示例 2： 输入：arr = [1,2] 输出：3 解释：总共只有 2 个长度为奇数的子数组，[1] 和 [2]。它们的和为 3 。 示例 3： 输入：arr = [10,11,12] 输出：66 提示： 1 1 解法一 暴力法，模拟每个奇数数组进行逐个计算。 class Solution { public: int sumOddLengthSubarrays(vector& arr) { int ans = 0; for (int step = 1; step 解法二 在解法一的基础上，不在每次循环计算和，而是使用前缀和来快速计算出和。 class Solution { public: int sumOddLengthSubarrays(vector& arr) { int n = arr.size(); vector preSum(n + 1); preSum[0] = 0; for (int i = 0; i Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-29 10:18:35 "},"docs/leetcode/1601-1700/":{"url":"docs/leetcode/1601-1700/","title":"1601~1700","keywords":"","body":"题目目录题目目录 Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-25 18:31:45 "},"docs/leetcode/1601-1700/1646.html":{"url":"docs/leetcode/1601-1700/1646.html","title":"1646.获取生成数组中的最大值","keywords":"","body":"获取生成数组中的最大值(简单)解法一获取生成数组中的最大值(简单) 给你一个整数 n 。按下述规则生成一个长度为 n + 1 的数组 nums ： nums[0] = 0 nums[1] = 1 当 2 时，nums[2 * i] = nums[i] 当 2 时，nums[2 * i + 1] = nums[i] + nums[i + 1] 返回生成数组 nums 中的 最大 值。 示例 1： 输入：n = 7 输出：3 解释：根据规则： nums[0] = 0 nums[1] = 1 nums[(1 * 2) = 2] = nums[1] = 1 nums[(1 * 2) + 1 = 3] = nums[1] + nums[2] = 1 + 1 = 2 nums[(2 * 2) = 4] = nums[2] = 1 nums[(2 * 2) + 1 = 5] = nums[2] + nums[3] = 1 + 2 = 3 nums[(3 * 2) = 6] = nums[3] = 2 nums[(3 * 2) + 1 = 7] = nums[3] + nums[4] = 2 + 1 = 3 因此，nums = [0,1,1,2,1,3,2,3]，最大值 3 示例 2： 输入：n = 2 输出：1 解释：根据规则，nums[0]、nums[1] 和 nums[2] 之中的最大值是 1 示例 3： 输入：n = 3 输出：2 解释：根据规则，nums[0]、nums[1]、nums[2] 和 nums[3] 之中的最大值是 2 提示： 0 解法一 模拟 class Solution { public: int getMaximumGenerated(int n) { if (n nums(n + 1); nums[0] = 0; nums[1] = 1; for (int i = 2; i Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-25 18:31:45 "},"docs/leetcode/1601-1700/1652.html":{"url":"docs/leetcode/1601-1700/1652.html","title":"1652.拆炸弹","keywords":"","body":"拆炸弹(简单)解法一拆炸弹(简单) 你有一个炸弹需要拆除，时间紧迫！你的情报员会给你一个长度为 n 的 循环 数组 code 以及一个密钥 k 。 为了获得正确的密码，你需要替换掉每一个数字。所有数字会 同时 被替换。 如果 k > 0 ，将第 i 个数字用 接下来 k 个数字之和替换。 如果 k ，将第 i 个数字用 之前 k 个数字之和替换。 如果 k == 0 ，将第 i 个数字用 0 替换。 由于 code 是循环的， code[n-1] 下一个元素是 code[0] ，且 code[0] 前一个元素是 code[n-1] 。 给你 循环 数组 code 和整数密钥 k ，请你返回解密后的结果来拆除炸弹！ 示例 1： 输入：code = [5,7,1,4], k = 3 输出：[12,10,16,13] 解释：每个数字都被接下来 3 个数字之和替换。解密后的密码为 [7+1+4, 1+4+5, 4+5+7, 5+7+1]。注意到数组是循环连接的。 示例 2： 输入：code = [1,2,3,4], k = 0 输出：[0,0,0,0] 解释：当 k 为 0 时，所有数字都被 0 替换。 示例 3： 输入：code = [2,4,9,3], k = -2 输出：[12,5,6,13] 解释：解密后的密码为 [3+9, 2+3, 4+2, 9+4] 。注意到数组是循环连接的。如果 k 是负数，那么和为 之前 的数字。 提示： n == code.length 1 1 -(n - 1) 解法一 分三种情况 k为0的时候, 就全部赋值为0 k大于0的时候, 就往后取k个值求和, 需要注意数组循环, 用取余的方式来循环 k小于0的时候, 就往前取k个值求和, 同时也需要数组循环 class Solution { public: vector decrypt(vector& code, int k) { int n = code.size(); vector res(n); for (int i = 0; i 0) { for (int j = 1; j Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-25 18:31:45 "},"docs/leetcode/1701-1800/":{"url":"docs/leetcode/1701-1800/","title":"1701~1800","keywords":"","body":"题目目录题目目录 Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-25 18:31:45 "},"docs/leetcode/1701-1800/1744.html":{"url":"docs/leetcode/1701-1800/1744.html","title":"1744.你能在你最喜欢的那天吃到你最喜欢的糖果吗？","keywords":"","body":"你能在你最喜欢的那天吃到你最喜欢的糖果吗(中等)解法一解法二你能在你最喜欢的那天吃到你最喜欢的糖果吗(中等) 给你一个下标从 0 开始的正整数数组 candiesCount ，其中 candiesCount[i] 表示你拥有的第 i 类糖果的数目。同时给你一个二维数组 queries ，其中 queries[i] = [favoriteTypei, favoriteDayi, dailyCapi] 。 你按照如下规则进行一场游戏： 你从第 0 天开始吃糖果。 你在吃完 所有 第 i - 1 类糖果之前，不能 吃任何一颗第 i 类糖果。 在吃完所有糖果之前，你必须每天 至少 吃 一颗 糖果。 请你构建一个布尔型数组 answer ，满足 answer.length == queries.length 。answer[i] 为 true 的条件是：在每天吃 不超过 dailyCapi 颗糖果的前提下，你可以在第 favoriteDayi 天吃到第 favoriteTypei 类糖果；否则 answer[i] 为 false 。注意，只要满足上面 3 条规则中的第二条规则，你就可以在同一天吃不同类型的糖果。 请你返回得到的数组 answer 。 示例 1： 输入：candiesCount = [7,4,5,3,8], queries = [[0,2,2],[4,2,4],[2,13,1000000000]] 输出：[true,false,true] 提示： 1- 在第 0 天吃 2 颗糖果(类型 0），第 1 天吃 2 颗糖果（类型 0），第 2 天你可以吃到类型 0 的糖果。 2- 每天你最多吃 4 颗糖果。即使第 0 天吃 4 颗糖果（类型 0），第 1 天吃 4 颗糖果（类型 0 和类型 1），你也没办法在第 2 天吃到类型 4 的糖果。换言之，你没法在每天吃 4 颗糖果的限制下在第 2 天吃到第 4 类糖果。 3- 如果你每天吃 1 颗糖果，你可以在第 13 天吃到类型 2 的糖果。 示例 2： 输入：candiesCount = [5,2,6,4,1], queries = [[3,1,2],[4,10,3],[3,10,100],[4,100,30],[1,3,1]] 输出：[false,true,true,false,false] 提示： 1 1 1 queries[i].length == 3 0 0 1 解法一 保存前缀和 如果 favoriteDayi 天 也多于 favoriteTypei 类型糖果的前缀和, 那么就无法 favoriteDayi 天吃到 favoriteTypei 的糖果 如果 (favoriteDayi + 1) * dailyCapi 小于 favoriteTypei 类型糖果的前缀和, 那么即使每天吃最大值, 也吃不到 favoriteTypei 的糖果 而其他情况是可以吃到糖果的. class Solution { public: vector canEat(vector& candiesCount, vector>& queries) { vector answer(queries.size()); vector result(candiesCount.size() + 1, 0); for (int i = 0; i = result[q[0] + 1]) { answer[i] = false; } else { answer[i] = true; } } return answer; } }; 解法二 题解 对于第 i 个询问 `(favoriteTypei, favoriteDayi ,dailyCapi)，我们每天至少吃 1 颗糖果，至多吃 dailyCapi 颗糖果，因此我们吃的糖果的数量落在区间： [ favoriteDayi + 1,(favoriteDayi + 1) * dailyCapi ] 那么只要这个区间包含了一颗第 favoriteTypei 种类型的糖果，就可以满足要求了。 因此我们求出糖果数量的前缀和，记录在数组 sum 中，那么第 ifavoriteType 种类型的糖果对应的编号范围为： [ sum favoriteTypei - 1 ] + 1, sum [ favoriteTypei ] ] 特别地，如果 favoriteTypei 为 0，那么区间的左端点为 1。 我们只要判断这两个区间是否有交集即可。如果有交集，说明我们可以吃到第 favoriteTypei 类的糖果。 class Solution { private: using LL = long long; public: vector canEat(vector& candiesCount, vector>& queries) { int n = candiesCount.size(); // 前缀和 vector sum(n); sum[0] = candiesCount[0]; for (int i = 1; i ans; for (const auto& q: queries) { int favoriteType = q[0], favoriteDay = q[1], dailyCap = q[2]; LL x1 = favoriteDay + 1; LL y1 = (LL)(favoriteDay + 1) * dailyCap; LL x2 = (favoriteType == 0 ? 1 : sum[favoriteType - 1] + 1); LL y2 = sum[favoriteType]; ans.push_back(!(x1 > y2 || y1 Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-25 18:31:45 "},"docs/leetcode/1801-1900/":{"url":"docs/leetcode/1801-1900/","title":"1801~1900","keywords":"","body":"题目目录题目目录 Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-25 18:31:45 "},"docs/leetcode/1101-1200/1818.html":{"url":"docs/leetcode/1101-1200/1818.html","title":"1818.绝对差值和","keywords":"","body":"绝对差值和(中等)解法一绝对差值和(中等) 给你两个正整数数组 nums1 和 nums2 ，数组的长度都是 n 。 数组 nums1 和 nums2 的 绝对差值和 定义为所有 |nums1[i] - nums2[i]|(0 的 总和（下标从 0 开始）。 你可以选用 nums1 中的 任意一个 元素来替换 nums1 中的 至多 一个元素，以 最小化 绝对差值和。 在替换数组 nums1 中最多一个元素 之后 ，返回最小绝对差值和。因为答案可能很大，所以需要对 10^9 + 7 取余 后返回。 |x| 定义为： 如果 x >= 0 ，值为 x ，或者 如果 x ，值为 -x 示例 1： 输入：nums1 = [1,7,5], nums2 = [2,3,5] 输出：3 解释：有两种可能的最优方案： - 将第二个元素替换为第一个元素：[1,7,5] => [1,1,5] ，或者 - 将第二个元素替换为第三个元素：[1,7,5] => [1,5,5] 两种方案的绝对差值和都是 |1-2| + (|1-3| 或者 |5-3|) + |5-5| = 3 示例 2： 输入：nums1 = [2,4,6,8,10], nums2 = [2,4,6,8,10] 输出：0 解释：nums1 和 nums2 相等，所以不用替换元素。绝对差值和为 0 示例 3： 输入：nums1 = [1,10,4,4,2,7], nums2 = [9,3,5,1,7,4] 输出：20 解释：将第一个元素替换为第二个元素：[1,10,4,4,2,7] => [10,10,4,4,2,7] 绝对差值和为 |10-9| + |10-3| + |4-5| + |4-1| + |2-7| + |7-4| = 20 提示： n == nums1.length n == nums2.length 1 1 解法一 题解 class Solution { public: static constexpr int mod = 1000 * 1000 * 1000 + 7; int minAbsoluteSumDiff(vector& nums1, vector& nums2) { int maxDiff = 0; int n = nums1.size(); int sum = 0; vector rec(nums1); sort(rec.begin(), rec.end()); for (int i = 0; i 0) { maxDiff = max(maxDiff, diff - (nums2[i] - rec[j - 1])); } } return (sum - maxDiff + mod) % mod; } }; Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-25 18:31:45 "},"docs/leetcode/1801-1900/1838.html":{"url":"docs/leetcode/1801-1900/1838.html","title":"1838.最高频元素的频数","keywords":"","body":"最高频元素的频数(中等)解法一最高频元素的频数(中等) 元素的 频数 是该元素在一个数组中出现的次数。 给你一个整数数组 nums 和一个整数 k 。在一步操作中，你可以选择 nums 的一个下标，并将该下标对应元素的值增加 1 。 执行最多 k 次操作后，返回数组中最高频元素的 最大可能频数 。 示例 1： 输入：nums = [1,2,4], k = 5 输出：3 解释：对第一个元素执行 3 次递增操作，对第二个元素执 2 次递增操作，此时 nums = [4,4,4] 。 4 是数组中最高频元素，频数是 3 。 示例 2： 输入：nums = [1,4,8,13], k = 5 输出：2 解释：存在多种最优解决方案： - 对第一个元素执行 3 次递增操作，此时 nums = [4,4,8,13] 。4 是数组中最高频元素，频数是 2 。 - 对第二个元素执行 4 次递增操作，此时 nums = [1,8,8,13] 。8 是数组中最高频元素，频数是 2 。 - 对第三个元素执行 5 次递增操作，此时 nums = [1,4,13,13] 。13 是数组中最高频元素，频数是 2 。 示例 3： 输入：nums = [3,9,6], k = 2 输出：1 提示： 1 1 1 解法一 看了题解的思路之后才有了思路 先排序, 然后从小到大使用滑动窗口, 用 l 和 r 来记录滑动窗口的左边界和右边界值, 当当前记录的操作步数小于0时, 说明滑动窗口内部的数不能满足在k操作次数下达到全部相等的条件, 所以此时需要移动左边界, 缩小窗口, 如果当前操作步数仍大于0, 说明还可以继续增大滑动窗口, 来容纳更多的相同的值. class Solution { public: int maxFrequency(vector& nums, int k) { sort(nums.begin(), nums.end()); int maxFreq = 1; long long currk = k; int l = 0; int r = 1; while (r 另一种写法 class Solution { public: int maxFrequency(vector& nums, int k) { sort(nums.begin(), nums.end()); int maxFreq = 1; long long currk = k; int l = 0; int r = 1; while (r = 0) { currk -= diff; ++r; maxFreq = max(maxFreq, r - l); } else { // 因为diff没有被currk计算进来，所以这里要用r - 1位置的数字做操作次数的差值计算 currk = currk + nums[r - 1] - nums[l]; ++l; } } return maxFreq; } }; Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-25 18:31:45 "},"docs/leetcode/1801-1900/1877.html":{"url":"docs/leetcode/1801-1900/1877.html","title":"1877.数组中最大对数和的最小值","keywords":"","body":"数组中最大对数和的最小值(中等)解法一数组中最大对数和的最小值(中等) 一个数对 (a,b) 的 数对和 等于 a + b 。最大数对和 是一个数对数组中最大的 数对和 。 比方说，如果我们有数对 (1,5) ，(2,3) 和 (4,4)，最大数对和 为 max(1+5, 2+3, 4+4) = max(6, 5, 8) = 8 。给你一个长度为 偶数 n 的数组 nums ，请你将 nums 中的元素分成 n / 2 个数对，使得： nums 中每个元素 恰好 在 一个 数对中，且 最大数对和 的值 最小 。 请你在最优数对划分的方案下，返回最小的 最大数对和 。 示例 1： 输入：nums = [3,5,2,3] 输出：7 解释：数组中的元素可以分为数对 (3,3) 和 (5,2) 。 最大数对和为 max(3+3, 5+2) = max(6, 7) = 7 。 示例 2： 输入：nums = [3,5,4,2,4,6] 输出：8 解释：数组中的元素可以分为数对 (3,5)，(4,4) 和 (6,2) 。 最大数对和为 max(3+5, 4+4, 6+2) = max(8, 8, 8) = 8 。 提示： n == nums.length 2 n 是 偶数 。 1 解法一 求对数和的最小值，那么数组中的最大值就要和最小值组合到一起，才能保证和最小，所以先对数组排序，从数组左右两个边界各取一个值作为一对对数，一直计算完毕所有对数，求出所有对数的最大值，就是最大对数的最小值。 class Solution { public: int minPairSum(vector& nums) { sort(nums.begin(), nums.end()); int ans = 0; int n = nums.size(); for (int i = 0; i Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-25 18:31:45 "},"docs/leetcode/1801-1900/1893.html":{"url":"docs/leetcode/1801-1900/1893.html","title":"1893.检查是否区域内所有整数都被覆盖","keywords":"","body":"检查是否区域内所有整数都被覆盖(简单)解法一解法二检查是否区域内所有整数都被覆盖(简单) 给你一个二维整数数组 ranges 和两个整数 left 和 right 。每个 ranges[i] = [starti, endi] 表示一个从 starti 到 endi 的 闭区间 。 如果闭区间 [left, right] 内每个整数都被 ranges 中 至少一个 区间覆盖，那么请你返回 true ，否则返回 false 。 已知区间 ranges[i] = [starti, endi] ，如果整数 x 满足 starti ，那么我们称整数 x 被覆盖了。 示例 1： 输入：ranges = [[1,2],[3,4],[5,6]], left = 2, right = 5 输出：true 解释：2 到 5 的每个整数都被覆盖了： - 2 被第一个区间覆盖。 - 3 和 4 被第二个区间覆盖。 - 5 被第三个区间覆盖。 示例 2： 输入：ranges = [[1,10],[10,20]], left = 21, right = 21 输出：false 解释：21 没有被任何一个区间覆盖。 提示： 1 1 1 解法一 对二维数组中的区间左边界为基准排序, 这样就可以依次寻找left和right是否在区间内覆盖了. class Solution { public: bool isCovered(vector>& ranges, int left, int right) { sort(ranges.begin(), ranges.end(), [](auto &r1, auto &r2) { return r1[0] = left) { left = range[1] + 1; } if (left > right) { return true; } } return false; } }; 解法二 差分数组 题解 class Solution { public: bool isCovered(vector>& ranges, int left, int right) { vector diff(52, 0); // 差分数组 for (auto&& range: ranges) { ++diff[range[0]]; --diff[range[1]+1]; } // 前缀和 int curr = 0; for (int i = 1; i = left && i Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-25 18:31:45 "},"docs/leetcode/jianzhioffer/":{"url":"docs/leetcode/jianzhioffer/","title":"剑指offer","keywords":"","body":"题目目录题目目录 Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-25 18:31:45 "},"docs/leetcode/jianzhioffer/38_1.html":{"url":"docs/leetcode/jianzhioffer/38_1.html","title":"38.剑指offer 38","keywords":"","body":"字符串的排列(中等)解法一字符串的排列(中等) 输入一个字符串，打印出该字符串中字符的所有排列。 你可以以任意顺序返回这个字符串数组，但里面不能有重复元素。 示例: 输入：s = \"abc\" 输出：[\"abc\",\"acb\",\"bac\",\"bca\",\"cab\",\"cba\"] 限制： 1 解法一 dfs，每次都对整个字符串遍历。 每个字符只能使用一次，在递归的时候，需要记录字符的使用状态； 在字符串中可能有重复的字符，所以用set来保存结果，达到去重的目的。 class Solution { public: vector permutation(string s) { set ans; for (int i = 0; i result; for (const auto &str : ans) { result.push_back(str); } return result; } private: void dfs(set &ans, string currStr, const string &s, int idx) { if (idx == s.size()) { ans.insert(currStr); return ; } for (int i = 0; i usedIdxs_; }; Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-25 18:31:45 "},"docs/leetcode/jianzhioffer/68_1.html":{"url":"docs/leetcode/jianzhioffer/68_1.html","title":"68-I.二叉搜索树的最近公共祖先","keywords":"","body":"二叉搜索树的最近公共祖先(简单)解法一解法二二叉搜索树的最近公共祖先(简单) 给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。 最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。” 例如，给定如下二叉搜索树: root = [6,2,8,0,4,7,9,null,null,3,5] 示例 1: 输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8 输出: 6 解释: 节点 2 和节点 8 的最近公共祖先是 6。 示例 2: 输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4 输出: 2 解释: 节点 2 和节点 4 的最近公共祖先是 2, 因为根据定义最近公共祖先节点可以为节点本身。 说明: 所有节点的值都是唯一的。 p、q 为不同节点且均存在于给定的二叉搜索树中。 解法一 身为一个二叉搜索树, 本身就是有序的 从根节点开始和两个值进行比较, 如果节点的值比两个值都大, 那么需要往节点的左节点去, 如果节点的值比两个值都小, 那么需要往节点的右边去, 否则的话就是两个值所在节点的最近共同祖先 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public: TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) { if (root == nullptr) { return nullptr; } if (root->val > p->val && root->val > q->val) return lowestCommonAncestor(root->left, p, q); if (root->val val && root->val val) return lowestCommonAncestor(root->right, p, q); return root; } }; 解法二 按照解法一的思路, 改为非递归 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public: TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) { TreeNode *node = root; while (node) { if (node->val > p->val && node->val > q->val) { node = node->left; } else if (node->val val && node->val val) { node = node->right; } else { break; } } return node; } }; Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-25 18:31:45 "},"docs/leetcode/jianzhioffer/080.html":{"url":"docs/leetcode/jianzhioffer/080.html","title":"080.含有k个元素的组合","keywords":"","body":"含有k个元素的组合(中等)解法一含有k个元素的组合(中等) 给定两个整数 n 和 k，返回 1 ... n 中所有可能的 k 个数的组合。 示例 1: 输入: n = 4, k = 2 输出: [ [2,4], [3,4], [2,3], [1,2], [1,3], [1,4], ] 示例 2: 输入: n = 1, k = 1 输出: [[1]] 提示: 1 1 解法一 常规dfs排列组合填充数组 class Solution { public: vector> combine(int n, int k) { vector > ans; vector nums(k); int idx = 0; function dfs = [&](int index) { if (idx == k) { ans.push_back(nums); return ; } for (int i = index; i Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-25 18:31:45 "},"docs/leetcode/interview/":{"url":"docs/leetcode/interview/","title":"面试题","keywords":"","body":"题目目录题目目录 Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-25 18:31:45 "},"docs/leetcode/interview/02_07.html":{"url":"docs/leetcode/interview/02_07.html","title":"02.07.链表相交","keywords":"","body":"链表相交(简单)解法一解法二解法三链表相交(简单) 给定两个（单向）链表，判定它们是否相交并返回交点。请注意相交的定义基于节点的引用，而不是基于节点的值。换句话说，如果一个链表的第k个节点与另一个链表的第j个节点是同一节点（引用完全相同），则这两个链表相交。 示例 1： 输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3 输出：Reference of the node with value = 8 输入解释：相交节点的值为 8 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。 示例 2： 输入：intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1 输出：Reference of the node with value = 2 输入解释：相交节点的值为 2 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。 示例 3： 输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2 输出：null 输入解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。 解释：这两个链表不相交，因此返回 null。 注意： 如果两个链表没有交点，返回 null 。 在返回结果后，两个链表仍须保持原有的结构。 可假定整个链表结构中没有循环。 程序尽量满足 O(n) 时间复杂度，且仅用 O(1) 内存。 解法一 暴力法, 逐一比较找到相同的节点 /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public: ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) { ListNode *pA = headA; ListNode *pB = headB; ListNode *hb = pB; while (pA ) { hb = pB; while (hb) { if (pA == hb) { return pA; } hb = hb->next; } pA = pA->next; } return nullptr; } }; 解法二 把一个链表存到hashset里面, 然后再循环另一个链表查找相同的节点 /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public: ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) { if (headA == nullptr || headB == nullptr) { return nullptr; } ListNode *pA = headA; ListNode *pB = headB; unordered_set nodeSet; while (pA) { nodeSet.insert(pA); pA = pA->next; } while (pB) { if (nodeSet.find(pB) != nodeSet.end()) { return pB; } pB = pB->next; } return nullptr; } }; 解法三 两个链表 l1 和 l2 从 l1 头到相交的距离为 a 从 l2 头到相交的距离为 b 那么就有: l1.length - a = l2.length - b 也就是: l1.length + b = l2.length + a 也就是说, p1 指针把 l1 链表走完之后再从 l2 链表头出发, p2指针把 l2 链表走完再从 l1 链表出发, 最终两个指针会在交叉点相遇 如果两个链表没有相交, 那么最终 两个指针会同时为空, 退出循环 /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public: ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) { if (headA == nullptr || headB == nullptr) { return nullptr; } ListNode *pA = headA; ListNode *pB = headB; while (pA != pB) { pA = pA != nullptr ? pA->next : headB; pB = pB != nullptr ? pB->next : headA; } return pA; } }; Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-25 18:31:45 "},"docs/leetcode/interview/03_03.html":{"url":"docs/leetcode/interview/03_03.html","title":"03.03.堆盘子","keywords":"","body":"堆盘子(中等)解法一堆盘子(中等) 堆盘子。设想有一堆盘子，堆太高可能会倒下来。因此，在现实生活中，盘子堆到一定高度时，我们就会另外堆一堆盘子。请实现数据结构 SetOfStacks，模拟这种行为。SetOfStacks 应该由多个栈组成，并且在前一个栈填满时新建一个栈。此外，SetOfStacks.push() 和 SetOfStacks.pop() 应该与普通栈的操作方法相同（也就是说，pop() 返回的值，应该跟只有一个栈时的情况一样）。 进阶：实现一个 popAt(int index) 方法，根据指定的子栈，执行 pop 操作。 当某个栈为空时，应当删除该栈。当栈中没有元素或不存在该栈时，pop，popAt 应返回 -1. 示例1: 输入： [\"StackOfPlates\", \"push\", \"push\", \"popAt\", \"pop\", \"pop\"] [[1], [1], [2], [1], [], []] 输出： [null, null, null, 2, 1, -1] 示例2: 输入： [\"StackOfPlates\", \"push\", \"push\", \"push\", \"popAt\", \"popAt\", \"popAt\"] [[2], [1], [2], [3], [0], [0], [0]] 输出： [null, null, null, null, 2, 1, 3] 解法一 用一个数组装所有的栈, 过程中需要判断数组空, 栈空的临界条件, 异界一些越的条件. class StackOfPlates { public: StackOfPlates(int cap): cap_(cap) { size_ = 0; } void push(int val) { if (cap_ = cap_) { stks_.push_back(stack()); ++size_; } stks_[size_ - 1].push(val); } int pop() { if (size_ == 0) { return -1; } int n = stks_[size_ - 1].top(); stks_[size_ - 1].pop(); if (stks_[size_ - 1].empty()) { stks_.pop_back(); --size_; } return n; } int popAt(int index) { if (index >= size_ || size_ == 0) { return -1; } int n = stks_[index].top(); stks_[index].pop(); if (stks_[index].empty()) { stks_.erase(stks_.begin() + index); --size_; } return n; } private: int cap_; int size_; vector > stks_; }; /** * Your StackOfPlates object will be instantiated and called as such: * StackOfPlates* obj = new StackOfPlates(cap); * obj->push(val); * int param_2 = obj->pop(); * int param_3 = obj->popAt(index); */ 优化 优化代码 class StackOfPlates { public: StackOfPlates(int cap): cap_(cap) { } void push(int val) { if (cap_ = cap_) { stks_.emplace_back(stack()); } stks_.back().push(val); } int pop() { return this->popAt(stks_.size() - 1); } int popAt(int index) { if (index >= stks_.size() || stks_.empty()) { return -1; } int n = stks_[index].top(); stks_[index].pop(); if (stks_[index].empty()) { stks_.erase(stks_.begin() + index); } return n; } private: int cap_; vector > stks_; }; /** * Your StackOfPlates object will be instantiated and called as such: * StackOfPlates* obj = new StackOfPlates(cap); * obj->push(val); * int param_2 = obj->pop(); * int param_3 = obj->popAt(index); */ Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-25 18:31:45 "},"docs/leetcode/interview/03_04.html":{"url":"docs/leetcode/interview/03_04.html","title":"03.04.化栈为队","keywords":"","body":"化栈为队(简单)解法一化栈为队(简单) 实现一个MyQueue类，该类用两个栈来实现一个队列。 示例： MyQueue queue = new MyQueue(); queue.push(1); queue.push(2); queue.peek(); // 返回 1 queue.pop(); // 返回 1 queue.empty(); // 返回 false 说明： 你只能使用标准的栈操作 -- 也就是只有 push to top, peek/pop from top, size 和 is empty 操作是合法的。 你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。 假设所有操作都是有效的 （例如，一个空的队列不会调用 pop 或者 peek 操作）。 解法一 栈是后进先出, 队列是先进先出, 从一个栈倒腾到另一个栈, 那另一个栈的出栈顺序就是最开始在第一个栈的进栈顺序, 正好可以达到队列的效果 看到官方的方法后, 我就觉得我写的比较智障, 根本就不需要 pop 和 push 都swap class MyQueue { public: /** Initialize your data structure here. */ MyQueue() { } /** Push element x to the back of queue. */ void push(int x) { swap(s2_, s1_); s1_.push(x); } /** Removes the element from in front of queue and returns that element. */ int pop() { swap(s1_, s2_); int n = s2_.top(); s2_.pop(); return n; } /** Get the front element. */ int peek() { swap(s1_, s2_); return s2_.top(); } /** Returns whether the queue is empty. */ bool empty() { return s1_.empty() && s2_.empty(); } private: void swap(stack &s1, stack &s2) { while (!s1.empty()) { s2.push(s1.top()); s1.pop(); } } private: stack s1_; stack s2_; }; /** * Your MyQueue object will be instantiated and called as such: * MyQueue* obj = new MyQueue(); * obj->push(x); * int param_2 = obj->pop(); * int param_3 = obj->peek(); * bool param_4 = obj->empty(); */ 优化 仅仅在出栈的栈为空的时候才需要从进栈的栈中倒腾过来 相比于上面的方法, 少了非常多的倒腾的时间 class MyQueue { public: /** Initialize your data structure here. */ MyQueue() { } /** Push element x to the back of queue. */ void push(int x) { s1_.push(x); } /** Removes the element from in front of queue and returns that element. */ int pop() { if (s2_.empty()) { swap(s1_, s2_); } int n = s2_.top(); s2_.pop(); return n; } /** Get the front element. */ int peek() { if (s2_.empty()) { swap(s1_, s2_); } return s2_.top(); } /** Returns whether the queue is empty. */ bool empty() { return s1_.empty() && s2_.empty(); } private: void swap(stack &s1, stack &s2) { while (!s1.empty()) { s2.push(s1.top()); s1.pop(); } } private: stack s1_; stack s2_; }; /** * Your MyQueue object will be instantiated and called as such: * MyQueue* obj = new MyQueue(); * obj->push(x); * int param_2 = obj->pop(); * int param_3 = obj->peek(); * bool param_4 = obj->empty(); */ Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-25 18:31:45 "},"docs/leetcode/interview/08_01.html":{"url":"docs/leetcode/interview/08_01.html","title":"08.01.三步问题","keywords":"","body":"三步问题(简单)解法一(超时)解法二解法三三步问题(简单) 三步问题。有个小孩正在上楼梯，楼梯有n阶台阶，小孩一次可以上1阶、2阶或3阶。实现一种方法，计算小孩有多少种上楼梯的方式。结果可能很大，你需要对结果模1000000007。 示例1: 输入：n = 3 输出：4 说明: 有四种走法 示例2: 输入：n = 5 输出：13 提示: n范围在[1, 1000000]之间 解法一(超时) 递归 这道题和斐波那契, 青蛙跳等等题是一样的 第n阶台阶时, 可以从 n - 1阶, n - 2阶 n -3阶 一次过来, 很容易得到公式: `f(n) = f(n - 1) + f(n - 2) + f(n - 3); class Solution { public: int waysToStep(int n) { if (n 解法二 使用动态规划, 保存每个台阶的次数 需要保存很多值, 占用很大的内存空间 class Solution { public: int waysToStep(int n) { vector f(n 解法三 因为只需要最后的结果, 中间变量可以不保留, 只需要几个变量循环使用即可 class Solution { public: const int MOD = 1000000007; int waysToStep(int n) { if (n = 3) { dp4 = (dp1 + dp2 + dp3) % MOD; dp1 = dp2; dp2 = dp3; dp3 = dp4; } return dp4; } }; Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-25 18:31:45 "},"docs/leetcode/interview/08_14.html":{"url":"docs/leetcode/interview/08_14.html","title":"08.14.布尔运算","keywords":"","body":"布尔运算(中等)解法一布尔运算(中等) 给定一个布尔表达式和一个期望的布尔结果 result，布尔表达式由 0 (false)、1 (true)、& (AND)、 | (OR) 和 ^ (XOR) 符号组成。实现一个函数，算出有几种可使该表达式得出 result 值的括号方法。 示例 1: 输入: s = \"1^0|0|1\", result = 0 输出: 2 解释: 两种可能的括号方法是 1^(0|(0|1)) 1^((0|0)|1) 示例 2: 输入: s = \"0&0&0&1^1|0\", result = 1 输出: 10 提示： 运算符的数量不超过 19 个 解法一 题解 状态定义： dp[i][j][result=0/1]表示第i到j个数字计算结果为result的方案数。 状态转移： 枚举区间分割点，根据分割点的情况讨论左右区间计算结果，方案数增量为左右方案数相乘。 分割点为 '&':结果为0 有三种情况： 0 0, 0 1, 1 0dp[i][j][0] += dp[i][k - 1][0] dp[k + 1][j][0] + dp[i][k - 1][0] dp[k + 1][j][1] + dp[i][k - 1][1] * dp[k + 1][j][0]; 结果为1 有一种情况： 1 1dp[i][j][1] += dp[i][k - 1][1] * dp[k + 1][j][1]; 分割点为 '|':结果为0 有一种情况： 0 0dp[i][j][0] += dp[i][k - 1][0] * dp[k + 1][j][0]; 结果为1 有三种情况： 0 1, 1 0, 1 1dp[i][j][1] += dp[i][k - 1][0] dp[k + 1][j][1] + dp[i][k - 1][1] dp[k + 1][j][0] + dp[i][k - 1][1] * dp[k + 1][j][1]; 分割点为 '^':结果为0 有两种情况： 0 0, 1 1dp[i][j][0] += dp[i][k - 1][0] dp[k + 1][j][0] + dp[i][k - 1][1] dp[k + 1][j][1]; 结果为1 有两种情况： 0 1, 1 0dp[i][j][1] += dp[i][k - 1][1] dp[k + 1][j][0] + dp[i][k - 1][0] dp[k + 1][j][1]; base case： 数字位初始化为1，即dp[i][i][0/1] = 1; class Solution { public: int countEval(string s, int result) { if (s.empty()) { return 0; } if (s.size() == 1) { return s[0] - '0' == result; } int n = s.size(); vector > > dp(n + 1, vector >(n + 1, vector(2, 0))); for (int i = 0; i Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-25 18:31:45 "},"docs/leetcode/interview/10_02.html":{"url":"docs/leetcode/interview/10_02.html","title":"10.02.变位词组","keywords":"","body":"变位词组(中等)解法一解法二变位词组(中等) 编写一种方法，对字符串数组进行排序，将所有变位词组合在一起。变位词是指字母相同，但排列不同的字符串。 注意：本题相对原题稍作修改 示例: 输入: [\"eat\", \"tea\", \"tan\", \"ate\", \"nat\", \"bat\"], 输出: [ [\"ate\",\"eat\",\"tea\"], [\"nat\",\"tan\"], [\"bat\"] ] 说明： 所有输入均为小写字母。 不考虑答案输出的顺序。 解法一 想到的一个很笨的方法, 还超时了, 具体正确性没有得到验证 通过一个表来检查是否为变位词, 与变位词对应的pair的中的数组存放变位词, 外层的vector就是不同的变位词数组和表 class Solution { public: vector> groupAnagrams(vector& strs) { vector, unordered_multiset > > tabs; for (const auto &str : strs) { int tabidx = 0; for (; tabidx t; for (const auto &ch : str) { t.insert(ch); } tabs.push_back({vector({str}), t}); } } vector > ans; for (const auto &tab : tabs) { ans.push_back(tab.first); } return ans; } }; 解法二 题解 排序的方法 对字符串的字符排序后, 相等的肯定为变位词, 只需要记录排序前后的对应关系就能很好的在表中找到对应的变位词列表, 并保存下来 class Solution { public: vector> groupAnagrams(vector& strs) { unordered_map > tab; for (const auto &str : strs) { string key = str; sort(key.begin(), key.end()); auto it = tab.find(key); if (it == tab.end()) { tab.insert({key, vector({str})}); } else { it->second.emplace_back(str); } } vector > ans; for (const auto &t : tab) { ans.emplace_back(t.second); } return ans; } }; Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-25 18:31:45 "},"docs/leetcode/interview/17_10.html":{"url":"docs/leetcode/interview/17_10.html","title":"17.10.主要元素","keywords":"","body":"主要元素(简单)解法一主要元素(简单) 数组中占比超过一半的元素称之为主要元素。给你一个 整数 数组，找出其中的主要元素。若没有，返回 -1 。请设计时间复杂度为 O(N) 、空间复杂度为 O(1) 的解决方案。 示例 1： 输入：[1,2,5,9,5,9,5,5,5] 输出：5 示例 2： 输入：[3,2] 输出：-1 示例 3： 输入：[2,2,1,1,1,2,2] 输出：2 解法一 可以使用hashmap来很容易做出来, 但是题目要求空间复杂度为O(1), 这就必须另想它法. 最终还是通过看了题解得知这种解法 使用摩尔投票方法 题解 class Solution { public: int majorityElement(vector& nums) { int count = 0; int candidate = -1; for (int i = 0; i nums.size() / 2 ? candidate : -1; } }; Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-25 18:31:45 "}}