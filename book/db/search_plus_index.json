{"./":{"url":"./","title":"前言","keywords":"","body":"前言前言 数据库相关内容整合 Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-25 18:31:45 "},"docs/mysql/user.html":{"url":"docs/mysql/user.html","title":"用户","keywords":"","body":"操作用户登录数据库创建用户修改密码用户授权删除用户查询用户权限操作用户 刷新flush privileges; 登录数据库 mysql -u 用户名 -p # 回车之后输入密码 创建用户 CREATE USER 'username'@'host' IDENTIFIED BY 'password'; 示例 CREATE USER 'dog'@'localhost' IDENTIFIED BY '123456'; CREATE USER 'pig'@'192.168.1.101_' IDENTIFIED BY '123456'; CREATE USER 'pig'@'%' IDENTIFIED BY '123456'; 修改密码 use mysql; update user set authentication_string=password('新密码') where user='user'; 说明:并不是所有版本的mysql密码字段都是 authentication_string, 有的可能是 password 用户授权 GRANT privileges ON databasename.tablename TO 'username'@'host' 说明 privileges 用户的操作权限, 如 SELECT, INSERT, UPDATE 等. 如果要授予所的权限则使用ALL; databasename 数据库名 tablename 表名, 如果要授予该用户对所有数据库和表的相应操作权限则可用 * 表示, 如 *.* 示例 给pig用户增加 select 和 insert 权限到 database 数据库的 table 表, 在所有ip段的服务器 GRANT SELECT, INSERT ON database.table TO 'pig'@'%'; 给pig用户增加所有权限 GRANT ALL ON *.* TO 'pig'@'%'; 使授权的用户能够给其它用户授权 GRANT privileges ON databasename.tablename TO 'username'@'host' WITH GRANT OPTION; 删除用户 drop user '用户名'@'%'; 查询用户权限 show grants for 'user'@'localhost'; 或 show grants for user; Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-25 18:31:45 "},"docs/mysql/table.html":{"url":"docs/mysql/table.html","title":"字段和表","keywords":"","body":"字段去除主键添加字段删除字段修改字段位置修改字段类型表查看表结构复制表结构及数据到新表只复制表结构到新表复制旧表的数据到新表查看表状态库查看和使用数据库查看当前数据库的所有表字段 字段的增删查改 去除主键 alter table table_test drop primary key; 添加字段 alter table table1 add transactor varchar(10) not Null; 添加字段并设为主键 alter table table1 add id int unsigned not Null auto_increment primary key 删除字段 ALTER TABLE `table_name` DROP 字段名 修改字段位置 到第一位 alter table `table_name` modify 字段名 int(10) unsigned auto_increment first; 到某一位字段后面 alter table `table_name` modify 字段名 varchar(10) after 某一位字段; 修改字段类型 alter table 表名称 change 字段原名称 字段新名称 字段类型 [是否允许非空]; alter table 表名称 modify 字段名称 字段类型 [是否允许非空]; alter table 表名称 modify 字段名称 字段类型 [是否允许非空]; 表 查看表结构 desc `table_name`; 复制表结构及数据到新表 CREATE TABLE 新表 SELECT * FROM 旧表 只复制表结构到新表 CREATE TABLE 新表 SELECT * FROM 旧表 WHERE 1=2; 即: 让WHERE条件不成立. 复制旧表的数据到新表 旧表和新表结构一样 INSERT INTO 新表 SELECT * FROM 旧表 旧表和新表结构不一样 INSERT INTO 新表(字段1,字段2,.......) SELECT 字段1,字段2,...... FROM 旧表 查看表状态 可以查看engine数据库引擎, version, row, index等信息 show table status from db like 条件 库 查看和使用数据库 显示所有可见的数据库 show databases; 切换到 database_name 数据库 use `database_name`; 查看当前数据库的所有表 show tables; Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-25 18:31:45 "},"docs/mysql/mysql-backup.html":{"url":"docs/mysql/mysql-backup.html","title":"备份","keywords":"","body":"数据库的备份导出整个数据库导出一个表导出一个数据库结构导出数据库一个表结构数据库的导入mysqlldump导入用 source 语句数据库的备份 导出整个数据库 mysqldump -u 用户名 -p 数据库名 > 导出的文件名 示例 mysqldump -u dbadmin -p myblog > /home/user/database_bak/myblog.sql 导出一个表 mysqldump -u 用户名 -p 数据库名 表名> 导出的文件名 示例 mysqldump -u dbadmin -p myblog wp_users> /home/user/database_bak/blog_users.sql 导出一个数据库结构 mysqldump -u dbadmin -p -d --add-drop-table myblog > /home/user/database_bak/blog_struc.sql 说明 -d 没有数据 --add-drop-table 在每个create语句之前增加一个drop table 导出数据库一个表结构 mysqldump -u dbadmin -p -d --add-drop-table myblog wp_users> /home/user/database_bak/blog_users_struc.sql 说明 -d 没有数据 --add-drop-table 在每个create语句之前增加一个drop table 数据库的导入 用 mysqldump 备份出来的文件是一个可以直接倒入的 SQL 脚本, 有两种方法可以将数据导入 mysqlldump导入 /usr/local/mysql/bin/mysql -u root -p ***** myblog 说明 这种方法很容易产生乱码 导出数据库时, 你如果忘了设置导出字符集的话, 在导入的时候, 就有可能会出问题. 假如你导出时设置导出时设置了utf8的编码, 但是你又把你的数据库现在的字符集改成了gb2312的, 这样又会乱码 用 source 语句 mysql -u dbadmin -p use myblog; set names utf8; // 这里的字符集根你的将要导入的数据库的字符集一致 source /home/user/database_bak/myblog.sql; Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-25 18:31:45 "},"docs/mysql/mysql.html":{"url":"docs/mysql/mysql.html","title":"事务定时器","keywords":"","body":"事件事件开关事件示例查看事件删除事件事件的开启和停止事件 事件开关 show variables like 'event_scheduler'; // 查看状态 set global event_scheduler=on; // 打开 set global event_scheduler=off; // 关闭 事件示例 示例 开始时间2019-07-12 08:52:00每分钟执行一次 delimiter $$ create event `detect_cnt` on schedule every 1 minute starts '2019-07-12 08:52:00' on completion not preserve enable do begin ..... end $$ delimiter 查看事件 select * from mysql.event; 删除事件 drop event 事件名; 事件的开启和停止 ALTER EVENT SetEVToInvalidStatus_AtNight_0100 DISABLE; // 停止 ALTER EVENT SetEVToInvalidStatus_AtNight_0100 ENABLE; // 开启 Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-25 18:31:45 "},"docs/mysql/mysql-efficiency.html":{"url":"docs/mysql/mysql-efficiency.html","title":"30种提升sql查询效率方法","keywords":"","body":"提高SQL查询效率的30种方法提高SQL查询效率的30种方法 对查询进行优化, 应尽量避免全表扫描, 首先应考虑在 where 及 order by 涉及的列上建立索引. 应尽量避免在 where 子句中对字段进行 null 值判断, 否则将导致引擎放弃使用索引而进行全表扫描 select id from t where num is null; // 全表扫描 select id from t where num=0; // 在num上面设置默认值0, 确保num列咩有null值, 然后用等于0查询. 应尽量避免在 where 子句中使用!=或<>操作符, 否则将引擎放弃使用索引而进行全表扫描. 应尽量避免在 where 子句中使用 or 来连接条件, 否则将导致引擎放弃使用索引而进行全表扫描 select id from t where num=10 or num=20; // 全表查询 // 改为如下语句 select id from t where num=10 union all select id from t where num=20; // 使用索引 in 和 not in 也要慎用, 否则会导致全表扫描 select id from t where num in(1,2,3); select id from t where num between 1 and 3; // 对于连续的数值, 能用 between 就不要用 in 下面的查询也将导致全表扫描 select id from t where name like '%abc%'; // 若要提高效率, 可以考虑全文检索 如果在 where 子句中使用参数, 也会导致全表扫描. 因为SQL只有在运行时才会解析局部变量, 但优化程序不能将访问计划的选择推迟到运行时; 它必须在编译时进行选择. 然而, 如果在编译时建立访问计划, 变量的值还是未知的, 因而无法作为索引选择的输入项. select id from t where num=@num; // 全表扫描 // 可以改为强制查询使用索引 select id from t with(index(索引名)) where num=@num; 应尽量避免在 where 子句中对字段进行表达式操作, 这将导致引擎放弃使用索引而进行全表扫描. select id from t where num/2=100; // 全表扫描 // 应改为: select id from t where num=100*2; 应尽量避免在 where 子句中对字段进行函数操作, 这将导致引擎放弃使用索引而进行全表扫描. select id from t where substring(name,1,3)='abc'--name以abc开头的id select id from t where datediff(day,createdate,'2005-11-30')=0--‘2005-11-30’生成的id // 应改为: select id from t where name like 'abc%' select id from t where createdate>='2005-11-30' and createdate 不要在 where 子句中的 \"=\" 左边进行函数、算术运算或其他表达式运算, 否则系统将可能无法正确使用索引 在使用索引字段作为条件时, 如果该索引是复合索引, 那么必须使用到该索引中的第一个字段作为条件时才能保证系统使用该索引, 否则该索引将不会被使用, 并且应尽可能的让字段顺序与索引顺序相一致. 不要写一些没有意义的查询 // 如需要生成一个空表结构 select col1,col2 into #t from t where 1=0; // 这类代码不会返回任何结果集, 但是会消耗系统资源的. // 应改成这样: create table #t(...); 很多时候用 exists 代替 in 是一个好的选择 select num from a where num in(select num from b); // 用下面的语句替换： select num from a where exists(select 1 from b where num=a.num); 并不是所有索引对查询都有效, SQL是根据表中数据来进行查询优化的, 当索引列有大量数据重复时, SQL查询可能不会去利用索引, 如一表中有字段sex, male, female几乎各一半, 那么即使在sex上建了索引也对查询效率起不了作用 索引并不是越多越好, 索引固然可以提高相应的 select 的效率, 但同时也降低了 insert 及 update 的效率, 因为 insert 或 update 时有可能会重建索引, 所以怎样建索引需要慎重考虑, 视具体情况而定. 一个表的索引数最好不要超过6个, 若太多则应考虑一些不常使用到的列上建的索引是否有必要. 应尽可能的避免更新 clustered 索引数据列, 因为 clustered 索引数据列的顺序就是表记录的物理存储顺序, 一旦该列值改变将导致整个表记录的顺序的调整, 会耗费相当大的资源. 若应用系统需要频繁更新 clustered 索引数据列, 那么需要考虑是否应将该索引建为 clustered 索引 尽量使用数字型字段, 若只含数值信息的字段尽量不要设计为字符型, 这会降低查询和连接的性能, 并会增加存储开销. 这是因为引擎在处理查询和连接时会逐个比较字符串中每一个字符, 而对于数字型而言只需要比较一次就够了 尽可能的使用 varchar/nvarchar 代替 char/nchar, 因为首先变长字段存储空间小, 可以节省存储空间, 其次对于查询来说, 在一个相对较小的字段内搜索效率显然要高些. 任何地方都不要使用 select * from t; 用具体的字段列表代替 \"*\", 不要返回用不到的任何字段 尽量使用表变量来代替临时表. 如果表变量包含大量数据, 请注意索引非常有限(只有主键索引) 避免频繁创建和删除临时表, 以减少系统表资源的消耗. 临时表并不是不可使用, 适当地使用它们可以使某些例程更有效, 例如: 当需要重复引用大型表或常用表中的某个数据集时. 但是, 对于一次性事件, 最好使用导出表 在新建临时表时, 如果一次性插入数据量很大, 那么可以使用 select into 代替 create table, 避免造成大量 log, 以提高速度; 如果数据量不大, 为了缓和系统表的资源, 应先create table, 然后insert 如果使用到了临时表, 在存储过程的最后务必将所有的临时表显式删除, 先 truncate table , 然后 drop table, 这样可以避免系统表的较长时间锁定 尽量避免使用游标, 因为游标的效率较差, 如果游标操作的数据超过1万行, 那么就应该考虑改写 使用基于游标的方法或临时表方法之前, 应先寻找基于集的解决方案来解决问题, 基于集的方法通常更有效 与临时表一样, 游标并不是不可使用. 对小型数据集使用 FAST_FORWARD 游标通常要优于其他逐行处理方法, 尤其是在必须引用几个表才能获得所需的数据时. 在结果集中包括\"合计\"的例程通常要比使用游标执行的速度快. 如果开发时间允许, 基于游标的方法和基于集的方法都可以尝试一下, 看哪一种方法的效果更好 在所有的存储过程和触发器的开始处设置 SET NOCOUNT ON, 在结束时设置 SET NOCOUNT OFF . 无需在执行存储过程和触发器的每个语句后向客户端发送 DONE_IN_PROC 消息 尽量避免大事务操作, 提高系统并发能力. 尽量避免向客户端返回大数据量, 若数据量过大, 应该考虑相应需求是否合理 Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-25 18:31:45 "},"docs/mysql/mysql-forget.html":{"url":"docs/mysql/mysql-forget.html","title":"记不住的sql","keywords":"","body":"记不住的语句计算时间差将一个或是多个特定的数据排在最前面转换日期值的函数mysql用户信息记不住的语句 计算时间差 select timestampdiff(SECOND, '1970-01-01 08:00:00', now()) from table; 将一个或是多个特定的数据排在最前面 select * from tablename order by case when (labh='201700002' or labh='201700004') then 0 else 1 end , xh desc; 转换日期值的函数 CONVERT(data_type(length), data_to_be_converted,style) data_type(length) // 规定目标数据类型(带有可选的长度). data_to_be_converted // 含有需要转换的值. style 规定日期/时间的输出格式 mysql用户信息 mysql存储用户和密码的表 msyql.user # 查询用户和授权host select user, host from mysql.user; Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-25 18:31:45 "},"docs/mysql/select.html":{"url":"docs/mysql/select.html","title":"查询","keywords":"","body":"前面驱动表选择合理的排序多表在A表且不在B表交集去重计数参考前面 在没有where情况下，左连接左边为驱动表，右连接右表为驱动表。 有where的情况下，要视情况而定，而且有可能会被引擎优化。 驱动表选择 在没有过滤条件的情况下，外表有多少行就会被加载多少次；每次加载相当于一次随机读。 假设a表有10000行，b表有100行；如果a表为驱动表会有10000次随机读，b表做驱动表，会有100次随机读。 合理的排序 多表join执行时，优化器内部会先找出外表，之后会对外表进行排序；如果order by后面跟的是外表字段，则排序会在这时完成。但如果order by后面的字段是内表字段，则在所有结果集选出之后，再进行一次排序。 多表 在A表且不在B表 方法1 select a.id from a where a.id not in (select id from b); 方法2 select a.id from a left join b on a.id = b.id where b.id is null; 方法3 select a.id from a where (select count(1) from b where a.id = b.id) = 0; 一般情况下使用 not in 效率是比较低的，推荐使用2和3。 交集 方法1 select a.id from a where a.id in (select id from b); 方法2 select a.id from a left join b on a.id = b.id where b.id is not null; 方法3 select a.id from a where (select count(1) from b where a.id = b.id) > 0; 去重计数 distinct方法 select count(distinct name) as name from t group by方法 select count(name) as name from t group by name 字段的重复记录较少时，group by更优秀，重复记录多时，使用distinct更好。 参考 SQL优化之多表join MySQL索引概述于读书笔记 Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-25 18:31:45 "},"docs/sqlserver/page_query.html":{"url":"docs/sqlserver/page_query.html","title":"分页查询","keywords":"","body":"方案一方案二方案三方案四方案五总结第四种方的存储过程sqlserver几种分页查询 方案一 SELECT TOP 30 * FROM ARTICLE WHERE ID NOT IN(SELECT TOP 45000 ID FROM ARTICLE ORDER BY YEAR DESC, ID DESC) ORDER BY YEAR DESC,ID DESC; 方案二 SELECT * FROM (　　SELECT TOP 30 * FROM (SELECT TOP 45030 * FROM ARTICLE ORDER BY YEAR DESC, ID DESC) f ORDER BY f.YEAR ASC, f.ID DESC) s ORDER BY s.YEAR DESC,s.ID DESC 方案三 SELECT * FROM ARTICLE w1, ( SELECT TOP 30 ID FROM ( SELECT TOP 50030 ID, YEAR FROM ARTICLE ORDER BY YEAR DESC, ID DESC ) w ORDER BY w.YEAR ASC, w.ID ASC ) w2 WHERE w1.ID = w2.ID ORDER BY w1.YEAR DESC, w1.ID DESC 方案四 SELECT * FROM ARTICLE w1 WHERE ID in ( SELECT top 30 ID FROM ( SELECT top 45030 ID, YEAR FROM ARTICLE ORDER BY YEAR DESC, ID DESC ) w ORDER BY w.YEAR ASC, w.ID ASC ) ORDER BY w1.YEAR DESC, w1.ID DESC 方案五 SELECT w2.n, w1.* FROM ARTICLE w1, (　　SELECT TOP 50030 row_number() OVER (ORDER BY YEAR DESC, ID DESC) n, ID FROM ARTICLE ) w2 WHERE w1.ID = w2.ID AND w2.n > 50000 ORDER BY w2.n ASC 总结 在查询页数靠前时, 效率3 > 4 > 5 > 2 > 1, 页码靠后时5 > 4 > 3 > 1 > 2, 再根据用户习惯, 一般用户的检索只看最前面几页, 因此选择3 4 5方案均可, 若综合考虑方案5是最好的选择, 但是要注意SQL2000不支持 row_number() 函数 第四种方的存储过程 if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[sys_Page_v2]') and OBJECTPROPERTY(id, N'IsProcedure') = 1) drop procedure [dbo].[sys_Page_v2] GO CREATE PROCEDURE [dbo].[sys_Page_v2] @PCount int output, --总页数输出 @RCount int output, --总记录数输出 @sys_Table nvarchar(100), --查询表名 @sys_Key varchar(50), --主键 @sys_Fields nvarchar(500), --查询字段 @sys_Where nvarchar(3000), --查询条件 @sys_Order nvarchar(100), --排序字段 @sys_Begin int, --开始位置 @sys_PageIndex int, --当前页数 @sys_PageSize int --页大小 AS SET NOCOUNT ON SET ANSI_WARNINGS ON IF @sys_PageSize '' BEGIN SET @new_order1 = ' ORDER BY ' + Replace(@sys_Order,'desc','') SET @new_order1 = Replace(@new_order1,'asc','desc') SET @new_order2 = ' ORDER BY ' + @sys_Order END ELSE BEGIN SET @new_order1 = ' ORDER BY ID DESC' SET @new_order2 = ' ORDER BY ID ASC' END SET @SqlCount = 'SELECT @RCount=COUNT(1),@PCount=CEILING((COUNT(1)+0.0)/' + CAST(@sys_PageSize AS NVARCHAR)+') FROM ' + @sys_Table + @new_where1 EXEC SP_EXECUTESQL @SqlCount,N'@RCount INT OUTPUT,@PCount INT OUTPUT', @RCount OUTPUT,@PCount OUTPUT IF @sys_PageIndex > CEILING((@RCount+0.0)/@sys_PageSize) --如果输入的当前页数大于实际总页数,则把实际总页数赋值给当前页数 BEGIN SET @sys_PageIndex = CEILING((@RCount+0.0)/@sys_PageSize) END set @sql = 'select '+ @sys_fields +' from ' + @sys_Table + ' w1 ' + ' where '+ @sys_Key +' in (' +'select top '+ ltrim(str(@sys_PageSize)) +' ' + @sys_Key + ' from ' +'(' +'select top ' + ltrim(STR(@sys_PageSize * @sys_PageIndex + @sys_Begin)) + ' ' + @sys_Key + ' FROM ' + @sys_Table + @new_where1 + @new_order2 +') w ' + @new_order1 +') ' + @new_order2 print(@sql) Exec(@sql) GO Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-25 18:31:45 "},"docs/other/precautions.html":{"url":"docs/other/precautions.html","title":"注意注意","keywords":"","body":"空值时间参考空值 select * from tb where name != 'dingfang' 这个查出的数据不仅不包含 dingfang，而且也不包含空值数据。 应该改为 select * from tb where (name != 'dingfang' or name is null) 时间 select * from tb where t 这个时间一般意味着是 2021-03-29 00:00:00，所以这里用 会包含29日一个整点的时间数据，看起来会很奇怪，有些场景这样会认为是错误的。 所以取时间一般是左闭右开区间。 select * from tb where t >= '2021-03-29' and t 参考 那些sql里面踩过的坑 Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-25 18:31:45 "}}