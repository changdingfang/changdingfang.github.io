{"./":{"url":"./","title":"前言","keywords":"","body":"简介参考简介 让编写的软件可以清楚而正确的表现出设计意图。 一般性规则：较少的代码就是较好的代码 28原则 80%的资源用于20%的代码身上 模板与泛型编程 c++ template机制自身是一部完整的图灵机：它可以被用来计算任何可计算的值。 于是导出了模板元编程(template metaprogramming)，创造出“在c++编译器内执行并于编译完成时停止执行”的程序。 classes和template都支持接口和多态。对classes而言接口是显示的，以函数签名为中心，多态通过virtual函数发生于运行期。对template而言接口是隐式的，基于有效表达式，多态通过template具现化和函数重载解析发生于编译期。 参考 Effective C++ More Effective C++ c++异常与\"为什么析构函数不能抛出异常\"问题 Herb Sutter的Uncaught Exceptions Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-25 18:31:45 "},"docs/basic/pointer.html":{"url":"docs/basic/pointer.html","title":"指针和引用","keywords":"","body":"指针和引用指针和引用 当你知道你需要指向某个东西，且绝不会改变指向其他东西，或是实现一个操作符而其语法无法由指针达成，应该选择引用，其他时候选择指针。 Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-25 18:31:45 "},"docs/basic/typeconver.html":{"url":"docs/basic/typeconver.html","title":"类型转换","keywords":"","body":"类型转换类型转换 最好使用c++提供的类型转换 语意明确、严谨、便于识别 4种类型转换，各司其职，适用于不同场景，更加的安全 Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-25 18:31:45 "},"docs/basic/define.html":{"url":"docs/basic/define.html","title":"尽量以const,enum,inline替换#define","keywords":"","body":"尽量以const,enum,inline替换#define尽量以const,enum,inline替换#define \"#define\"不被视为语言的一部分。 #define PI 3.14 记号PI可能没有进入记号表（symbol table）内。 所以在编译错误信息时，可能会产生困惑，因为看到的信息也许是3.14而不是PI 使用常量替换 /* c++11之后出现的constexpr, 11之前使用const */ constexpr double PI = 3.14; /* 常量字符串*/ const char *const name = \"ding fang\"; /* 或 const std::string(\"ding fang\"); */ /* 一个class的专属常量 */ class A { private: static constexpr int num; /* static 避免产生多份实体,需要在实现文件中定义 */ /* 或者用枚举 */ enum { Num = 99 }; /* 可以避免被获取地或被或被引用, 不会分配非必要的内存 */ }; constexpr int A::num = 99; inline 替代 函数宏 #include #define MAX(a, b) ( ((a) > (b)) ? (a) : (b) ) template inline T Max(T &a, T &b) { return a > b ? a : b; } int main(void) { int a = 2, b = 0; /* * a被加了两次, * 因为被替换为 (++a) > (b) ? (++a) : (b) * 当a Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-25 18:31:45 "},"docs/basic/initialization.html":{"url":"docs/basic/initialization.html","title":"确定对象被使用前已先被初始化","keywords":"","body":"确定对象被使用前已先被初始化确定对象被使用前已先被初始化 类的成员初始化有着固定的顺序，基类早于派生类先初始化，先声明的成员比后声明的成员先初始化 #include class A { public: /* 初始化顺序和声明顺序相同，与构造函数初始化列表顺序无关 */ A() : b_(5) , a_(b_) /* a比b先声明，此时b并没有被初始化，a得到的值是不确定的 */ { } int a_; int b_; }; int main(void) { A a; std::cout 定义于不同编译单元内的non-local static对象的初始化顺序并没有明确定义，所以初始化顺序是不确定的，尽量不使用静态对象给静态对象初始化 可以把这些non-local static对象的放在函数内，通过调用这些函数返回该对象的一个引用，这样可以在函数第一次被调用时初始化该对象，并且以后都使用该函数来获取该对象，这种手法类似于单例模式。 class A { }; A &getA() { /* 非线程安全 */ static A a; /* 以local static 替代non-local static */ return a; } int main(void) { getA(); return 0; } Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-25 18:31:45 "},"docs/basic/polymorphism.html":{"url":"docs/basic/polymorphism.html","title":"多态和指针算数不要混用","keywords":"","body":"多态和指针算术不要混用多态和指针算术不要混用 数组对象几乎总是会涉及指针的算术运算，所以数组和多态不要混用 因为混用，所以以下代码输出会出现不可预期的结果(注释中有解释) #include #define LEN 5 class A { public: friend std::ostream &operator Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-25 18:31:45 "},"docs/basic/default_constructor.html":{"url":"docs/basic/default_constructor.html","title":"非必要不提供default constructor","keywords":"","body":"非必要不提供default constructor非必要不提供default constructor \"合理的从无到有生成对象\"的classes，都应该内含default constructors，而\"必须有某些外来信息才能生成对象\"的classes，则不必拥有default constructor。 缺乏default constructor，在以下3中情况下出现问题 数组 一般没有任何方法可以为数组中的对象指定constructor自变量 template－based container classes 如果template没有消除default constructor的使用，那么将无法使用没有默认构造函数的类 virtual base classes 如果基类缺少defalut constructor，那么所有的派生类构造时，都要提供基类的constructors自变量。这样的代码违背了设计原则 在使用数组时避免default constructor使用的方法 #include class A { public: A(int a){}; }; int main(void) { /* 数组使用收到影响 */ // A a[3]; // 缺少默认构造函数，无法编译 A a[3] = { A(1), A(2), A(3) }; // 正确 /* 采用指针数组 */ A *a1[3]; A **pa = new A*[3]; for (int i = 0; i (rawm); for (int i = 0; i Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-25 18:31:45 "},"docs/basic/virtual_destruct.html":{"url":"docs/basic/virtual_destruct.html","title":"virtual析构函数","keywords":"","body":"virtual析构函数virtual析构函数 classes的设计目的如果不是为了作为base classes使用，或不是为了具备多态性，就不该声明virtual析构函数 只要类中有任何一个函数声明为virtual，那么就会生成vptr和vtbl，从而占用一定的空间 Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-25 18:31:45 "},"docs/operator/assignment.html":{"url":"docs/operator/assignment.html","title":"赋值操作注意事项","keywords":"","body":"赋值操作符注意事项赋值操作符注意事项 派生类实现赋值运算符时，不要忘记调用父类的复赋值运算符。它不像拷贝构造函数一样能够自动调用默认的拷贝构造函数。 #include class A { public: explicit A(int a): a_(a) { } int a_; }; class B : public A { public: void print() { std::cout 自己写copying函数时，注意： 复制所有local的成员变量 调用所有base classes内的适合的copying函数 Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-25 18:31:45 "},"docs/operator/typeconverfunc.html":{"url":"docs/operator/typeconverfunc.html","title":"\"类型转换函数\"","keywords":"","body":"“类型转换函数”“类型转换函数” 最好不要提供任何类型转换函数，在不预期的情况下，这类函数可能会被调用，而结果可能是不正确、不直观的程序行为，很难调试 两种函数允许编译器执行转换 单自变量constructors 隐式类型转换操作符 单变量constructors举例 class A { public: A(int num) { }; // explicit A(int num) { }; /* 避免隐式类型转换 */ bool operator == (const A &r) { return true; }; }; int main(void) { int n = 10; A a(10); /* * 发生了类型转换，n会调用A(int num)实例化成A的，再调用==重载符号比较 * 这样的行为是很危险的，应当避免，在构造函数上加上explicit即可。 * */ if (a == n); return 0; } 隐式类型转换举例 #include class A { public: operator double() const { return double(2.0); } double asDouble() const { return double(2.0); } }; int main(void) { A a; double d = 0.5 * a; /* 发生了隐式类型转换 */ std::cout Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-25 18:31:45 "},"docs/operator/in_de_crement.html":{"url":"docs/operator/in_de_crement.html","title":"increment/decrement操作符","keywords":"","body":"increment/decrement操作符increment/decrement操作符 区别increment/decrement操作符的前置(prefix)和后置(postfix)形式 class MyInt { public: /* 这里只是演示，并没有做加法 */ MyInt &operator +=(const int &r) { return *this; }; /* prefix increment,前加加 */ MyInt &operator ++() { *this += 1; return *this; } /* postfix increment,后加加，int参数默认为0 */ const MyInt operator ++(int) { MyInt oldVal = *this; /* 让后加加依赖于前加加，这样只维护前加加即可 */ ++(*this); return oldVal; } /* 减法的方式和加法的方式是一样的 */ }; int main(void) { MyInt i; ++i; i++; return 0; } 前置式是“先累加然后取出”，后置式是“先取出然后累加”，这就是为什么代码中前置和后置的重载不一样的原因。为什么后置式返回的对象要加const如果后置式返回的对象不是const的，那么下面的写法将会合法 MyInt i; i++++; 既i.operator++(0).operator++(0)，第二个operator++的调用动作基于第一个调用动作的返回值。而其返回值是一个oldval，这样的结果是i只被加了一次，违反了直觉，容易混淆。就算是正常的int类型也不允许这样使用的。 Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-25 18:31:45 "},"docs/operator/and_or_comma.html":{"url":"docs/operator/and_or_comma.html","title":"不要重载\"&&\",\"||\",\",\"操作符","keywords":"","body":"不要重载\"&&\",\"||\"和\",\"操作符不要重载\"&&\",\"||\"和\",\"操作符 短路 /* 如果num 0 && num 0，那么\"||\"后面的代码就不会被执行 */ if (num > 0 || num 重载\"&&\"和\"||\"操作符，会从根本层面改变整个游戏规则，“短路”将会失效。 // if (a1 && a2) ... // 既转换为 if (a1.operator &&(a2)) ... /* operator && 为成员函数 */ if (operator &&(a1, a2)) ... /* operator && 为全局函数 */ /* 这失去了“短路”的语义 */ 逗号表达式 表达式如果内含逗号，那么逗号左侧的会先被执行，然后逗号的右侧的再被执行，最后，整个逗号表达式的结果以逗号右侧的值为代表。 如果把逗号操作符写成一个非成员函数，那绝对无法保证左侧的表达式一定比右侧表达式更早的执行，因为两个表达式都被当做函数调用时的自变量，传递给操作符函数，而无法控制一个函数的自变量执行顺序。 如果把逗号操作符写成一个成员函数， 那无法保证左侧的表达式一定比右侧表达式更早的执行，因为编译器不强迫做这样的事情，因此无法“不但将逗号操作符重载，并保证其行为像它应该有的那样” Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-25 18:31:45 "},"docs/operator/new_delete.html":{"url":"docs/operator/new_delete.html","title":"new和delete","keywords":"","body":"new 和 deletenewnew operator和operator new`new operator做了什么operator new做了什么placement newdeletedelete operator和operator delete`数组new 和 delete new new operator和operator new` 如 string *ps = new string(\"hello world\"); 使用的是 new operator这个操作符是由语言内建的，不能被改变意义，总是做相同的事情 new operator做了什么 分配足够放置一个string对象的内存 调用一个constructor，为内存中的对象初始化 函数operator new的可能声明 void *operator new(size_t size); operator new 只负责内存分配，和malloc类似 operator new做了什么 返回一个指针，指向一块原始的、未设初始值的内存 placement new #include int main(void) { size_t size = sizeof(int); void *buffer = operator new(size); new (buffer) int; return 0; } 上面是new operator的用法之一，其中指定一个额外的自变量（buffer）作为new operator“隐式调用 operator new”时所用。这样的operator new就是placement new。 如果希望对象在heap，使用new operator 如果只分配内存，使用operator new 如果打算在heap objects产生时自己决定内存分配方式，那就自己写一个operator new，并使用new operator，它会自动调用自己写的operator new 如果想在已分配的内存中构造对象，使用placement new delete 为了避免资源泄露，每一个动态分配行为都必须匹配一个相应但相反的释放动作。 delete operator和operator delete` string *ps; // ''' delete ps; /* 调用delete operator */ 内存释放动作是由函数 operator delete执行，可能的声明 void operator delete(void *memory); 因此，delete ps; 会造成编译器产生近似这样的代码 ps->~string(); /* 调用对象的析构函数 */ operator delete(ps); /* 释放对象占用的内存 */ 如果使用placement new在某块内存中产生对象，那应该避免对这块内存使用delete operator。因为delete operator会调用operator delete来释放内存，但是该内存内含的对象最初并非由operator new分配得来的。 数组 operator new [] 与 operator delete [] /* * 调用operator new []分配足够容纳10个string对象的内存 * 然后对每个元素调用string default ctor进行初始化。 */ string *ps = new string[10]; /* * 为数组中每个元素调用dtor * 然后调用operator delete [] 释放内存 */ delete [] ps; Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-25 18:31:45 "},"docs/operator/nd/":{"url":"docs/operator/nd/","title":"定制new和delete","keywords":"","body":"定制new和delete定制new和delete 了解c++内存管理例程的行为，研究并学习软件使用内存的行为特征，然后修改分配和归还工作，以求获得其所建置的系统的最佳效率。 分配例程和归还例程 Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-25 18:31:45 "},"docs/operator/nd/new_handle.html":{"url":"docs/operator/nd/new_handle.html","title":"new-handler的行为","keywords":"","body":"了解new-handler的行为set_new_handler使用示例不要使用new(std::nothrow)了解new-handler的行为 当operator new无法满足某一内存分配需求时，它会抛出异常。当operator new抛出异常以反映一个未获满足的内存需求之前，它会先调用一个用户指定的错误处理函数(new-handler) set_new_handler使用示例 #include void outOfMem() { std::cerr 不要使用new(std::nothrow) 它只能保证 new(std::nothrow)不抛出异常，但是不能保证整个表达式不抛出异常，在构造对象时，构造函数内有可能会使用new来分配内存，这时该new是有可能抛出异常的，从而导致异常扩散影响到外部 #include class A { public: A() { while (true) { /* 这里会抛异常 */ int *p = new int[1000 * 1024 * 1024]; } } }; int main(void) { try { /* 虽然使用不抛异常方式，但构造A时可能会抛异常 */ A *p = new(std::nothrow) A(); } catch(...) { std::cerr Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-25 18:31:45 "},"docs/operator/nd/replace.html":{"url":"docs/operator/nd/replace.html","title":"new和delete的替换时机","keywords":"","body":"了解new和delete的合理替换时机为什么替换编写new和deleteplacement new和placement delete了解new和delete的合理替换时机 为什么替换 用来检测运用上的错误 定制的new和delete可以添加日志,用于定位new和delete失败问题 强化性能 可以根据需求定制特化的new和delete,减少内存碎片产生,优化new和delete的效率 弥补缺省分配器中的非最佳齐位(内存对齐) 不同的架构,影响访问效率的对齐位可能不一样 将相关对象成簇集中 某些特定的数据结构通常是一起使用的,这时使用定制的可以把“内存页错误”的频率降低 降低额外内存开销 普通版的往往会使用更多的内存,因为它们经常在每一个分配区块身上招引某些额外开销 收集使用上的统计数据 收集软件如何使用动态内存,分配内存大小分布、寿命、最大分配量等等 编写new和delete 下面是大概流程的伪代码 void *operator new(std::size_t size) { if (size == 0) { size = 1; } while (true) { /* 分配内存 */ if (/* 分配成功 */) { return /* 一个指针 */; } std::new_handler globalHandler = std::set_new_handler(NULL); std::set_new_handler(globalHandler); if (globalHandler) { (*globalHandler)(); } else { throw std::bad_alloc(); } } } void operator delete(void *ramMemory) noexcept { if (ramMemory == NULL) { return; } /* 归还内存 */ } operator new 应该内含一个无穷循环，并尝试分配内存，如果无法满足内存需求，应该调用new-handler。也应该处理好0bytes申请operator delete 应该处理好null指针 placement new和placement delete placement new和placement delete需要成对出现 如果一个带有额外参数的 operator new 没有“带相同额外参数”的对应 operator delete ， 那么当new的内存分配动作需要取消并恢复旧观时就没有任何 operator delete 会被调用(这会导致资源泄露) 只写 placement new 和 placement delete 会遮掩全局的new和delete，导致预期的new和delete失败 class A { public: /* 因为作用域的缘故，该new会覆盖全局的new */ static void *operator new(std::size_t size, std::ostream &logStream) noexcept { /* do something */ } static void operator delete(void *p) noexcept { /* do something */ } /* 与带有额外参数的new对应 */ static void operator delete(void *p, std::ostream &logStream) { /* do something */ } }; int main(void) { // A *p0 = new A(); /* 报错，因为类的new覆盖了全区的new */ A *p1 = new (std::cerr) A(); return 0; } 需要重写全局的new和delelte，在类内实现和全局参数一样的new和delete来调用全局的new和delete #include class A { public: static void *operator new(std::size_t size) noexcept { return ::operator new(size); } static void operator delete(void *p) noexcept { ::operator delete(p); } static void *operator new(std::size_t size, const std::nothrow_t &nt) noexcept { return ::operator new(size, nt); } static void operator delete(void *p, const std::nothrow_t &) noexcept { ::operator delete(p); } static void *operator new(std::size_t size, std::ostream &logStream) noexcept { /* do something */ } static void operator delete(void *p, std::ostream &logStream) noexcept { /* do something */ } }; int main(void) { A *p0 = new A(); A *p1 = new (std::cerr) A(); delete p0; delete p1; return 0; } 现在所有的一切都可以正常的工作了。 Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-25 18:31:45 "},"docs/exception/smart_pointer.html":{"url":"docs/exception/smart_pointer.html","title":"使用智能指针避免资源泄露","keywords":"","body":"使用智能指针避免资源泄露普通的构造时阻止资源泄露使用智能指针避免资源泄露 或设计一个类，使用构造和析构的特性来达到目的 原则：把资源封装在对象内，通常便可以在exceptions出现时避免资源泄露。 普通的 #include void test1() { int *p = new int(100); /* ... */ /* 假如这里有可能会抛异常 */ /* ... */ /* 如果抛异常，则会出现内存泄露 */ delete p; } void test2() { int *p = new int(100); try { /* 假如这里有可能会抛异常 */ /* 避免了抛异常时内存泄露，但是代码看起来被try搞乱了 */ } catch(...) { delete p; throw; } delete p; } void test3() { std::unique_ptr p(new int(100)); /* 使用智能指针，优雅规避 */ /* ... */ /* 假如这里有可能会抛异常 */ /* ... */ } int main(void) { return 0; } 构造时阻止资源泄露 在构造列表上是没办法写try...catch来捕捉异常的，如果是指针常量，那么又必须在初始化列表里面进行初始化，这个时候如果抛异常是比较难处理的，使用智能指针可以很好的规避。 #include class A { }; class B { public: /* 使用智能指针，可以很优雅且有效的避免在构造对象期间资源泄露 */ /* 即使pa2在构造期间有异常抛出，pa1也能够正常释放掉资源 */ B() : pa1_(std::make_shared(A())) , pa2_(std::make_shared(A())) { } public: std::shared_ptr pa1_; std::shared_ptr pa2_; }; int main(void) { B b; return 0; } Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-25 18:31:45 "},"docs/exception/exception_destruct.html":{"url":"docs/exception/exception_destruct.html","title":"尽量阻止异常流出析构之外","keywords":"","body":"尽量阻止异常流出析构之外尽量阻止异常流出析构之外 析构被调用的情况 正常状态下被销毁（离开了生命空间）或被明确地删除 对象被异常处理机制销毁（也就是异常传播过程中栈展开机制） 有了 std::uncaught_exception(); 方法后，可以判断当前是否有异常正在进行栈展开，那么就可以来决定是否可以把析构里面的异常抛出去。 但是我看了Herb Sutter写的这篇文章之后，我犹豫了，我不确定该不该使用该方法，因为我对这篇英文文章不是很理解。 我大概理解的是使用std::uncaught_exception有两个问题 第一它并没有做到绝对的安全， 第二个是哲学本身问题，这样写使接口和语义复杂化，而且让调用者必须处理两种错误方式。 #include class B { public: void foo() { throw 1; } /* 避免异常流出析构之外 */ ~B() { try { this->foo(); std::cout Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-25 18:31:45 "},"docs/exception/throw_and_param.html":{"url":"docs/exception/throw_and_param.html","title":"抛出一个exception与传递一个参数的差异","keywords":"","body":"抛出一个exception与传递一个参数的差异抛出一个exception与传递一个参数的差异 抛出异常时，会创建一个副本，这个与catch的接收方式无关 Widget w; throw w; /* 会创建一个副本 */ catch(Widget &w) { /* ... */ throw; /* 不会生成新的副本，会继续传播w */ } catch(Widget &w) { /* ... */ throw w; /* 会产生一个新的副本，发生了复制 */ } // catch异常时，有三种方式 catch(Widget w) // by value catch(Widget &w) // by reference catch(const Widget &w) // by refence-to-const 捕捉异常时，不会发生隐式类型转换 #include void foo(int val) { try { throw val; } catch(double d) { /* 无法捕捉int类型的异常 */ std::cout try { /* ... */ } catch(logic_error &ex) { /* 将捕捉所有的logic_error exceptions, 甚至包括其派生类 */ /* ... */ } catch(invalid_argument &ex) { /* invalid_argument 是logic_error的派生类，这里将不会被执行 */ /* ... */ } 综上可以看出，抛出异常和传递函数参数相比，多了创建了一个副本。异常捕获不会发生隐式类型转换，而普通函数可以。异常捕获是按照catch子句出现顺序做匹配尝试，而函数是一句最佳匹配类型做匹配。 千万不要抛出一个指向局部变量的指针，因为在抛出时，该局部变量也会被销毁，这是很危险的行为。 catch(const void *) ... /* 可捕获任何类型指针的异常 */ Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-25 18:31:45 "},"docs/exception/by_reference.html":{"url":"docs/exception/by_reference.html","title":"以by reference方式捕捉exception","keywords":"","body":"以by reference方式捕捉exception为什么不用by pointer方式为什么不用by value方式以by reference方式捕捉exception 为什么不用by pointer方式 有对象删除问题，对于局部指针，会出现使用已销毁的地指针问题，使用堆或全局的指针，又不确定需要不需要删除。 为什么不用by value方式 需要复制两次 会引起切割问题 当有基类于派生类时，会丢失派生部分。 #include class A { public: virtual void foo() { std::cout 所以，使用by reference的方式。 Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-25 18:31:45 "},"docs/exception/except_cost.html":{"url":"docs/exception/except_cost.html","title":"异常处理的成本","keywords":"","body":"异常处理的成本异常处理的成本 #include #include int foo() { /* 下面是使用不同的方式，所消耗的时间 */ throw 5; /* use:10915 use:9827 use:9548 use:9780 use:10262 */ // return 5; /* use:11 use:12 use:12 use:11 use:11 */ } void test(const int cal_count) { struct timeval tv; gettimeofday(&tv, NULL); for (int i = 0; i 这个测试并不怎么样，但是可以看出使用throw与catch，会大大降低性能。 Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-25 18:31:45 "},"docs/exception/except_safe.html":{"url":"docs/exception/except_safe.html","title":"做好\"异常安全\"","keywords":"","body":"做好“异常安全”做好“异常安全” 异常安全性的函数应当做到: 不泄露任何资源 不允许数据破坏 异常安全函数应当做到下面三个保证之一: 基本保证 如果有异常被抛出，程序内的任何事物仍然保持在有效状态下。没有任何对象或数据结构会因此而破坏，所有对象都处于一种内部前后一致的状态。然而程序的现实状态不可预料 强烈保证 如果有异常被抛出，程序状态不改变（类似于事物，保证一致性和原子性） 不抛掷保证 承诺绝不抛出异常，因为它们总是能够完成它们原先承诺的功能。 强烈保证可通过copy-and-swap实现既给打算修改的对象做一个副本，然后在副本上做一切必要修改，若有任何修改动作抛出异常，原对象仍保持未改变状态，待所有改变都成功后，再将修改过的那个副本和原对象在一个不抛异常的操作中置换(swap) 具备异常安全性 以对象管理资源，避免资源泄露 挑选三个保证之一实施于函数上 Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-25 18:31:45 "},"docs/efficiency/lazy_evaluation.html":{"url":"docs/efficiency/lazy_evaluation.html","title":"使用lazy evaluation","keywords":"","body":"使用lazy evaluation(缓式评估)lazy fetching(缓式取出)lazy expression evaluation(表达式缓评估)总结使用lazy evaluation(缓式评估) reference counting(引用计数) 正如std::string的写时复制一样,只有当真正需要改变的时候,才去做(现在的 std::string 已经不是写时复制了) lazy fetching(缓式取出) 可能一个对象里面含有许多的字段,这个对象必须在每次执行时保持与前次执行的一致性和连贯性,所以这些字段必须存到数据库中.每个对象都有唯一识别码,可用来从数据库中取回对象. #include #include class A { public: A(int id) { }; const std::string &field1() const; int field2() const { return 0; }; double field3() const { return 0.0; }; const std::string &field4() const; /* ...很多很多... */ private: /* 加上mutable修饰可用让该member在const修饰的函数中修改 */ mutable std::string *fv1_{nullptr}; mutable int *fv2_{nullptr}; mutable double *fv3_{nullptr}; mutable std::string *fv4_{nullptr}; /* ...很多很多... */ }; const std::string &A::field1() const { if (fv1_ == nullptr) { /* 从数据库得到该字段数据,这里我随便伪造一个数据 */ fv1_ = new std::string(\"hello world fv1\"); } return *fv1_; } const std::string &A::field4() const { if (fv4_ == nullptr) { /* 从数据库得到该字段数据,这里我随便伪造一个数据 */ fv4_ = new std::string(\"hello world fv4\"); } return *fv4_; } int main(void) { A a(10); std::cout 做到了只有在使用某个字段的时候才会去数据库读取数据给对应字段赋值,而没有使用时是一个nullptr值,如果在很多情况下都是只使用该对象的几个成员,那么这样相比于构建对象就给每个member data赋值省去了很多资源与提升性能. lazy expression evaluation(表达式缓评估) 在需要用或者被逼无奈的时候,再进行计算. template class Matrix { /* ... */ }; int main(void) { Matrix m1; /* (1000, 1000)*/ Matrix m2; /* (1000, 1000)*/ // Matrix m3 = m1 + m2; /* 情况一 */ Matrix m4; /* (1000, 1000)*/ /* * m3 = m1 + m2的结果并未被使用,就改变了m3的值 * 这样m1 + m2的计算就造成了浪费 * */ // m3 = m4 + m1; /* 情况二 */ // cout 总结 如果计算是必须要被执行的,那使用lazy evaluation(缓式评估)并不能提升性能,反而会增加资源消耗,所以它适用于某些计算可以避免的场景 Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-25 18:31:45 "},"docs/efficiency/share.html":{"url":"docs/efficiency/share.html","title":"分期摊还预期的计算成本","keywords":"","body":"分期摊还预期的计算成本缓存prefetching(预先支出)分期摊还预期的计算成本 如果预期程序常常会用到某个计算,可以设计一份数据结构以便能够极有效率的处理需求. 缓存 比如某个数据经常到数据库查询,这时可以把它读取出来,每次再被查询的时候,就直接拿内存里面的数据进行返回. 把昂贵的数据库查询动作以相对廉价的内存数据查找动作替代.或将经常被计算的结果缓存下来等等 prefetching(预先支出) 这个拿STL的std::vector来举例再合适不过了,vector就是使用了预先分配空间,来减少频繁的调用new而提升空间分配效率. #include int main(void) { std::vector v; // v.reserve(10); /* 不同的编译器对vector的内存分配策略可能不同 */ v.push_back(1); /* v.capacity(): 1 */ v.push_back(1); /* v.capacity(): 2 */ v.push_back(1); /* v.capacity(): 4 */ v.push_back(1); /* v.capacity(): 4 */ v.push_back(1); /* v.capacity(): 8 */ v.push_back(1); /* v.capacity(): 8 */ return 0; } 不管是缓存还是预先支出,都是以空间来换取时间,这样做在很多情况下是很值得的. Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-25 18:31:45 "},"docs/efficiency/tempobject.html":{"url":"docs/efficiency/tempobject.html","title":"临时对象的来源","keywords":"","body":"临时对象的来源临时对象的来源 函数传值时,发生类型转换 返回值 #include class A { public: A() { std::cout 临时对象是有成本消耗的, 所以应该尽量消除它们更重要的是拥有敏锐的眼力, 看到可能产生的临时对象的地方 Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-25 18:31:45 "},"docs/efficiency/overload.html":{"url":"docs/efficiency/overload.html","title":"使用函数重载避免隐私类型转换","keywords":"","body":"使用函数重载避免隐式类型转换使用函数重载避免隐式类型转换 #include class A { public: A(int) { std::cout 增加一大堆重载函数不见得是件好事,除非使用重载函数后,效率有很大的提升 Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-25 18:31:45 "},"docs/efficiency/operator_complex.html":{"url":"docs/efficiency/operator_complex.html","title":"操作符复合形式取代独身形式","keywords":"","body":"操作符复合形式取代独身形式操作符复合形式取代独身形式 复合形式(op=)独身形式(op) 独身形式通常必须返回一个新对象,所以要承担一个临时对象的构造和析构成本,而复合形式则是直接将结果写入其左端的自变量,不需要产生临时对象来放置返回值. 要确保操作符的复合形式和独身形式之间的自然关系能够存在,就是以复合形式为基础实现独身形式 #include class A { public: A(): num_(10) { std::cout num_ += r.num_; return *this; } A operator +(const A &r) { return A(*this) += r; } int get_num() const { return num_; } A(const A &r) { std::cout num_ = r.num_; } A &operator = (const A &r) { std::cout num_ = r.num_; return *this; } private: int num_; }; int main(void) { A a, b, c, d; #if 0 /* 独身形式,会产生临时对象,有额外的构造和析构 */ d = a + b + c; #else /* 复合形式,不会产生临时对象 */ d = a; d += b; d += c; #endif std::cout Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-25 18:31:45 "},"docs/efficiency/more_cost.html":{"url":"docs/efficiency/more_cost.html","title":"虚函数、多重继承、虚基类、运行时类型的成本","keywords":"","body":"了解虚函数、多重继承、虚基类、运行时类型识别的成本了解虚函数、多重继承、虚基类、运行时类型识别的成本 我感觉我对虚表和虚表指针的理解还不够深入,但大致是知道会增加内存的开销以及寻址的成本 关于虚函数不能使用inline(即使写成inline,编译器也会优化掉)inline意味着编译期间将调用端的调用动作被调用函数的函数体取代. 但是virtual意味着\"等待,直到运行时期才知道哪个函数被调用\",所以这是有冲突的. #include class A { public: void foo1() { }; virtual void foo2() { }; virtual void foo3() { }; virtual ~A() { }; }; class B : public A { public: virtual void foo2() { }; virtual ~B() { }; }; class C : public A { public: virtual void foo3() { }; virtual ~C() { }; }; class D : public B { public: virtual void foo2() { }; virtual ~D() { }; }; class E : public B, public C { public: virtual void foo3() { }; virtual ~E() { }; }; int main(void) { std::cout Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-25 18:31:45 "},"docs/efficiency/inline.html":{"url":"docs/efficiency/inline.html","title":"inline的里里外外","keywords":"","body":"了解inline的里里外外为什么inline函数一般定义于头文件哪些情况不是inline最后了解inline的里里外外 看起来像函数，动作像函数，比宏好用，调用时没有函数调用的额外开销 inline的观念：对函数的每一个调用都以函数体本身替换。 所以过度使用inline，会使代码膨胀，但如果函数体很小，编译器针对“函数本体”产出的代码可能比针对“函数调用”产出的更小。 函数体在类中实现的成员函数默认为inline class A { public: void f() {}; /* 默认inline, 如果函数体定义在类外，则非inline */ inline void f2() {}; /* 显式inline */ }; 为什么inline函数一般定义于头文件 inline函数通常被定义于头文件，因为大多数建置环境在编译过程中进行inline，而为了将一个“函数调用”替换为“被调用函数的本体”，编译器必须知道那个函数长什么样子。某些建置环境可以在连接期完成inline，少量建置环境如基于.NET CLI的托管环境可以在运行期完成inline 哪些情况不是inline 大部分编译器拒绝太过复杂的函数inline(如递归) 所有对virtual函数的调用也无法inline，因为virtual意味着\"等待，直到运行期才确定调用哪个函数\" 有时候编译器有意愿inline某个函数，但还是可能为该函数生成一个函数本体。例如程序要取某个inline函数的地址，编译器通常必须为此函数生成一个outlined函数本体。毕竟编译器没能力提出一个指针指向一个并不存在的函数。编译器通常不对“通过函数指针而进行的调用”实施inlining 如果在容器中存放带有构造和析构的对象，那构造和析构也不会被inline，毕竟在容器内部需要通过函数指针调用这些构造和析构. 而且构造和析构不适合inline，虽然很多构造和析构看起来什么都没做，但实际上编译器会让构造和析构做很多事情，因为c++对于“对象被创建和被销毁时发生什么事”做了很多的保证。这导致了构造和析构的复杂。 最后 将大多数inline限制在小型、被频繁调用的函数身上。日后调试过程和二进制升级也更容易，也可使代码膨胀问题最小，让程序的速度提升机会最大化 Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-25 18:31:45 "},"docs/efficiency/smart_pointer.html":{"url":"docs/efficiency/smart_pointer.html","title":"智能指针选择","keywords":"","body":"智能指针在 c++ 里面很好用，很大程度上解决了资源泄露问题，但同时也会有些资源开销问题，在选择使用 shared_ptr 还是 unique_ptr 时，也有一些可以改善效率的地方值得注意。 如果可以使用 unique_ptr 就尽量使用 unique_ptr。 因为 shared_ptr 会考虑引用计数，需要原子操作，增加了开销。 Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-25 18:31:45 "},"docs/technology/blur.html":{"url":"docs/technology/blur.html","title":"constructor和non-member function虚化","keywords":"","body":"constructor和non-member function虚化non-member function虚化constructor和non-member function虚化 当派生类重新定义基类的虚函数时,如果一个函数的返回类型是个指针(或引用),指向一个基类,那么派生类的函数也可以返回一个指针(或引用),指向该基类的一个派生类. 这个构造函数虚化,我看完之后理解的就和设计模式里面的工厂模式是一样的. non-member function虚化 根据参数的动态类型的不同来执行不同的行为 #include class A { public: virtual std::ostream &print(std::ostream &s) const = 0; }; class B : public A { public: virtual std::ostream &print(std::ostream &s) const { s Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-25 18:31:45 "},"docs/technology/non_heap_object.html":{"url":"docs/technology/non_heap_object.html","title":"要求(禁止)对象产生于heap中","keywords":"","body":"要求（或禁止）对象产生于heap中要求对象产生于heap中禁止在heap上构建对象要求（或禁止）对象产生于heap中 要求对象产生于heap中 构造函数设为私有 构造函数比较多，一一设为私有比较麻烦，且容易遗漏 析构函数设为私有 class A { public: /* 做一个伪析构 */ void destory() { this->~A(); } private: /* 析构函数设为私有，防止在栈上构建对象 */ ~A() { }; }; class M { // A a_; /* 错误，不可在堆上创建 */ A *pa_; /* 在内含类中，需要改为指针使用 */ }; int main(void) { // A a; /* 错误 */ A *pa = new A(); /* 正确 */ // delete pa; /* 错误 */ pa->destory(); /* 正确 */ return 0; } 对于这种限制了只能在堆上构建对象的类，在内含类里面也必须使用指针，而且这种类无法继承，如果把基类的析构函数改为protected，就可以继承了，但是却无法得知是创建堆上还是创建在栈上的了。 class A { protected: ~A() { }; }; class B : public A { public: B() {}; ~B() {}; }; int main(void) { B b; /* 正确 */ B *pb = new B(); /* 正确 */ return 0; } 对于这种情况的处理，是比较麻烦的，这里不展开研究，如果迫不得已需要对其进行研究，可参看more effective c\\+\\+ 中文版p147 禁止在heap上构建对象 #include class A { public: /* 用c++11的方式 */ /* static void *operator new(size_t) = delete; static void operator delete(void *) = delete; static void *operator new [](size_t) = delete; static void operator delete [](void *) =delete; */ private: static void *operator new(size_t); static void operator delete(void *); static void *operator new [](size_t); static void operator delete [](void *); }; int main(void) { A a; // A *pa = new A(); /* 错误 */ // A *pa = new A[10]; /* 错误 */ A *p = &a; // delete p; /* 错误，delete已经被私有化，编译器就可以报错，delete []同原理 */ return 0; } Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-25 18:31:45 "},"docs/technology/reference_count.html":{"url":"docs/technology/reference_count.html","title":"引用计数","keywords":"","body":"引用计数目的引用计数实现引用计数 目的 简化heap objects周边的簿记工作 记录“对象的拥有者”是件重要的事，因为他有责任删除该对象，但在程序执行的过程中，对象的拥有权可能转移，所以记录对象的拥有权并非是轻松的事情。 引用计数构建出一个垃圾回收机制的一个简单形式 实现一种常识 如果许多对象有相同的值，将这个值存储多次是件很愚蠢的事。最好让所有等值的对象共享一份实值，不但节省内存，也使程序速度加快（因为不需要再构造和析构同值的多余副本） 引用计数实现 #include #include class String { public: String() { pValue_ = new StringValue_T(\"\"); } String(const char *initValue) { pValue_ = new StringValue_T(initValue); } String(const String &r) : pValue_(r.pValue_) { ++pValue_->refCount; } String &operator = (const String &r) { if (r.pValue_ == pValue_) { return *this; } if (--pValue_->refCount == 0) { delete pValue_; pValue_ = NULL; } pValue_ = r.pValue_; ++pValue_->refCount; return *this; } ~String() { if (--pValue_->refCount == 0) { delete pValue_; pValue_ = NULL; } } unsigned int refCount() { return pValue_->refCount; } private: typedef struct T_StringValue { T_StringValue(const char *initValue) : refCount(1) { data = new char [strlen(initValue) + 1]; ::strcpy(data, initValue); } ~T_StringValue() { delete [] data; } unsigned int refCount; char *data; }StringValue_T; StringValue_T *pValue_; }; int main(void) { String str1; String str2(\"hello world\"); std::cout 我实现了一个比较完整的string类 github地址：df::String Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-25 18:31:45 "},"docs/technology/proxy.html":{"url":"docs/technology/proxy.html","title":"代理类","keywords":"","body":"代理类无法区分读写操作的简化版string可以区分读写操作的简化版string总结一下代理类 以String简化版为例，当使用s[index]时，无法区分是读操作还是写操作，所以，就只能悲观的认为是写操作，结束引用计数，创建新的char[]，但可能很多情况下方括号取值就只是读而已，所以为了避免这种情况，可以使用代理类来解决。 无法区分读写操作的简化版string #include class String { public: String(const char *initValue) { data_ = new char [::strlen(initValue) + 1]; ::strcpy(data_, initValue); } char &operator [](int index) { return data_[index]; } private: char *data_; }; int main(void) { String s(\"hello world\"); s[1]; /* 无法区分左值和右值 */ return 0; } 可以区分读写操作的简化版string #include #include class String { public: String(const char *initValue) { data_ = new char [::strlen(initValue) + 1]; ::strcpy(data_, initValue); } class CharProxy { public: CharProxy(String &s, int index) : s_(s) , index_(index) { } CharProxy &operator =(const CharProxy &r) { std::cout 通过代理类，可以判断出读写操作，这样之前的String就知道什么时候该分配新的空间生产新的char []了，代码中还缺少对const string的处理，当然和这个non-const的处理相差不多。 这个其实使用了延缓策略。 总结一下 代理类实际上有三种好处，我这里只用代码体现了一种 实现多维数组 真实数组为一个一维数组，内嵌代理为一个一维数组，组合起来就是一个二维数组 区分读写 压制隐式转换 因为返回的类型为代理类类型，所以很多操作需要隐式类型转换，如果代理类没实现，就不能进行隐式类型转换，这样可以有效的压制隐式类型转换 Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-25 18:31:45 "},"docs/technology/rvo.html":{"url":"docs/technology/rvo.html","title":"RVO","keywords":"","body":"返回值优化返回值优化 RVO(Return Value Optimization) 是一种编译器优化技术，通过该技术可以减少函数返回时生成的临时值(对象)的个数，可以提升程序运行效率。 这种技术也被称为 \"copy elision(复制消除)\" 优化。 在返回值中尽量不要使用 std::move， 在返回值中会因为 std::move 导致编译器再隐式地构造一个临时变量(通过移动构造函数)，然后 RVO。反而因为为了优化而损失了性能。 Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-25 18:31:45 "},"docs/design/easy_use_api.html":{"url":"docs/design/easy_use_api.html","title":"让接口容易使用","keywords":"","body":"让接口容易被使用让接口容易被使用 如果用户企图使用某个接口而却没有获得他预期的行为，这个代码不该通过编译；如果代码通过了了编译，它的作为就该是用户所想要的。 让接口保持统一 STL容器的接口十分的一致，比如size(),使用时就知道是获取容器内有多少个对象而如果像其他语言一样，有的对array提供size，对list又提供length，甚至提供count，这样让开发人员使用时十分痛苦(以为该使用size，结果提供的是length，容易造成混乱)。 Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-25 18:31:45 "},"docs/design/class.html":{"url":"docs/design/class.html","title":"设计class","keywords":"","body":"设计class设计class class的设计就是type的设计。 对象应该如何被创建和销毁 构造函数和析构函数的设计 对象初始化和对象赋值的差异 注意构造和赋值操作符的行为 在以值传递时注意拷贝构造函数的实现 参数类型值是否应该检查正确性 继承体系 父类的virtual和non-virtual约束你的设计，如果作为父类，那设计时需要注意哪些为virtual的，特别是析构函数 类型转换 显式与隐式转换的注意，特别是隐式转换时是否会出现非预期行为 公共、保护和私有的设计 私有设计成员变量,可以赋予用户访问数据的一致性,可细微划分访问控制,允诺约束条件获得保证,并提供class作者以充分的实现弹性 是否应该设计为模板类 如果是一个types家族，那可能需要设计一个模板类使之更加通用 Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-25 18:31:45 "},"docs/design/member_func.html":{"url":"docs/design/member_func.html","title":"以non-member、non-friend替换member函数","keywords":"","body":"以non-member、non-friend替换member函数以non-member、non-friend替换member函数 假如有一个class表示网页浏览器 class WebBrowser { public: /* ... ... */ void clearCache(); void clearHistory(); void removeCookies(); /* ... ... */ }; 假如这时需要一个同时清理cache,history和cookies的方法,这个方法可以放在class里面,也可以放在class外面. 这时最好选择放在class外面, 理由如下:member方法是可以访问私有成员的,越多的公有的member方法,那封装性就越差,因为这时有了更多的member方法可以访问私有成员了,所以,如果封装的方法只是访问class里面的公有方法,那么设计为non-member和non-friend更好. void clearWebBrowser(WebBrowser &w) { w.clearCache(); w.clearHistory(); w.removeCookies(); } 而且这样也有利于用户自己扩充这些方法进行外部封装. 比如用户可能只需其中部分清理工作 void clearWebCacheAndHistory(WebBrowser &w) { w.clearCache(); w.clearHistory(); } Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-25 18:31:45 "},"docs/design/use_non_member.html":{"url":"docs/design/use_non_member.html","title":"何时采用non-member函数","keywords":"","body":"所有参数都需要隐式类型转换时采用non-member函数所有参数都需要隐式类型转换时采用non-member函数 class Rational { public: Rational(int numerator = 0, int denominator = 1) : numerator_(numerator) , denominator_(denominator) { } /* Rational a(1, 2); // 成员函数 operator * () 不能完成该操作, 左操作数无法转换为Rational Rational c = 2 * a; Rational operator * (const Rational &r) { return Rational(this->numerator_ * r.numerator_, this->denominator_ * r.denominator_); } */ int numerator() const { return numerator_; } int denominator() const { return denominator_; } private: int numerator_; int denominator_; }; Rational operator * (const Rational &l, const Rational &r) { /* 有时候可通过公共方法获取值, 而不必设置为friend函数 */ return Rational(l.numerator() * r.numerator(), l.denominator() * r.denominator()); } int main(void) { Rational a(1, 2), b(3, 4); Rational c = a * b; c = a * 2; c = 2 * a; return 0; } Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-25 18:31:45 "},"docs/design/delay.html":{"url":"docs/design/delay.html","title":"延迟变量定义式的出现时间","keywords":"","body":"延后变量定义式的出现时间延后变量定义式的出现时间 只要定义一个变量而其类型带有一个构造函数或析构函数，那么当程序的控制流到达这个变量定义式时，便要承受构造成本，当离开其作用域时，便承受析构成本；即使这个变量最终并未被使用。 void test(string s1) { string s2; if (s1.empty()) { /* 进入到该逻辑分支时，s2将不会被使用，或者是其它返回也是一样的效果 */ throw(\"s1 is emtpy\"); } /* 对象在构造时，尽量给一个有意义的初始值，不然后面赋值操作仍需要消耗成本 */ string s3(\"hello world\"); string s4; s4 = \"hello world\"; /* 应当在s4初始化时赋予初始值 */ /* ... ... */ } 对于循环体，应当考虑赋值成本与构造析构成本采取不同的方案 /* 方案一 */ Widget w; for (int i = 0; i 方案一：1个构造1个析构和n个赋值操作方案二：n个构造和n个析构 Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-25 18:31:45 "},"docs/design/less_transfer_type.html":{"url":"docs/design/less_transfer_type.html","title":"尽量少做转型动作","keywords":"","body":"尽量少做转型动作尽量少做转型动作 似是而非的代码,这些转型动作可能会出现非预期结果 #include class Base { public: Base() : baseNum_(10) { }; virtual void change() { baseNum_ = 50; }; void print() { std::cout (*this).change(); Base::change(); /* 使用该方式调用基类方法 */ derivedNum_ = 30; } void print() { std::cout (&d); pb->print(); return 0; } 使用类型转换是要消耗一定性能的;特别是使用dynamic_cast，向下转型会进行多次的class真实类型比较，很耗性能，深度继承和多重继承表现尤为明显。 Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-25 18:31:45 "},"docs/design/oo/":{"url":"docs/design/oo/","title":"继承和面向对象设计","keywords":"","body":"继承和面向对象设计继承和面向对象设计 多重继承比单一继承复杂，可能导致二义性，以及对virtual继承的需要。 virtual继承会增加大小、速度、初始化(及赋值)复杂度等等成本。如果virtual base classes不带任何数据，将是最具实用价值的情况。 如果单一继承能够做好，尽量不要使用多重继承 Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-25 18:31:45 "},"docs/design/oo/is-a.html":{"url":"docs/design/oo/is-a.html","title":"确定public继承塑模出is-a关系","keywords":"","body":"确定public继承塑模出is-a关系确定public继承塑模出is-a关系 公有继承意味着“is-a”的关系 如果class D以public形式继承class B，那么每一个类型为D的对象同时也是一个类型为B的对象，反之不成立。B表现一般化，D比B表现更特殊化 例如人和学生 class Person { /* ... ... */ }; class Student: public Person { /* ... ... */ }; 每个学生都是人，但人不一定是学生，而学生有所属学校，但这对人不成立。人的概念比学生更一般化，学生是人的一种特殊形式。 public继承和is-a之间的等价关系好像很简单，但有时候可能会被误导。 例如鸟和企鹅，鸟可以飞（一般都这么认为吧） class Bird { public: virtual void fly() { /* ... ... */ }; }; class Penguin: public Bird { /* ... ... */}; 但企鹅不会飞，这就违反了is-a，所以在设计之前应当了解类的相互关系之间的差异，并知道如何最好的塑造它们。 Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-25 18:31:45 "},"docs/design/oo/cover_name.html":{"url":"docs/design/oo/cover_name.html","title":"避免遮掩继承而来的名称","keywords":"","body":"避免遮掩继承而来的名称避免遮掩继承而来的名称 #include class Base { public: virtual void mf1() = 0; virtual void mf1(int) { std::cout 即使base classes 和 derived classes内的函数有不同的参数类型，也会被遮掩。 如果使用public继承而又不继承那些重载函数，就违反了base和derived之间的is-a关系 这时把Derived类稍微改动一下，就可以继续让上面注释掉的部分可以正确调用了 class Derived : public Base { public: using Base::mf1; using Base::mf3; virtual void mf1() { std::cout Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-25 18:31:45 "},"docs/design/oo/api_achieve.html":{"url":"docs/design/oo/api_achieve.html","title":"区分接口继承和实现继承","keywords":"","body":"区分接口继承和实现继承区分接口继承和实现继承 飞机需要一个fly方法，为了避免派生类写重复的代码，把基类的fly写成virtual的，让缺省情况下都是用默认的基类fly方法 class Airplane { virtual void fly() { }; }; class ModelA: pulic Airplane { }: class ModelB: pulic Airplane { }: 如果又有新的飞机子类加入，且需要自己的特殊fly方法（现有的默认fly不适合），那它就需要重写fly，但是如果该子类忘记写fly，这默认会使用基类的fly，会导致运行时出现不可预期的错误。这时需要把基类的fly声明为纯虚函数，并且实现，在需要默认fly方法的子类中实现一个fly调用父类的fly，在需要特殊的fly函数时就自己实现一套，而且如果因为忘记没有写，会在编译期就提示错误的。 #include class Airplane { public: virtual void fly() = 0; }; void Airplane::fly() { std::cout 如果确定是一个所有子类都通用的方法，那就在基类声明为non-virtual函数，所有的派生类都不该重写该方法，都应当使用基类的该方法。 纯虚函数具体指定接口继承虚函数具体指定接口继承及缺省实现继承non-virtual函数具体指定接口继承以及强制性实现继承 Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-25 18:31:45 "},"docs/design/oo/non_default.html":{"url":"docs/design/oo/non_default.html","title":"不要重新定义继承而来的缺省参数值","keywords":"","body":"不要重新定义继承而来的缺省参数值不要重新定义继承而来的缺省参数值 被声明指针类型是静态类型，不论它指向什么，它的静态类型是固定的。对象所谓的动态类型指“目前所指对象的类型”，也就是说动态类型可以表现出一个对象将会有什么行为。 #include class Base { public: /* * something是动态绑定的，但num却是静态绑定。 * 既调用一个派生类内的something函数时，使用的也是基类的缺省参数值 */ virtual void something(int num = 10) = 0; }; class Derived: public Base { public: /* 该缺省参数值设置其实是无效的，而且容易误导 */ virtual void something(int num = 20) { std::cout something(); /* 使用base类的默认值,而非派生类 */ return 0; } 所以，绝对不要重新定义一个继承而来的缺省参数值，因为缺省参数值是静态绑定，而virtual函数却是动态绑定的。 Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-25 18:31:45 "},"docs/design/oo/private.html":{"url":"docs/design/oo/private.html","title":"谨慎使用private继承","keywords":"","body":"谨慎使用private继承谨慎使用private继承 如果类之间继承关系是private，编译器不会自动将一个派生类对象转换为一个基类对象。由private继承而来的所有成员在派生类总都会变成private属性，这意味着只有实现部分被继承，接口部分被略去。 class Person { /* ... ... */ }; class Student: private Person { /* ... ... */ }; Person p; Student s; eat(p); /* 没问题 */ // eat(s); /* 错误，私有继承不能将派生类对象转换成一个基类对象，私有继承不是is-a的关系 */ 私有继承意味着“is-implemented-in-terms-of(根据某物实现出)”，在复合里面也具有同样的意义，在复合和私有继承之间，尽可能的选择复合，在必要时使用private继承(当protected成员或virtual函数牵扯进来的时候) 比如通过一个定时器来记录某个接口每个时间段被调用次数 class Timer { public: explicit Timer(int tickFrequercy); virtual void onTick() const; /* 每次统计一次一个时间段某个接口被调用的次数 */ /* ... ... */ }; class Widget /* public是is-a关系，但Widget和Timer不是一个东西，所以不能用public，这是设计理念 */ : private Timer { private: virtual void onTick() const; }; 但是private继承可以在派生类中重写继承的方法，有时候需要禁止重写(现代c++可以使用final关键字禁止重写)，就采用复合的方式 class Widget { private: /* 这样即使有派生类继承于Widget，也不可能重写统计方法了 */ class WidgetTimer: public Timer { public: virtual void onTick() const; }; WidgetTimer *ptimer_; }; 私有继承意味着is-implemented-in-terms-of。通常比复合的级别低，但是当派生类需要访问保护基类的成员或重新定义继承而来的虚函数时，需要使用私有继承而不是复合 还有一个没有举例，是复合相比，私有继承可以做到empty base最优化。这对致力于“对象尺寸最小化”的程序库而言很重要 Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-25 18:31:45 "},"docs/template/features.html":{"url":"docs/template/features.html","title":"模板编程特点","keywords":"","body":"模版编程优点缺点知识点模版编程 例子地址 优点 灵活性，可重用性和可可扩展性高 大大减少开发时间，模版可以把同一个算法适用于不同类型数据，在编译时确定具体的数据类型 模版模拟多态比c++类继承实现多态效率要高，无虚函数，无继承 缺点 易读性比较不好，调试比较困难 模版的数据类型职能在编译时才能被确定 所有用基于模版算法的实现必须包含在整个设计的.h头文件中，当工程比较大的时候，编译时间较长 知识点 模板的实现应该也在头文件里面. 在编译时模板并不能生成真正的二进制代码，而是在编译调用模板类或函数的CPP文件时才会去找对应的模板声明和实现，在这种情况下编译器是不知道实现模板类或函数的CPP文件的存在，所以它只能找到模板类或函数的声明而找不到实现，而只好创建一个符号寄希望于链接程序找地址。但模板类或函数的实现并不能被编译成二进制代码，结果链接程序找不到地址只好报错了 Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-25 18:31:45 "},"docs/template/typename.html":{"url":"docs/template/typename.html","title":"了解typename的双重意义","keywords":"","body":"了解typename的双重意义了解typename的双重意义 通常情况下使用 class 和 typename 没有什么不同 /* 两者一样 */ template class Widget; template class Widget; 但是遇到这样的代码会有歧义 template void print(const C &c) { /* ... ... */ C::const_iterator *x; /* 非法代码 */ /* ... ... */ } template内出现的名称如果依赖于某个template参数，称之为从属名称(dependent names)，如果从属名称在class内呈嵌套状，称它为嵌套从属名称(nested dependent name)。 C::const_iterator 本意意图为一个迭代器，它就是一个从属名称，实际上是一个嵌套从属名称。但是，C::const_iterator 可能有其它的意思；这里的 C::const_iterator *x 可以认为是声明一个local变量，是一个指针，指向 C::const_iterator 。但是如果 C::const_iterator 不是类型，而是C里面有个静态成员变量恰好名字为 const_iterator，或者如果x是个全局变量名称，那这样的话，上面的代码就变成了一个相乘的动作。 正确的方式 template void print(const C &c) { /* ... ... */ typename C::const_iterator *x; /* ... ... */ } 任何时候想要在template中指渉一个嵌套从属类型名称，就必须在紧邻它的前一个位置放上关键字 typename但是在这个规则之外，typename不可以出现在base classes list内的嵌套从属类型名称之前，也不能再member initialization list中作为base class修饰符。 template class Base { public: class Nested { public: Nested() { }; Nested(int x) { }; }; }; template class Derived: public Base::Nested /* base class list中不允许typename */ { public: explicit Derived(int x) : Base::Nested(x) /* member init list中不允许typename */ { /* * 嵌套从属类型名称 * 既不再base class list中，也不在member init list中 * 作为一个base class修饰符需要加上typename * */ typename Base::Nested temp; } }; int main(void) { Derived d(2); return 0; } Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-25 18:31:45 "},"docs/template/template_base.html":{"url":"docs/template/template_base.html","title":"处理模板化基类的名称","keywords":"","body":"处理模板化基类的名称处理模板化基类的名称 #include template class A { public: void mf1() { std::cout class B : public A { public: // void mf() { mf1();}; /* 这样写，编译器是不知道mf1的定义的 */ /* 用下面三种方法之一都可以完成正确的调用 */ void mf3() { this->mf1(); }; void mf5() { A::mf1(); }; /* 如果调用的是virtual函数，这里将使用基类的方法，导致virtual失效 */ using A::mf1; /* 这里使用会影响到mf3和mf5的，单独测试时需要注释掉这个 */ void mf4() { mf1(); }; }; /* 全特化*/ template <> class B { public: void mf2() { std::cout b; b.mf3(); b.mf4(); b.mf5(); B b2; /* 这里会匹配上全特化 */ // b2.mf3(); /* 全特化的这个没有mf3、mf4和mf5 */ b2.mf2(); /* 全特化里面只有mf2方法 */ return 0; } Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-25 18:31:45 "},"docs/template/type_conver_non_member.html":{"url":"docs/template/type_conver_non_member.html","title":"需要类型转换时为模板定义非成员函数","keywords":"","body":"需要类型转换时请为模板定义非成员函数需要类型转换时请为模板定义非成员函数 编写一个class template，它所提供的“与此template相关的”函数支持“所有参数之隐式类型转换”时，请将那些函数定义为“class template 内部的friend函数” template class Rational { public: Rational(const T &numerator = 0, const T &denominator = 1) : n_(numerator), d_(denominator) { } const T numerator() const { return n_; }; const T denominator() const { return d_; }; /* 这样写无法链接，这样只提供一个声明，编译器找不到定义 */ // friend const Rational operator * (const Rational &l, const Rational &r); /* 可以这样直接在类内写定义 */ friend const Rational operator * (const Rational &l, const Rational &r) { return Rational(l.numerator() * r.numerator(), l.denominator() * r.denominator()); } private: T n_; T d_; }; /* // 定义在外面，在类内友元无法具现化，将导致找不到链接 template const Rational operator * (const Rational &l, const Rational &r) { } */ int main(void) { Rational oneHalf(1, 2); Rational result = oneHalf * 2; return 0; } Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-25 18:31:45 "},"docs/template/template_metaprogramming.html":{"url":"docs/template/template_metaprogramming.html","title":"初识模板元编程","keywords":"","body":"初识模板元编程特点初识模板元编程 template元编程(template metaprogramming(TMP))是基于c++程序编写模板并执行于编译期的过程 特点 让某些事情更容易 可将工作从运行期转移到编译期 某些错误原本通常在运行期才能侦测到，现在可以在编译期找出来 使用TMP的c++程序可能在每一个方面都更高效 较小的可执行文件 较短的运行期 较少的内存需求 但是将工作从运行期转移到编译期会导致编译时间变长 下面是一个计算阶乘的例子，可以明显看出递归、迭代和模板元编程的速度差异模板元编程把计算放在了编译期，运行时每次获取阶乘结果都是一个已经计算好的常数，这使程序运行时速度得到很大的提升，而且占用更少的内存，而递归和迭代都是在运行期计算的，每次获取阶乘结果都要进行一遍计算，所以耗时较多。 #include #include /* 递归求阶乘 */ unsigned long int factorial(int n) { if (n == 0 || n == 1) { return 1; } return n * factorial(n - 1); } /* 模板元编程递归求阶乘 */ template struct Factorial { enum { value = n * Factorial::value }; }; template<> struct Factorial { enum { value = 1 }; }; /* 迭代求阶乘 */ unsigned long int factorial2(int n) { unsigned long int value = 1; for (int i = 2; i ::value; break; /* 这里用900是因为最大支持到900 */ case 3: factorial2(900); break; } } struct timeval tv2; gettimeofday(&tv2, NULL); unsigned long int t = ((tv2.tv_sec - tv1.tv_sec) * 1000 * 1000 + (tv2.tv_usec - tv1.tv_usec)); std::cout Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-25 18:31:45 "},"docs/other/variety.html":{"url":"docs/other/variety.html","title":"唯一不变的是变化","keywords":"","body":"唯一不变的是变化唯一不变的是变化 程序的维护者通常都不是当初的开发者，所以设计和实现时应该注意到如何帮助其他人理解、修改、强化你的程序 如果不希望某件事发生，那就尽量用特定的语法来杜绝，而不是仅仅添加一行警示的注释 如果一个类在设计时绝不打算成为派生类，那么就不应该只在头文件的class上端摆一行注释，而是应该以c++语法来阻止派生。 如果一个class要求其所有对象实体必须于heap内产生，那么请不要只告诉clients那么做，应该以特定的语法来约束该行为 如果目前不需要使用赋值函数和拷贝构造函数，那就声明delete 很多行为错误，可能发生于系统默认的赋值函数和默认拷贝构造函数 不要写一些与应有行为表现不一致的函数 这样的行为只有惊吓，没有惊喜，特别是重载操作符，一定要慎之又慎，不要出现怪异的行为，尽量和内建类型的行为保持一致 任何事情只要有人能够做，就会有人做（类似于墨菲定理） 只要编译没问题，就会有人做，所以，一定要让自己写的classes容易被正确的使用，不容易被误用。需要接受“用户是白痴”的事实。 尽量写出可移植的代码 尽可能的采用封装性质，尽可能让实现细节成为private 时间不断前进，我们与时俱进 Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-25 18:31:45 "},"docs/other/feel.html":{"url":"docs/other/feel.html","title":"忽略感觉","keywords":"","body":"忽略感觉忽略感觉 写代码时往往“觉得”通情达理，最后出错时就越难排查错误。忽略掉自己的感觉，以明确的方式和规范去写代码 代码通过编译，但并不表示就可以正常运作 Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-25 18:31:45 "},"docs/other/warning.html":{"url":"docs/other/warning.html","title":"不要太忽视警告","keywords":"","body":"不要太忽视警告不要太忽视警告 下面的代码可能有些编译器不会发出警告,这仅仅是个演示而已 #include class A { public: virtual void f() const { std::cout f(); /* 调用的是基类的函数，而并非是派生类的函数 */ return 0; } Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-25 18:31:45 "},"docs/other/other.html":{"url":"docs/other/other.html","title":"其他","keywords":"","body":"每当程序中需要使用强制类型转换时，不满足里氏替换原则，就应该警醒以下自己，是不是抽象层次不够 Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-25 18:31:45 "}}