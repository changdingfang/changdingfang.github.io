{"./":{"url":"./","title":"前言","keywords":"","body":"前言前言 用的时候Google总是出来一大堆不知道管不管用的答案, 一个个去试错, 浪费很多时间, 在这个python快查里面记录哪些我记不住, 又用得到的知识, 方便快查. Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-25 18:31:45 "},"docs/basic/list.html":{"url":"docs/basic/list.html","title":"list","keywords":"","body":"listlist完全相等比对list转字符串list list完全相等比对 内容一样, 顺序不一样 假设有如下两个列表 list1 = [\"one\", \"two\", \"three\"] list2 = [\"two\", \"three\", \"one\"] ` 不改变本身: 可以使用 sorted 方法排序在进行比对 sorted(list1) == sorted(list2) 改变本身: 使用list自带的sort排序后比对。 list1.sort() == list2.sort() list转字符串 # 1. list中全部为字符串 li1 = ['hello', 'world', 'nihao'] s1 = \",\".join(li1) # 转换成以逗号分割的字符串 # 2. list中有数字 li2 = [1, 2, 3, 4] s2 = [str(x) for x in li2] Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-25 18:31:45 "},"docs/basic/dict.html":{"url":"docs/basic/dict.html","title":"dict","keywords":"","body":"字典字典拷贝字典 字典拷贝 python的赋值, 默认为引用, 既修改副本会影响到原来的字典, 有时候可能需要一个完全独立的副本, 这时候就需要使用深拷贝来达到目的 python里面可以使用一些方法来根据需要拷贝字典数据 d1 = { \"k1\": \"hello\", \"k2\": \"world\", \"k3\": { \"m1\": \"haha\", \"m2\": \"enen\" } } d2 = d1 # 引用 d3 = d1.copy() # 父对象深拷贝，子对象浅拷贝。 d4 = copy.deepcopy(d1) # 深拷贝 Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-25 18:31:45 "},"docs/basic/set.html":{"url":"docs/basic/set.html","title":"list","keywords":"","body":"集合子集集合 子集 intersection() 方法用于返回两个或者更多集合的交集 setz = set.intersection(set1, set2 ... ...) 参数 set1 必须 set2 可选，更多集合的以逗号隔开 返回值 返回值为一个新的集合 示例 x = {\"1\", \"hello\", \"nihao\", \"world\"} y = {\"hello\", \"world\", \"1\"} z = x.intersection(y) print(z) # 输出为: {\"1\", \"hello\", \"world\"} Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-25 18:31:45 "},"docs/basic/except.html":{"url":"docs/basic/except.html","title":"异常捕捉","keywords":"","body":"异常捕获所有异常异常 捕获所有异常 try: ... except Exception as e: ... print ('reason: %s' % e) Exception 将会捕捉除SystemExit, KeyboardInterrupt和GeneratorExit之外的所有异常。如果想捕获这三个异常， 可以将Exception改成BaseException即可。 Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-25 18:31:45 "},"docs/basic/func.html":{"url":"docs/basic/func.html","title":"函数","keywords":"","body":"函数函数参数前面的星号函数 函数参数前面的星号 def foo1(pargm1, \\*pargm2): print(\"foo1 pargm1: {}\".format(pargm1)) print(\"foo1 pargm2: {}\".format(pargm2)) def foo2(pargm1, \\*\\*pargm2): print(\"foo2 pargm1: {}\".format(pargm1)) print(\"foo2 pargm2: {}\".format(pargm2)) foo1('t1', 't2', 't3', 't4') foo2('t1', t2 = 't2', t3 = 't3', t4 ='t4') 单星号 将所有参数以元组的形式导入 双星号 将所有参数以字典的形式导入 上面例子输出 foo1 pargm1: t1 foo1 pargm2: ('t2', 't3', 't4') foo2 pargm1: t1 foo2 pargm2: {'t4': 't4', 't2': 't2', 't3': 't3'} Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-25 18:31:45 "},"docs/apply/time_zone.html":{"url":"docs/apply/time_zone.html","title":"时区","keywords":"","body":"时区修改时区时区 修改时区 os.environ['TZ'] = 'Asia/Shanghai' Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-25 18:31:45 "},"docs/apply/logger.html":{"url":"docs/apply/logger.html","title":"日志","keywords":"","body":"logging模块logging模块 日志按时间循环产生和覆盖 import logging from logging.handlers import TimedRotatingFileHandler import time log_file = \"./output.log\" time_handler = TimedRotatingFileHandler(log_file, when='M', interval=1, backupCount=7) time_handler.suffix = '%Y-%m-%d-%H-%M' formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(lineno)d - %(module)s - %(message)s') time_handler.setFormatter(formatter) logger = logging.getLogger() logger.addHandler(time_handler) logger.setLevel(logging.DEBUG) TimedRotatingFileHandler类的参数含义 filename 日志文件名 when 一个字符串，用于描述滚动周期的基本单位 \"S\": Seconds \"M\": Minutes \"H\": Hours \"D\": Days \"W\": Week day(0 == Monday) interval 滚动周期，单位由when指定，比如when='D',interval=1，表示每天产生一个日志文件 backupCount 表示日志文件的保留的个数；不写则全部保存 对于文件日志大小的可以循环覆盖，但对于日期格式的，我测试的没有效果 Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-25 18:31:45 "},"docs/apply/module_info.html":{"url":"docs/apply/module_info.html","title":"模块信息","keywords":"","body":"模块信息获取模块版本号打印模块路径模块信息 获取模块版本号 import request print(request.__version__) 打印模块路径 import os import xxx print(os.path.dirname(xxx.__file__)) Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-25 18:31:45 "},"docs/apply/url.html":{"url":"docs/apply/url.html","title":"url解析","keywords":"","body":"url解析参考url解析 通常我使用 urllib.parse 对url进行解析但某些情况下可能没有 urllib.parse 需要做一个处理 # 详细文档说明: https://docs.python.org/3/library/urllib.parse.html try: from urllib.parse import urlparse except ImportError: import urlparse url = 'https://changdingfang.com?k1=hello&k2=world&k3=12345' # 获取key-value参数形式 params = urlparse.parse_qs(urlparse.urlsplit(url).query) # params = { # \"k1\": \"hello\", # \"k2\": \"world\", # \"k3\": 12345, # } 参考 将url拆分为各个组成部分 Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-25 18:31:45 "},"docs/apply/socket.html":{"url":"docs/apply/socket.html","title":"网络编程socket","keywords":"","body":"网络编程示例服务端客户端其他网络编程示例 服务端 #!/usr/python # -*- coding:utf-8 -*- import socket # 建立进程对象 sk = socket.socket() # 确定通信地址和端口 address = ('127.0.0.1',9082) # 绑定地址，通过bind绑定 sk.bind(address) # 监听连接信息。后面的参数数字代表最大等待数目，也就是允许几个客户端连接。如果服务端的个数超出这个个数，就会报错。 sk.listen(100) print('waiting....') # 提示等待连接中 f = open(\"test.txt\", \"ab+\"); conn,addr = sk.accept() cnt = 0 while True: mes = conn.recv(10240) cnt += 1 print(\"[%d], len: [%d]\" % (cnt, len(mes))) f.write(mes) sk.close() 客户端 #!/usr/python # -*- coding:utf-8 -*- import socket import json import time if __name__==\"__main__\": sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM) conn = 'unix通信scoket管道绝对路径' try: sock.connect(conn) except: print(\"connect error\") exit(-2) sock.send(\"url\") result_json = sock.recv(256) sock.close() print(result_json) 其他 可以看网络编程更详细一些的内容 网络编程 Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-25 18:31:45 "},"docs/apply/struct.html":{"url":"docs/apply/struct.html","title":"字节流打包拆包","keywords":"","body":"字节流打包拆包使用示例格式化符号与C语言类型对应关系表字节流打包拆包 python可以使用struct模块进行字节流打包拆包, 用于自定义协议传输数据 使用示例 import struct i1 = 1 i2 = 2 l1 = 1 f1 = 1.23456 s1 = \"hello world\" # s在使用时, 1个s对应一个字符, 一个字符串, 要取其长度个s进行封包(解包的时候也是如此) buf = struct.pack(\"iilf11s\", i1, i2, l1, f1, s1) print(\"buf len: {}\".format(len(buf))) # 打印16进制 print(\"buf: {}\".format(repr(buf))) # 解包 print(\"unpack:{}\".format(struct.unpack(\"iilf11s\", buf))) # char类型需要单个字符取出 c1 = 'c1c1' buf2 = struct.pack('4c', c1[0], c1[1], c1[2], c1[3]) print('buf2 len: {}'.format(len(buf2))) 格式化符号与C语言类型对应关系表 格式符 c语言类型 python类型 标准大小 x pad byte(填充字节) no value c char 长度为1的字符串 1 b signed char integer 1 B unsigned char integer 1 ? _Bool bool 1 h short integer 2 H unsigned short integer 2 i int integer 4 I long int integer 4 L unsigned long long 8 q long long long 8 Q unsigned long long long 8 f float float 4 d double float 4 s char[] string p char[] string P void * long Copyright © 2020-2021 ChangDingFang all right reserved，powered by Gitbook最近一次修订时间: 2021-08-25 18:31:45 "}}